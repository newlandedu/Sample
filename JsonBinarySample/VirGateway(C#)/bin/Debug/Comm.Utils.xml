<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Comm.Utils</name>
    </assembly>
    <members>
        <member name="T:Comm.Utils.SortType">
            <summary>
            排序方式
            </summary>
        </member>
        <member name="F:Comm.Utils.SortType.Default">
            <summary>
            默认排序
            </summary>
        </member>
        <member name="F:Comm.Utils.SortType.DisplayText">
            <summary>
            文本排序
            </summary>
        </member>
        <member name="F:Comm.Utils.SortType.Rank">
            <summary>
            等级排序
            </summary>
        </member>
        <member name="T:Comm.Utils.CacheHelper">
            <summary>
            Cache
            </summary>
        </member>
        <member name="M:Comm.Utils.CacheHelper.Insert(System.String,System.Object,System.Double)">
            <summary>
            增加一个缓存对象
            </summary>
            <param name="strKey">键</param>
            <param name="valueObj">值</param>
            <param name="duration">以秒为单位</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CacheHelper.IsExist(System.String)">
            <summary>
            判断缓存对象是否存在
            </summary>
            <param name="strKey"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CacheHelper.Read(System.String)">
            <summary>
            读取缓存对象
            </summary>
            <param name="strKey"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CacheHelper.Remove(System.String)">
            <summary>
            删除缓存对象
            </summary>
            <param name="strKey"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CacheHelper.RemoveByRegexp(System.String)">
            <summary>
            根据设置的正则表达式清除缓存对象
            </summary>
            <param name="pattern">正则表达式</param>
        </member>
        <member name="M:Comm.Utils.CacheHelper.Clear">
            <summary>
            清除所有缓存对象
            </summary>
        </member>
        <member name="M:Comm.Utils.CacheHelper.onRemove(System.String,System.Object,System.Web.Caching.CacheItemRemovedReason)">
            <summary>
            此方法在值失效之前调用，可以用于在失效之前更新数据库，或从数据库重新获取数据
            </summary>
            <param name="strKey"></param>
            <param name="obj"></param>
            <param name="reason"></param>
        </member>
        <member name="T:Comm.Utils.CookieHelper">
            <summary>
            Cookie操作类
            </summary>
        </member>
        <member name="P:Comm.Utils.CookieHelper.EncryptKey">
            <summary>
            反篡改密钥
            </summary>
        </member>
        <member name="M:Comm.Utils.CookieHelper.Set(System.String,System.String,System.Nullable{System.Int32},System.String,System.String)">
            <summary>
            创建COOKIE对象并赋Value值，修改COOKIE的Value值也用此方法，因为对COOKIE修改必须重新设expires
            </summary>
            <param name="cookieName">COOKIE对象名</param>
            <param name="cookieValue">COOKIE值,一般是string值</param>
            <param name="expires">COOKIE对象有效时间（秒数），空表示不设有效时间，1表示永久有效，大于等于2表示具体有效秒数，31536000秒=1年=(60*60*24*365)</param>
            <param name="domains">作用域,多个域名用;隔开</param>
            <param name="path">作用路径，默认"/"</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Comm.Utils.CookieHelper.Set(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Nullable{System.Int32},System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Comm.Utils.CookieHelper.Set(System.String,System.Object,System.Nullable{System.Int32},System.String,System.String)" -->
        <member name="M:Comm.Utils.CookieHelper.GetCookie(System.String)">
            <summary>
            获取HttpCookie对象
            </summary>
            <param name="cookieName">Cookie名称</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.Get(System.String)">
            <summary>
            读取Cookie的值，如果对象不存在，则返回null
            </summary>
            <param name="cookieName">Cookie名称</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.GetKey(System.String,System.String)">
            <summary>
            读取Cookie某个Key键的Value，如果对象不存在或keyName为空，则返回null
            </summary>
            <param name="cookieName">Cookie名称</param>
            <param name="keyName">Key键名</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.Edit(System.String,System.Object,System.Nullable{System.Int32})">
            <summary>
            修改COOKIE中值，操作成功返回true，无COOKIE返回false。
            </summary>
            <param name="cookieName">Cookie名称</param>
            <param name="cookieValue">Cookie值</param>
            <param name="expires">COOKIE对象有效时间（秒数），为null取不设定时间,1表示永久有效，大于等于2表示具体有效秒数，31536000秒=1年=(60*60*24*365)。</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.EditKey(System.String,System.String,System.Object,System.Nullable{System.Int32})">
            <summary>
            修改COOKIE中某个Key键的值 或 给某个COOKIE添加Key键 都调用本方法，操作成功返回true，无COOKIE返回false。
            </summary>
            <param name="cookieName">Cookie名称</param>
            <param name="keyName">Key键名</param>
            <param name="keyValue">Key键值</param>
            <param name="expires">COOKIE对象有效时间（秒数），为null取原始的时间,1表示永久有效，大于等于2表示具体有效秒数，31536000秒=1年=(60*60*24*365)。</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.Del(System.String,System.String,System.String)">
            <summary>
            删除COOKIE对象
            </summary>
            <param name="cookieName">Cookie对名称</param>
            <param name="domains">作用域,多个域名用;隔开</param>
            <param name="path">作用路径</param>
        </member>
        <member name="M:Comm.Utils.CookieHelper.DelKey(System.String,System.String)">
            <summary>
            删除某个COOKIE中某个Key子键
            </summary>
            <param name="cookieName">Cookie名称</param>
            <param name="keyName">Key键名</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.ExistCookie(System.String)">
            <summary>
            是否存在Cookie
            </summary>
            <param name="cookieName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.SelectDomain(System.String)">
            <summary>
            定位到正确的域
            </summary>
            <param name="strDomains"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.GetEncryptValue(System.Web.HttpCookie)">
            <summary>
            加密
            </summary>
            <param name="ck"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CookieHelper.ValidateCookies(System.Web.HttpCookie)">
            <summary>
             验证
            </summary>
            <param name="ck"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.ArrayBuffer`1">
             缓冲区的可能状态:
             <code>
             (1)
             ----====== data ======-----rspace----
                 |                 |             |
                 rd_nxt            wr_nxt        capacity-1
            (2)
             ==ldata==-------------==== rdata ====
                      |            |             |
                      wr_nxt       rd_nxt        capacity-1
             (3)
             ===ldata=============rdata===========(full of data)
                         |
                         wr_nxt(rd_nxt)
             (4)
             -------------------------------------(empty)
                       |
                       wr_nxt(rd_nxt)
             </code>
            <summary>
            使用字节数组来实现的缓冲区，类似Socket接收动作中的缓存区
            </summary>
            <typeparam name="T">所缓冲的数据类型</typeparam>
        </member>
        <member name="F:Comm.Utils.ArrayBuffer`1.DFLT_SIZE">
            <summary>
            默认大小.
            </summary>
        </member>
        <member name="F:Comm.Utils.ArrayBuffer`1.space">
            <summary>
            缓冲区还能容纳的元素数目.
            </summary>
        </member>
        <member name="F:Comm.Utils.ArrayBuffer`1.available">
            <summary>
            缓冲区中的数据元素数目.
            </summary>
        </member>
        <member name="F:Comm.Utils.ArrayBuffer`1.capacity">
            <summary>
            缓冲区的容量.注意 capacity 和 buf.Length 可以不相同, 前者小于或者等于后者.
            </summary>
        </member>
        <member name="F:Comm.Utils.ArrayBuffer`1.wr_nxt">
            <summary>
            下一次要将数据写入缓冲区的开始下标.
            </summary>
        </member>
        <member name="F:Comm.Utils.ArrayBuffer`1.rd_nxt">
            <summary>
            下一次读取接收缓冲区的开始下标.
            </summary>
        </member>
        <member name="F:Comm.Utils.ArrayBuffer`1.dataBuf">
            <summary>
            缓冲区所使用的数组.
            </summary>
        </member>
        <member name="F:Comm.Utils.ArrayBuffer`1.readSemaphore">
            <summary>
            如果当前缓冲区中有数据可读, 它将会被设置.
            </summary>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.#ctor">
            <summary>
            创建一个具体默认容量的缓冲区.
            </summary>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.#ctor(System.Int32)">
            <summary>
            创建一个指定容量的缓冲区.
            </summary>
            <param name="capacity">缓冲区的容量.</param>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.#ctor(`0[])">
            <summary>
            使用指定的数组来创建一个缓冲区.
            </summary>
            <param name="buf">缓冲区将要使用的数组.</param>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            使用指定的数组来创建一个缓冲区, 且该数组已经包含数据.
            </summary>
            <param name="buf">缓冲区将要使用的数组.</param>
            <param name="offset">数据在数组中的偏移.</param>
            <param name="size">数据的字节数.</param>
        </member>
        <member name="P:Comm.Utils.ArrayBuffer`1.Space">
            <summary>
            缓冲区还能容纳的元素数目.
            </summary>
        </member>
        <member name="P:Comm.Utils.ArrayBuffer`1.Available">
            <summary>
            缓冲区中可供读取的数据的元素数目
            </summary>
        </member>
        <member name="P:Comm.Utils.ArrayBuffer`1.Capacity">
            <summary>
            get, set 接收缓冲区的大小(元素数目). 默认值为 512K.
            Capacity 不能设置为小于 Available 的值(实现会忽略这样的值).
            </summary>
        </member>
        <member name="P:Comm.Utils.ArrayBuffer`1.ReadTimeout">
            <summary>
            Read 方法的超时时间(单位毫秒). 默认为 -1, 表示无限长.
            </summary>
        </member>
        <member name="P:Comm.Utils.ArrayBuffer`1.WriteTimeout">
            <summary>
            Write 方法的超时时间(单位毫秒). 默认为 -1, 表示无限长.
            </summary>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.Clear">
            <summary>
            清空本缓冲区.
            </summary>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.Read(`0[])">
            <summary>
            从缓冲区中读取数据. 读取的字节数一定是 buf.Length 和 Available 的较小者.
            </summary>
            <param name="buf">存储接收到的数据的缓冲区.</param>
            <returns>已经读取的字节数. 一定是 size 和 Available 的较小者.</returns>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.Read(`0[],System.Int32,System.Int32)">
            <summary>
            从缓冲区中读取数据. 读取的字节数一定是 size 和 Available 的较小者.
            本方法是线程安全的.
            </summary>
            <param name="buf">存储接收到的数据的缓冲区.</param>
            <param name="offset">buf 中存储所接收数据的位置.</param>
            <param name="size">要读取的字节数.</param>
            <returns>已经读取的字节数. 一定是 size 和 Available 的较小者.</returns>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.ReadData(`0[],System.Int32,System.Int32)">
            <summary>
            把本缓冲区的数据复制指定的数组中, 并移动读指针.
            </summary>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.Write(System.Byte[])">
            <summary>
            写入数据到缓冲区.
            </summary>
            <param name="buf">要写入的数据的缓冲区.</param>
        </member>
        <member name="M:Comm.Utils.ArrayBuffer`1.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入数据到缓冲区. 注意: 本方法不是线程安全的.
            </summary>
            <param name="buf">要写入的数据的缓冲区.</param>
            <param name="offset">数据缓冲区中要写入数据的起始位置.</param>
            <param name="size">要写入的字节数.</param>
            <exception cref="T:System.ApplicationException">如果空间不足, 会抛出异常.</exception>
        </member>
        <member name="T:Comm.Utils.DllImportInvoke">
            <summary>
            非托管DLL加载与方法调用
            </summary>
        </member>
        <member name="M:Comm.Utils.DllImportInvoke.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="M:Comm.Utils.DllImportInvoke.Import(System.String)">
            <summary>
            加载DLL
            </summary>
            <param name="dllPath"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.DllImportInvoke.Invoke(System.IntPtr,System.String,System.Type)">
            <summary>
            将要执行的函数转换为委托
            </summary>
            <param name="APIName"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.CodeTimer">
            <summary>
            性能计数器
            </summary>
        </member>
        <member name="M:Comm.Utils.CodeTimer.Initialize">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:Comm.Utils.CodeTimer.Time(System.String,System.Int32,System.Action)">
            <summary>
            计数
            </summary>
            <param name="name">名称</param>
            <param name="iteration">循环次数</param>
            <param name="action">需要执行的方法体</param>
        </member>
        <member name="M:Comm.Utils.CodeTimer.Time(System.String,System.Int32,System.Action,System.Action{System.String})">
            <summary>
            计数
            </summary>
            <param name="name">名称</param>
            <param name="iteration">循环次数</param>
            <param name="action">需要执行的方法体</param>
            <param name="output">输出需要执行的方法体</param>
        </member>
        <member name="T:Comm.Utils.AppCmdProcessorBase">
            <summary>
            应用程序命令行启动参数基类
            </summary>
        </member>
        <member name="P:Comm.Utils.AppCmdProcessorBase.Args">
            <summary>
            返回原始参数
            </summary>
        </member>
        <member name="M:Comm.Utils.AppCmdProcessorBase.#ctor(System.String[])">
            <summary>
            缺省构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.AppCmdProcessorBase.ArgsToProgramData">
            <summary>
            遍历执行
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.AppCmdProcessorBase.InitializeArguments">
            <summary>
            生成一组常用命令行散列表
            </summary>
        </member>
        <member name="M:Comm.Utils.AppCmdProcessorBase.DoExecuteArgument(Comm.Utils.CommandLineArgument)">
            <summary>
            执行Argument的每一个动作
            </summary>
            <param name="argument"></param>
        </member>
        <member name="M:Comm.Utils.AppCmdProcessorBase.DoExecuteNoArgument">
            <summary>
            没有启动参数时执行的动作
            </summary>
        </member>
        <member name="M:Comm.Utils.AppCmdProcessorBase.Run">
            <summary>
            执行
            </summary>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.ApplicationCommandLine">
            <summary>
            The purpose of the ApplicationCommandLine class is to allow application
            programmers the ability to avoid having to parse the command line,
            handling all of the complexities of the commandline, and allow them
            to focus on the data given in the command line.
            
            The ApplicationCommandLine class maps program defined data (instances of 
            CommandLineArgument) to actual command line input (thats the Main(String[] args) 
            input).  
            
            For the purpose of this class, there are two types inputs recieved on the
            command line.   Arguments that are deliniated with a delimter such as -, and
            arguments that are not deliniated.
            
            Arguments deliniated with a delimter are called cmdArgs and
            those that are not will be called fileArgs
            
            One thing to note, not all undelinated arguments are fileArgs.  Some of them could be
            data for a cmdArg.  In such case they are called dataArgs.  The content for dataArgs are
            stored with cmdArg class instances if the cmdArg is an instance of DataCommandLineArgument
            
            Example:  myprog -c -f notes.txt notes2.txt
            
            -c is a cmdArg
            -f is a cmdArg with a dataArg
            notes.txt is the dataArg for -f
            notes2.txt is a fileArg
            
            of course the above example assumes that -f is defined as a dataArg
            </summary>
        </member>
        <member name="F:Comm.Utils.ApplicationCommandLine._validArgPrefixes">
            <summary>
            identifies valid syntax for denoting a command line argument
            </summary>
        </member>
        <member name="F:Comm.Utils.ApplicationCommandLine._cmdArgs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Comm.Utils.ApplicationCommandLine._fileArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:Comm.Utils.ApplicationCommandLine.IsStartingWithArgPrefix(System.String)">
            <summary>
            search through the known acceptable argument prefixes and see if the 
            string input begins with one of them.
            
            This search is case sensitive 
            </summary>
            <param name="arg"></param>
            <returns>true if input begins with one of the items in _validArgPrefixes</returns>
        </member>
        <member name="M:Comm.Utils.ApplicationCommandLine.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ApplicationCommandLine.ParseCmdLineToArgs(System.String[])">
            <summary>
            Running through the array of commandline arguements
            compares them with _cmdArgs array and sets them
            to selected when found, and passes in data to them
            when the data is found
            </summary>
            <param name="args">string array, typically the string[] received from Main</param>
        </member>
        <member name="M:Comm.Utils.ApplicationCommandLine.AddArg(Comm.Utils.CommandLineArgument)">
            <summary>
            just adds an argument to the hash table
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:Comm.Utils.ApplicationCommandLine.ContainsArg(System.String)">
            <summary>
            是否包含启动参数
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="P:Comm.Utils.ApplicationCommandLine.Item(System.String)">
            <summary>
            获取命令行参数
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="P:Comm.Utils.ApplicationCommandLine.ArgCount">
            <summary>
            可控参数个数
            </summary>
        </member>
        <member name="P:Comm.Utils.ApplicationCommandLine.ArgumentPrefixes">
            <summary>
            
            </summary>
        </member>
        <member name="P:Comm.Utils.ApplicationCommandLine.FileArgs">
            <summary>
            
            </summary>
        </member>
        <member name="T:Comm.Utils.CommandLineArgument">
            <summary>
            This class represents a command line parameter (argument) that requires an option to
            set.  For example /? is a commandline argument that is valid for this class
            
            Used in conjuction with a ApplicationCommandLine instance
            </summary>
        </member>
        <member name="F:Comm.Utils.CommandLineArgument._argument">
            <summary>
            this is the argument identifer without the - or / 
            it can be anything, such as ? o overwrite, as long as its a single
            "word" (since spaces delimit command line arguments)
            </summary>
        </member>
        <member name="F:Comm.Utils.CommandLineArgument._helpText">
            <summary>
            this is text that will be printed when help is needed
            </summary>
        </member>
        <member name="F:Comm.Utils.CommandLineArgument._selected">
            <summary>
            indicates if this argument was chosen (found in the command line)
            </summary>
        </member>
        <member name="M:Comm.Utils.CommandLineArgument.SetSelected(System.Boolean)">
            <summary>
            sets the value for the _selected memeber
            made as a function so that derived classes 
            dont have to reimplement the Selected property
            but instead reimplement this function as needed
            </summary>
            <param name="state">bool, selected state</param>
        </member>
        <member name="M:Comm.Utils.CommandLineArgument.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="arg">string, argument identifier such as ?</param>
            <param name="help">string, text to help the user understand the meaninging of the argument</param>
        </member>
        <member name="M:Comm.Utils.CommandLineArgument.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="arg">string, argument identifier such as ?</param>
            <param name="help">string, text to help the user understand the meaninging of the argument</param>
            <param name="state">bool, selected state</param>
        </member>
        <member name="M:Comm.Utils.CommandLineArgument.ToString">
            <summary>
            
            </summary>
            <returns>string</returns>
        </member>
        <member name="P:Comm.Utils.CommandLineArgument.Argument">
            <summary>
            Property:  the argument identifer without the - or / 
            it can be anything, such as ? o overwrite, as long as its a single
            "word" (since spaces delimit command line arguments)
            </summary>
        </member>
        <member name="P:Comm.Utils.CommandLineArgument.HelpText">
            <summary>
            Property: text that will be printed when help is needed
            </summary>
        </member>
        <member name="P:Comm.Utils.CommandLineArgument.Selected">
            <summary>
            Property: indicates if this argument was chosen (found in the command line)
            </summary>
        </member>
        <member name="T:Comm.Utils.SwitchableCommandLineArgument">
            <summary>
            Switchable arguments are arguments that are exclusive of on another--for example
            lighton and lightoff would be switchable because light cannot be both on and off
            at the same time
            </summary>
        </member>
        <member name="F:Comm.Utils.SwitchableCommandLineArgument._switchArg">
            <summary>
            This is the counter point to the argument 
            digging into this can get recurvise and nasty
            </summary>
        </member>
        <member name="M:Comm.Utils.SwitchableCommandLineArgument.StateChangeTogglesRelativesState(System.Boolean)">
            <summary>
            should only be called from SetSelected
            it is communicated from a related SwitchableCommandLineArgument change
            in state
            </summary>
            <param name="state">bool, selected state</param>
        </member>
        <member name="M:Comm.Utils.SwitchableCommandLineArgument.SetSelected(System.Boolean)">
            <summary>
            Overides base class so that the related SwitchableCommandLineArgument member _switchArg
            selected state can be toggled to the opposite of this instance state will be 
            </summary>
            <param name="state">bool, selected state</param>
        </member>
        <member name="M:Comm.Utils.SwitchableCommandLineArgument.#ctor(System.String,System.String,Comm.Utils.SwitchableCommandLineArgument)">
            <summary>
            Constructor
            </summary>
            <param name="arg">string (parent), argument identifier such as ?</param>
            <param name="help">string (parent), text to help the user understand the meaninging of the argument</param>
            <param name="switchArg">Another argument that is exclusively tied to this argument</param>
        </member>
        <member name="M:Comm.Utils.SwitchableCommandLineArgument.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="arg"></param>
            <param name="help"></param>
        </member>
        <member name="P:Comm.Utils.SwitchableCommandLineArgument.SwitchArg">
            <summary>
            
            </summary>
        </member>
        <member name="T:Comm.Utils.DataCommandLineArgument">
            <summary>
            This class is for command line arguments that receive input after them
            such as -f myfile.txt 
            the argument is f and the data is myfile.txt
            all data is kept as text, users must decide how to translate it
            </summary>
        </member>
        <member name="F:Comm.Utils.DataCommandLineArgument._hasData">
            <summary>
            identifies if data was found
            </summary>
        </member>
        <member name="F:Comm.Utils.DataCommandLineArgument._data">
            <summary>
            the data its self
            </summary>
        </member>
        <member name="M:Comm.Utils.DataCommandLineArgument.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="arg"></param>
            <param name="help"></param>
        </member>
        <member name="M:Comm.Utils.DataCommandLineArgument.#ctor(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="arg"></param>
            <param name="help"></param>
        </member>
        <member name="P:Comm.Utils.DataCommandLineArgument.Data">
            <summary>
            
            </summary>
        </member>
        <member name="P:Comm.Utils.DataCommandLineArgument.HasData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Comm.Utils.CommandLineHelper.RunOnce(System.String,System.String)">
            <summary>
            RunOnce
            </summary>
            <param name="fileName"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CommandLineHelper.Run(System.String,System.String,System.String,System.String@)">
            <summary>
            运行外部程序并获取输出
            </summary>
            <param name="fileName">可执行文件</param>
            <param name="arguments">参数</param>
            <param name="errorMessage">异常信息</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.CommandLineHelper.Run(System.String,System.String,System.String@)">
            <summary>
            运行外部程序并获取输出
            </summary>
            <param name="fileName">可执行文件</param>
            <param name="arguments">参数</param>
            <param name="errorMessage">异常信息</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.CommandLineHelper.ReadProcessOutput(System.Diagnostics.Process,System.String,System.String@)">
            <summary>
            获取输出
            </summary>
            <param name="cmdLineProcess">执行进程</param>
            <param name="fileName">可执行文件</param>
            <param name="errorMessage">异常信息</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.CommandLineHelper.OpenLink(System.String)">
            <summary>
            打开网络地址
            </summary>
            <param name="url">网址</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:Comm.Utils.CommandLineHelper.OpenLinkByDefaultBrowser(System.String)">
            <summary>
            打开网络地址(使用默认浏览器)
            </summary>
            <param name="url">网址</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:Comm.Utils.CommandLineHelper.OpenLinkByIExplore(System.String)">
            <summary>
            打开网络地址(使用IE浏览器)
            </summary>
            <param name="url">网址</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:Comm.Utils.CommandLineHelper.GetText(System.String,System.String,System.Int32)">
            <summary>
            获取单个匹配内容
            </summary>
            <param name="sInput">输入内容</param>
            <param name="sRegex">表达式字符串</param>
            <param name="iGroupIndex">分组序号, 从1开始, 0不分组</param>
            <returns>匹配到的项</returns>
        </member>
        <member name="T:Comm.Utils.CryptoHelper">
            <summary>
             加密解密操作类
             </summary>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.MD5(System.String)">
            <summary>
            MD5加密（不可逆）
            </summary>
            <param name="source"></param>
            <returns>返回32位数的字符串，16字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.MD5Salt(System.String,System.String)">
            <summary>
            MD5加盐加密（不可逆）
            </summary>
            <param name="source"></param>
            <param name="salt"></param>
            <returns>返回32位数的字符串，16字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.MD516(System.String)">
            <summary>
            MD516位加密（不可逆）
            </summary>
            <param name="source"></param>
            <returns>返回16位数的字符串，8字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.MD516Salt(System.String,System.String)">
            <summary>
            MD516位加盐加密（不可逆）
            </summary>
            <param name="source"></param>
            <param name="salt"></param>
            <returns>返回16位数的字符串，8字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.SHA1(System.String)">
            <summary>
            SHA1加密
            </summary>
            <param name="source"></param>
            <returns>返回40位数的字符串，20字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.SHA256(System.String)">
            <summary>
            SHA256加密
            </summary>
            <param name="source"></param>
            <returns>返回64位数的字符串，32字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.SHA384(System.String)">
            <summary>
            SHA384加密
            </summary>
            <param name="source"></param>
            <returns>返回96位数的字符串，48字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.SHA512(System.String)">
            <summary>
            SHA512加密
            </summary>
            <param name="source"></param>
            <returns>返回128位数的字符串，64字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.HMACSHA1(System.String,System.String)">
            <summary>
            HMACSHA1加密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <returns>返回40位数的字符串，20字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.HMACSHA256(System.String,System.String)">
            <summary>
            HMACSHA256加密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <returns>返回40位数的字符串，20字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.HMACSHA384(System.String,System.String)">
            <summary>
            HMACSHA384加密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <returns>返回96位数的字符串，48字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.HMACSHA512(System.String,System.String)">
            <summary>
            HMACSHA512加密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <returns>返回128位数的字符串，64字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.HMACMD5(System.String,System.String)">
            <summary>
            HMACMD5加密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <returns>返回32位数的字符串，16字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.HMACRIPEMD160(System.String,System.String)">
            <summary>
            HMACRIPEMD160加密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <returns>返回40位数的字符串，20字节</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.RSA(System.String,System.String)">
            <summary>
            RSA加密
            </summary>
            <param name="source"></param>
            <param name="publicKey">公钥</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.RSADecrypt(System.String,System.String)">
            <summary>
            RSA解密
            </summary>
            <param name="source"></param>
            <param name="privateKey">私钥</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.DSA(System.String)">
            <summary>
             DSA加密
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.AES(System.String,System.String,System.Security.Cryptography.CipherMode,System.String,System.Security.Cryptography.PaddingMode)">
            <summary>  
            AES加密（别名Rijndael）
            </summary>  
            <param name="source">待加密字段</param>  
            <param name="keyVal">密钥值</param>  
            <param name="cipherMode">算法模式,默认CBC</param>  
            <param name="ivVal">加密向量</param> 
            <param name="paddingMode">补码方式，默认PKCS7</param>  
            <returns></returns>  
        </member>
        <member name="M:Comm.Utils.CryptoHelper.AESDecrypt(System.String,System.String,System.Security.Cryptography.CipherMode,System.String,System.Security.Cryptography.PaddingMode)">
            <summary>  
            AES解密
            </summary>  
            <param name="source">待加密字段</param>  
            <param name="keyVal">密钥值</param>  
            <param name="cipherMode">算法模式,默认CBC</param>  
            <param name="ivVal">加密辅助向量</param>  
            <param name="paddingMode">补码方式，默认PKCS7</param>  
            <returns></returns>  
        </member>
        <member name="M:Comm.Utils.CryptoHelper.AESByte(System.Byte[],System.String,System.Security.Cryptography.CipherMode,System.String,System.Security.Cryptography.PaddingMode)">
            <summary>  
            AES加密（别名Rijndael）
            </summary>  
            <param name="source">待加密字段</param>  
            <param name="keyVal">密钥值</param>  
            <param name="cipherMode">算法模式,默认CBC</param>  
            <param name="ivVal">加密向量</param> 
            <param name="paddingMode">补码方式，默认PKCS7</param>  
            <returns></returns>  
        </member>
        <member name="M:Comm.Utils.CryptoHelper.AESByteDecrypt(System.Byte[],System.String,System.Security.Cryptography.CipherMode,System.String,System.Security.Cryptography.PaddingMode)">
            <summary>  
            AES解密
            </summary>  
            <param name="source">待加密字段</param>  
            <param name="keyVal">密钥值</param>  
            <param name="cipherMode">算法模式,默认CBC</param>  
            <param name="ivVal">加密辅助向量</param>  
            <param name="paddingMode">补码方式，默认PKCS7</param>  
            <returns></returns>  
        </member>
        <member name="M:Comm.Utils.CryptoHelper.RSAKeyToPem(System.String,System.Boolean)">
            <summary>
            RSA密钥转Pem密钥
            </summary>
            <param name="RSAKey">RSA密钥</param>
            <param name="isPrivateKey">是否是私钥</param>
            <returns>Pem密钥</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.PemToRSAKey(System.String,System.Boolean)">
            <summary>
            Pem密钥转RSA密钥
            </summary>
            <param name="pemKey">Pem密钥</param>
            <param name="isPrivateKey">是否是私钥</param>
            <returns>RSA密钥</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.DES(System.String,System.String,System.String)">
            <summary>
            DES加密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <param name="ivVal"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.DESDecrypt(System.String,System.String,System.String)">
            <summary>
            DES解密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <param name="ivVal"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.DES3(System.String,System.String)">
            <summary>
            3DES加密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.DES3Decrypt(System.String,System.String)">
            <summary>
            DES3解密
            </summary>
            <param name="source"></param>
            <param name="keyVal"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.RC4(System.String,System.String)">
            <summary>
            RC4加密
            </summary>
            <param name="source"></param>
            <param name="ckey"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.RC4Decrypt(System.String,System.String)">
            <summary>
            RC4解密
            </summary>
            <param name="source"></param>
            <param name="ckey"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.RC4GetKey(System.Byte[],System.Int32)">
            <summary>
            打乱密码
            </summary>
            <param name="pass">密码</param>
            <param name="kLen">密码箱长度</param>
            <returns>打乱后的密码</returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.Base64(System.String)">
            <summary>
            BASE64加密
            </summary>
            <param name="source">待加密字段</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.Base64Decrypt(System.String)">
            <summary>
            BASE64解密
            </summary>
            <param name="source">待解密字段</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.Str2Bytes(System.String)">
            <summary>
            转成数组
            </summary>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.Bytes2Str(System.Collections.Generic.IEnumerable{System.Byte},System.String)">
            <summary>
            转换成字符串
            </summary>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.FormatByte(System.String,System.Text.Encoding)">
            <summary>
            获取字符串字符数组
            </summary>
            <param name="strVal"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CryptoHelper.HashAlgorithmBase(System.Security.Cryptography.HashAlgorithm,System.String,System.Text.Encoding,System.Int32,System.Int32)">
            <summary>
            HashAlgorithm 加密统一方法
            </summary>
            <param name="hashAlgorithmObj"></param>
            <param name="source"></param>
            <param name="encoding"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.LibRunState">
            <summary>
            运行状态
            </summary>
        </member>
        <member name="F:Comm.Utils.LibRunState.UnStart">
            <summary>
            未启动
            </summary>
        </member>
        <member name="F:Comm.Utils.LibRunState.Starting">
            <summary>
            启动中
            </summary>
        </member>
        <member name="F:Comm.Utils.LibRunState.StartFail">
            <summary>
            启动失败
            </summary>
        </member>
        <member name="F:Comm.Utils.LibRunState.Running">
            <summary>
            运行中
            </summary>
        </member>
        <member name="F:Comm.Utils.LibRunState.Stopped">
            <summary>
            已停止
            </summary>
        </member>
        <member name="T:Comm.Utils.Sequence">
            <summary>
            定义一组默认的序列
            </summary>
        </member>
        <member name="T:Comm.Utils.CommonEqualityComparer`2">
            <summary>
            公共比较器
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:Comm.Utils.DistinctExtensions">
            <summary>
            集合Distinct扩展
            </summary>
        </member>
        <member name="T:Comm.Utils.UploadReqEntityBase">
            <summary>
            上传请求实体
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadReqEntityBase.FileName">
            <summary>
            文件名
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadReqEntityBase.FileStream">
            <summary>
            文件流
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadReqEntityBase.LimitSize">
            <summary>
            文件大小限定（单位KB）
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadReqEntityBase.LimitType">
            <summary>
            文件类型限定（如.jpg/.png/.docx/.xlsx）
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadReqEntityBase.AbsoluteSaveDirectory">
            <summary>
            文件绝对保存目录
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadReqEntityBase.SaveFileNameMode">
            <summary>
            保存文件名方式，默认为Guid
            </summary>
        </member>
        <member name="T:Comm.Utils.UploadImgReqEntity">
            <summary>
            上传请求实体
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadImgReqEntity.IsThumb">
            <summary>
            是否保存略缩图（图片时有效）
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadImgReqEntity.ThumbMode">
            <summary>
            生成缩略图的方式
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadImgReqEntity.ThumbHeight">
            <summary>
            略缩图高度
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadImgReqEntity.ThumbWidth">
            <summary>
            略缩图宽度
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadImgReqEntity.IsWaterMark">
            <summary>
            是否打水印（图片时有效）
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadImgReqEntity.WaterMarkAbsFilePath">
            <summary>
            水印图片绝对路径
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadImgReqEntity.WaterMarkPosition">
            <summary>
            打水印的位置
            </summary>
        </member>
        <member name="T:Comm.Utils.UploadSaveFileNameMode">
            <summary>
            保存文件名方式
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadSaveFileNameMode.Guid">
            <summary>
            使用Guid 形式
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadSaveFileNameMode.Guid_OriginalName">
            <summary>
            使用 Guid_原始文件名 形式
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadSaveFileNameMode.YyyyMMddHHmmss">
            <summary>
            使用 yyyyMMddHHmmss 形式
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadSaveFileNameMode.YyyyMMddHHmmssJoin3Rnd">
            <summary>
            使用 yyyyMMddHHmmss加3位数字随机数 形式
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadSaveFileNameMode.OriginalName">
            <summary>
            原始文件名
            </summary>
        </member>
        <member name="T:Comm.Utils.UploadHandleLogic">
            <summary>
            上传操作逻辑
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadHandleLogic.BaseFileLogic">
            <summary>
            基本文件上传逻辑
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadHandleLogic.ImageFileLogic">
            <summary>
            图片文件上传逻辑
            </summary>
        </member>
        <member name="T:Comm.Utils.UploadThumbnailMode">
            <summary>
            缩略图生成方式
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadThumbnailMode.WH">
            <summary>
            指定宽高
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadThumbnailMode.W">
            <summary>
            指定宽，按比例缩放高
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadThumbnailMode.H">
            <summary>
            指定高，按比例缩放宽
            </summary>
        </member>
        <member name="T:Comm.Utils.UploadWaterMarkPosition">
            <summary>
            打水印位置
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadWaterMarkPosition.LeftTop">
            <summary>
            左上
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadWaterMarkPosition.LeftBottom">
            <summary>
            左下
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadWaterMarkPosition.RightTop">
            <summary>
            右上
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadWaterMarkPosition.RightBottom">
            <summary>
            右下
            </summary>
        </member>
        <member name="F:Comm.Utils.UploadWaterMarkPosition.Center">
            <summary>
            居中
            </summary>
        </member>
        <member name="T:Comm.Utils.UploadResEntityBase">
            <summary>
            上传响应实体
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadResEntityBase.FileName">
            <summary>
            原始文件名
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadResEntityBase.FileSaveName">
            <summary>
            保存后的文件名
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadResEntityBase.FileExtension">
            <summary>
            文件扩展名
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadResEntityBase.RelativeSaveDirectory">
            <summary>
            文件相对保存目录
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadResEntityBase.UniqueID">
            <summary>
            唯一标识
            </summary>
        </member>
        <member name="T:Comm.Utils.UploadImgResEntity">
            <summary>
            上传响应实体
            </summary>
        </member>
        <member name="P:Comm.Utils.UploadImgResEntity.ThumbFileName">
            <summary>
            缩略图文件名（为图片时无扩展名）
            </summary>
        </member>
        <member name="T:Comm.Utils.HttpMethod">
            <summary>
            Http Method 
            </summary>
        </member>
        <member name="F:Comm.Utils.HttpMethod.GET">
            <summary>
            从指定的url上获取内容
            </summary>
        </member>
        <member name="F:Comm.Utils.HttpMethod.POST">
            <summary>
            提交body中的内容给服务器中指定的url中，属于非幂等的(non-idempotent)请求
            </summary>
        </member>
        <member name="F:Comm.Utils.HttpMethod.HEAD">
            <summary>
            从指定的url上获取header内容(类似Get方式)
            </summary>
        </member>
        <member name="F:Comm.Utils.HttpMethod.TRACE">
            <summary>
            TRACE
            </summary>
        </member>
        <member name="F:Comm.Utils.HttpMethod.PUT">
            <summary>
            将body上传至服务器指定url处
            </summary>
        </member>
        <member name="F:Comm.Utils.HttpMethod.DELETE">
            <summary>
            在指定url处删除资源
            </summary>
        </member>
        <member name="F:Comm.Utils.HttpMethod.OPTIONS">
            <summary>
            获取指定url中能接收的请求方法
            </summary>
        </member>
        <member name="F:Comm.Utils.HttpMethod.CONNECT">
            <summary>
             连接指定频段。当客户端需要通过代理服务器连接HTTPS服务器是用到
            </summary>
        </member>
        <member name="T:Comm.Utils.HttpReqEntity">
            <summary>
            HTTP请求实体
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpReqEntity.Method">
            <summary>
            请求方式
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpReqEntity.Encoding">
            <summary>
            请求编码
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpReqEntity.ContentType">
            <summary>
            请求格式
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpReqEntity.Headers">
            <summary>
            附包头集合
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpReqEntity.Cookies">
            <summary>
            附Cookies值
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpReqEntity.Datas">
            <summary>
            附包体数据
            </summary>
        </member>
        <member name="M:Comm.Utils.HttpReqEntity.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.HttpResEntity">
            <summary>
            HTTP响应实体
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpResEntity.Headers">
            <summary>
            包头集合
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpResEntity.Bodys">
            <summary>
            HTML/JSON等内容
            </summary>
        </member>
        <member name="P:Comm.Utils.HttpResEntity.Cookies">
            <summary>
            Cookies值
            </summary>
        </member>
        <member name="T:Comm.Utils.CallFuncKind">
            <summary>
            发送数据的类型
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.ServerStarted">
            <summary>
            服务端启动
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.ServerStopped">
            <summary>
            服务停止
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.ClientInit">
            <summary>
            客户端初始化
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.ClientStarted">
            <summary>
            客户端启动
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.OtherClientInit">
            <summary>
            其它客户端启动
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.ClientStopped">
            <summary>
            客户端停止
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.CheckClientExits">
            <summary>
            检查客户端是否存在
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.GetClients">
            <summary>
            取得客户端列表
            </summary>
        </member>
        <member name="F:Comm.Utils.CallFuncKind.NotifyServerExit">
            <summary>
            通知服务端退出
            </summary>
        </member>
        <member name="T:Comm.Utils.IIPCMessage">
            <summary>
            Remoting IPC 透明对象接口
            </summary>
        </member>
        <member name="M:Comm.Utils.IIPCMessage.DoExecuteMethod(System.String,System.Object,Comm.Utils.ReceiveResult@)">
            <summary>
            执行服务端的万能方法，此方法由客户端调用，服务端处理方法转接
            </summary>
            <param name="method">要执行的方法名称</param>
            <param name="args">执行方法的参数</param>
            <param name="result">接收数据对象</param> 
        </member>
        <member name="M:Comm.Utils.IIPCMessage.ClientRegister(System.String,Comm.Utils.ReceiveEventHandler)">
            <summary>
            服务端注册，以便可以接收服务端发送过来的数据
            </summary>
            <param name="key">客户端唯一标识</param>
            <param name="handler">接收数据委托</param>
            <returns>是否注册成功</returns>
        </member>
        <member name="M:Comm.Utils.IIPCMessage.IsConnect">
            <summary>
            是否连接上
            </summary>
            <returns></returns>
        </member>
        <member name="F:Comm.Utils.RemotingIPCDefine.ServerName">
            <summary>
            进行IPC通信的服务器端名称
            </summary>
        </member>
        <member name="F:Comm.Utils.RemotingIPCDefine.ServerUrl">
            <summary>
            进行IPC通信的客户端连接地址
            </summary>
        </member>
        <member name="T:Comm.Utils.ReceiveEventWrapper">
            <summary>
            接收数据事件壳
            </summary>
        </member>
        <member name="E:Comm.Utils.ReceiveEventWrapper.ReceiveEvent">
            <summary>
            接收数据事件
            </summary>
        </member>
        <member name="M:Comm.Utils.ReceiveEventWrapper.Receive(System.String,System.Object,Comm.Utils.ReceiveResult@)">
            <summary>
            接收数据转接的方法
            </summary>
            <param name="method">要执行的方法名称</param>
            <param name="args">执行方法的参数</param>
            <param name="result">接收数据对象</param>
        </member>
        <member name="T:Comm.Utils.RemotingIPCServer">
            <summary>
            Remoting IPC服务端
            <example>
            初始一个服务例如下：
            第1步实例对象、RemotingIPCServer IpcServer = new RemotingIPCServer("IpcServer");
            第2步订阅事件、IpcServer.Receive += IpcServer_Receive;所有的传送数据都在事件处理程序里面进行
            第3步开启服务、IpcServer.StartServer();
            </example>
            </summary>
        </member>
        <member name="E:Comm.Utils.RemotingIPCServer.Receive">
             <summary>
            服务端接收事件
             </summary>
        </member>
        <member name="P:Comm.Utils.RemotingIPCServer.IsStop">
            <summary>
            获取一个值表示是否停止工作
            </summary>
        </member>
        <member name="P:Comm.Utils.RemotingIPCServer.HasClient">
            <summary>
            是否拥有客户端
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="key">端口名</param>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.StartServer">
            <summary>
            启动服务器.
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.PauseServer">
            <summary>
            暂停服务器
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.CloseServer">
            <summary>
            关闭服务端
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.SendTo(System.String,System.Object)">
            <summary>
            发送数据到客务端 ,发送只对当前的客户端 currentClientKey
            </summary>
            <param name="method">要执行的方法标识</param>
            <param name="args">要执行的方法参数</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.SendTo(Comm.Utils.CallFuncKind,System.Object)">
            <summary>
            发送数据到客务端 ,发送只对当前的客户端 currentClientKey
            </summary>
            <param name="method">要执行的方法标识</param>
            <param name="args">要执行的方法参数</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.ExistClient">
            <summary>
            客户端是否存在
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.DoExecuteMethod(System.String,System.Object,Comm.Utils.ReceiveResult@)">
            <summary>
            执行服务端的万能方法，此方法由客户端调用，服务端处理方法转接
            </summary>
            <param name="method">要执行的方法名称</param>
            <param name="args">执行方法的参数</param>
            <param name="result">接收数据对象</param> 
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.ClientRegister(System.String,Comm.Utils.ReceiveEventHandler)">
            <summary>
            服务端注册，以便可以接收服务端发送过来的数据
            </summary>
            <param name="key">客户端唯一标识</param>
            <param name="handler">接收数据委托</param>
            <returns>是否注册成功</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.IsConnect">
            <summary>
            是否连接
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCServer.FormClientStarted(System.Object,Comm.Utils.ReceiveResult@)">
            <summary>
            客户端启动
            </summary>
            <param name="args"></param>
            <param name="result"></param>
        </member>
        <member name="T:Comm.Utils.RemotingClientInfo">
            <summary>
            Remting 客户端信息列表
            </summary>
        </member>
        <member name="P:Comm.Utils.RemotingClientInfo.Effective">
            <summary>
            是否为有效的客户端用户
            </summary>
        </member>
        <member name="P:Comm.Utils.RemotingClientInfo.Key">
            <summary>
            客户端 唯一标识
            </summary>
        </member>
        <member name="P:Comm.Utils.RemotingClientInfo.Handler">
             <summary>
            查看 <see cref="T:Comm.Utils.ReceiveEventHandler"/>对象
             </summary>
        </member>
        <member name="T:Comm.Utils.RemotingIPCBase">
            <summary>
            Remoting 通信基类
            </summary>
        </member>
        <member name="P:Comm.Utils.RemotingIPCBase.Key">
            <summary>
            获取一个值，表示唯一标识
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCBase.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Comm.Utils.RemotingIPCBase.SendTo(System.String,System.Object)">
            <summary>
            发送
            </summary>
            <param name="method">方法标识</param>
            <param name="args">参数</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCBase.SendTo(Comm.Utils.CallFuncKind,System.Object)">
            <summary>
            发送
            </summary>
            <param name="method">方法标识</param>
            <param name="args">参数</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCBase.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCBase.InitializeLifetimeService">
            <summary>
            InitializeLifetimeService
            </summary>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.ReceiveResult">
            <summary>
            接收数据对象
            </summary>
        </member>
        <member name="P:Comm.Utils.ReceiveResult.Value">
            <summary>
            接收数据值
            </summary>
        </member>
        <member name="T:Comm.Utils.ReceiveEventHandler">
            <summary>
            Remoting IPC 接收数据委托
            </summary>
            <param name="methodName">执行方法的标识</param>
            <param name="arges">执行方法对应的参数，此参数必须可序列化的</param>
            <returns>执行方法后的返回值</returns>
        </member>
        <member name="T:Comm.Utils.RemotingIPCClient">
            <summary>
            为IPC通信提供客户端管理.
            </summary>
            <example>
            初始一个客户端例如下：
            第1步实例对象、RemotingIPCClient IpcClient = new RemotingIPCClient("Client1", "IpcServer");
            第2步订阅事件、IpcClient.Receive += IpcClient_Receive;所有的传送数据都在事件处理程序里面进行
            第3步开启服务、IpcClient.StartClient();
            </example>
        </member>
        <member name="E:Comm.Utils.RemotingIPCClient.Receive">
            <summary>
            Window 进程消息系统接收数据事件
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.#ctor(System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.GetIPCMessage">
            <summary>
            获取消息中心业务接口对象
            </summary>
            <returns>消息中心业务接口对象</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.Connect">
            <summary>
            为IPC通信提供连接服务端的接口方法
            </summary>
            <returns>返回IPC通信数据访问接口</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.OnWrapperReceiveEvent(System.String,System.Object,Comm.Utils.ReceiveResult@)">
            <summary>
            OnWrapperReceiveEvent
            </summary>
            <param name="methodName"></param>
            <param name="arges"></param>
            <param name="result"></param>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.OnReceive(System.String,System.Object,Comm.Utils.ReceiveResult@)">
            <summary>
            OnReceive
            </summary>
            <param name="method"></param>
            <param name="args"></param>
            <param name="result"></param>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.ClientStop(System.Object)">
            <summary>
            ClientStop
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.ServerStarted(System.Object)">
            <summary>
            ServerStarted
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.ReceiveClientInitialize(System.Object)">
            <summary>
            ReceiveClientInitialize
            </summary>
            <param name="args"></param>
        </member>
        <member name="P:Comm.Utils.RemotingIPCClient.ServerExists">
             <summary>
            获取服务端是否存在
             </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.ReConnect">
            <summary>
            重连接
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.SendTo(System.String,System.Object)">
            <summary>
            发送数据到服务端
            </summary>
            <param name="method">方法标识</param>
            <param name="args">参数</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.SendTo(Comm.Utils.CallFuncKind,System.Object)">
            <summary>
            发送数据到服务端
            </summary>
            <param name="method">方法标识</param>
            <param name="args">参数</param>
            <returns>返回值</returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.StartClient">
            <summary>
            开起客户端
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.GetClients">
            <summary>
            取得当前IPC已存在客户端列表
            </summary>
            <returns>为null 说明IPC服务端还没有启动，Length=0 则没有客户端 Length>0 表示有客户端 </returns>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.Close">
            <summary>
            退出客户端
            </summary>
        </member>
        <member name="M:Comm.Utils.RemotingIPCClient.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaFunction">
            <summary>
            Type for C# callbacks
            In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, lua_gettop(L) returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index lua_gettop(L). To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results. 
            </summary>
            <param name="luaState"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaHookFunction">
            <summary>
            Type for debugging hook functions callbacks. 
            </summary>
            <param name="luaState"></param>
            <param name="ar"></param>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaKFunction">
            <summary>
            Type for continuation functions 
            </summary>
            <param name="L"></param>
            <param name="status"></param>
            <param name="ctx"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaReader">
            <summary>
            The reader function used by lua_load. Every time it needs another piece of the chunk, lua_load calls the reader, passing along its data parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set size to the block size
            </summary>
            <param name="L"></param>
            <param name="ud"></param>
            <param name="sz"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaWriter">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="p"></param>
            <param name="size"></param>
            <param name="ud"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaAlloc">
            <summary>
            The type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to realloc
            </summary>
            <param name="ud"></param>
            <param name="ptr"></param>
            <param name="osize"></param>
            <param name="nsize"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.KeraLua.Lua">
            <summary>
            Lua state class, main interface to use Lua library.
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.Handle">
            <summary>
            Internal Lua handle pointer.
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.Encoding">
            <summary>
            Encoding for the string conversions
            ASCII by default.
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.ExtraSpace">
            <summary>
             Returns a pointer to a raw memory area associated with the given Lua state. The application can use this area for any purpose; Lua does not use it for anything.
             Each new thread has this area initialized with a copy of the area of the main thread. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.MainThread">
            <summary>
            Get the main thread object, if the object is the main thread will be equal this
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.#ctor(System.Boolean)">
            <summary>
            Initialize Lua state, and open the default libs
            </summary>
            <param name="openLibs">flag to enable/disable opening the default libs</param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.#ctor(Comm.Utils.KeraLua.LuaAlloc,System.IntPtr)">
            <summary>
            Initialize Lua state with allocator function and user data value
            This method will NOT open the default libs.
            Creates a new thread running in a new, independent state. Returns NULL if it cannot create the thread or the state (due to lack of memory). The argument f is the allocator function; Lua does all memory allocation for this state through this function (see lua_Alloc). The second argument, ud, is an opaque pointer that Lua passes to the allocator in every call. 
            </summary>
            <param name="allocator">LuaAlloc allocator function called to alloc/free memory</param>
            <param name="ud">opaque pointer passed to allocator</param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.FromIntPtr(System.IntPtr)">
            <summary>
            Get the Lua object from IntPtr
            Useful for LuaFunction callbacks, if the Lua object was already collected will return null.
            </summary>
            <param name="luaState"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Finalize">
            <summary>
            Finalizer, will dispose the lua state if wasn't closed
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Dispose(System.Boolean)">
            <summary>
            Dispose lua state
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Close">
            <summary>
            Destroys all objects in the given Lua state (calling the corresponding garbage-collection metamethods, if any) and frees all dynamic memory used by this state
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Dispose">
            <summary>
            Dispose the lua context (calling Close)
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.AbsIndex(System.Int32)">
            <summary>
            Converts the acceptable index idx into an equivalent absolute index (that is, one that does not depend on the stack top). 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Arith(Comm.Utils.KeraLua.LuaOperation)">
            <summary>
            Performs an arithmetic or bitwise operation over the two values (or one, in the case of negations) at the top of the stack, with the value at the top being the second operand, pops these values, and pushes the result of the operation. The function follows the semantics of the corresponding Lua operator (that is, it may call metamethods). 
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.AtPanic(Comm.Utils.KeraLua.LuaFunction)">
            <summary>
            Sets a new panic function and returns the old one
            </summary>
            <param name="panicFunction"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Call(System.Int32,System.Int32)">
            <summary>
             Calls a function. 
             To call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order;
             that is, the first argument is pushed first. Finally you call lua_call; nargs is the number of arguments that you pushed onto the stack.
             All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns.
             The number of results is adjusted to nresults, unless nresults is LUA_MULTRET. In this case, all results from the function are pushed;
             Lua takes care that the returned values fit into the stack space, but it does not ensure any extra space in the stack. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack. 
            </summary>
            <param name="arguments"></param>
            <param name="results"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CallK(System.Int32,System.Int32,System.Int32,Comm.Utils.KeraLua.LuaKFunction)">
            <summary>
            This function behaves exactly like lua_call, but allows the called function to yield 
            </summary>
            <param name="arguments"></param>
            <param name="results"></param>
            <param name="context"></param>
            <param name="continuation"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckStack(System.Int32)">
            <summary>
            Ensures that the stack has space for at least n extra slots (that is, that you can safely push up to n values into it). It returns false if it cannot fulfill the request,
            </summary>
            <param name="nExtraSlots"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Compare(System.Int32,System.Int32,Comm.Utils.KeraLua.LuaCompare)">
            <summary>
            Compares two Lua values. Returns 1 if the value at index index1 satisfies op when compared with the value at index index2
            </summary>
            <param name="index1"></param>
            <param name="index2"></param>
            <param name="comparison"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Concat(System.Int32)">
            <summary>
            Concatenates the n values at the top of the stack, pops them, and leaves the result at the top. If n is 1, the result is the single value on the stack (that is, the function does nothing);
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Copy(System.Int32,System.Int32)">
            <summary>
            Copies the element at index fromidx into the valid index toidx, replacing the value at that position
            </summary>
            <param name="fromIndex"></param>
            <param name="toIndex"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CreateTable(System.Int32,System.Int32)">
            <summary>
            Creates a new empty table and pushes it onto the stack. Parameter narr is a hint for how many elements the table will have as a sequence; parameter nrec is a hint for how many other elements the table will have
            </summary>
            <param name="elements"></param>
            <param name="records"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Dump(Comm.Utils.KeraLua.LuaWriter,System.IntPtr,System.Boolean)">
            <summary>
            Dumps a function as a binary chunk. Receives a Lua function on the top of the stack and produces a binary chunk that, if loaded again, results in a function equivalent to the one dumped
            </summary>
            <param name="writer"></param>
            <param name="data"></param>
            <param name="stripDebug"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Error">
            <summary>
            Generates a Lua error, using the value at the top of the stack as the error object. This function does a long jump
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GarbageCollector(Comm.Utils.KeraLua.LuaGC,System.Int32)">
            <summary>
            Controls the garbage collector. 
            </summary>
            <param name="what"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetAllocFunction(System.IntPtr@)">
            <summary>
            Returns the memory-allocation function of a given state. If ud is not NULL, Lua stores in *ud the opaque pointer given when the memory-allocator function was set. 
            </summary>
            <param name="ud"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetField(System.Int32,System.String)">
            <summary>
             Pushes onto the stack the value t[k], where t is the value at the given index. As in Lua, this function may trigger a metamethod for the "index" event (see ?.4).
            Returns the type of the pushed value. 
            </summary>
            <param name="index"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetField(Comm.Utils.KeraLua.LuaRegistry,System.String)">
            <summary>
             Pushes onto the stack the value t[k], where t is the value at the given index. As in Lua, this function may trigger a metamethod for the "index" event (see ?.4).
            Returns the type of the pushed value. 
            </summary>
            <param name="index"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetGlobal(System.String)">
            <summary>
            Pushes onto the stack the value of the global name. Returns the type of that value
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetInteger(System.Int32,System.Int64)">
            <summary>
            Pushes onto the stack the value t[i], where t is the value at the given index
            </summary>
            <param name="index"></param>
            <param name="i"></param>
            <returns> Returns the type of the pushed value</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetInfo(System.String,System.IntPtr)">
            <summary>
            Gets information about a specific function or function invocation. 
            </summary>
            <param name="what"></param>
            <param name="ar"></param>
            <returns>This function returns false on error (for instance, an invalid option in what). </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetInfo(System.String,Comm.Utils.KeraLua.LuaDebug@)">
            <summary>
            Gets information about a specific function or function invocation. 
            </summary>
            <param name="what"></param>
            <param name="ar"></param>
            <returns>This function returns false on error (for instance, an invalid option in what). </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetLocal(System.IntPtr,System.Int32)">
            <summary>
            Gets information about a local variable of a given activation record or a given function. 
            </summary>
            <param name="ar"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetLocal(Comm.Utils.KeraLua.LuaDebug,System.Int32)">
            <summary>
            Gets information about a local variable of a given activation record or a given function. 
            </summary>
            <param name="ar"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetMetaTable(System.Int32)">
            <summary>
            If the value at the given index has a metatable, the function pushes that metatable onto the stack and returns 1
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetStack(System.Int32,System.IntPtr)">
            <summary>
            Gets information about the interpreter runtime stack. 
            </summary>
            <param name="level"></param>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetStack(System.Int32,Comm.Utils.KeraLua.LuaDebug@)">
            <summary>
            Gets information about the interpreter runtime stack. 
            </summary>
            <param name="level"></param>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetTable(System.Int32)">
            <summary>
            Pushes onto the stack the value t[k], where t is the value at the given index and k is the value at the top of the stack. 
            </summary>
            <param name="index"></param>
            <returns>Returns the type of the pushed value</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetTable(Comm.Utils.KeraLua.LuaRegistry)">
            <summary>
            Pushes onto the stack the value t[k], where t is the value at the given index and k is the value at the top of the stack. 
            </summary>
            <param name="index"></param>
            <returns>Returns the type of the pushed value</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetTop">
            <summary>
            Returns the index of the top element in the stack. 0 means an empty stack.
            </summary>
            <returns>Returns the index of the top element in the stack.</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetUserValue(System.Int32)">
            <summary>
            Pushes onto the stack the Lua value associated with the full userdata at the given index. 
            </summary>
            <param name="index"></param>
            <returns>Returns the type of the pushed value. </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetUpValue(System.Int32,System.Int32)">
            <summary>
             Gets information about the n-th upvalue of the closure at index funcindex. It pushes the upvalue's value onto the stack and returns its name. Returns NULL (and pushes nothing) when the index n is greater than the number of upvalues.
             For C functions, this function uses the empty string "" as a name for all upvalues. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.)
             Upvalues have no particular order, as they are active through the whole function. They are numbered in an arbitrary order. 
            </summary>
            <param name="functionIndex"></param>
            <param name="n"></param>
            <returns>Returns the type of the pushed value. </returns>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.Hook">
            <summary>
            Returns the current hook function. 
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.HookCount">
            <summary>
            Returns the current hook count. 
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.HookMask">
            <summary>
            Returns the current hook mask. 
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Insert(System.Int32)">
            <summary>
            Moves the top element into the given valid index, shifting up the elements above this index to open space. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position. 
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsBoolean(System.Int32)">
            <summary>
            Returns  if the value at the given index is a boolean
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsCFunction(System.Int32)">
            <summary>
            Returns  if the value at the given index is a C(#) function
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsFunction(System.Int32)">
            <summary>
            Returns  if the value at the given index is a function
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsInteger(System.Int32)">
            <summary>
            Returns  if the value at the given index is an integer
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsLightUserData(System.Int32)">
            <summary>
            Returns  if the value at the given index is light user data
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsNil(System.Int32)">
            <summary>
            Returns  if the value at the given index is nil
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsNone(System.Int32)">
            <summary>
            Returns  if the value at the given index is none
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsNoneOrNil(System.Int32)">
            <summary>
            Check if the value at the index is none or nil
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsNumber(System.Int32)">
            <summary>
            Returns  if the value at the given index is a number
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsStringOrNumber(System.Int32)">
            <summary>
            Returns  if the value at the given index is a string or a number (which is always convertible to a string)
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsString(System.Int32)">
            <summary>
            Returns  if the value at the given index is a string
            NOTE: This is different from the lua_isstring, which return true if the value is a number
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsTable(System.Int32)">
            <summary>
            Returns  if the value at the given index is a table. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsThread(System.Int32)">
            <summary>
            Returns  if the value at the given index is a thread. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.IsUserData(System.Int32)">
            <summary>
            Returns  if the value at the given index is a user data. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.IsYieldable">
            <summary>
            Returns  if the given coroutine can yield, and 0 otherwise
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushLength(System.Int32)">
            <summary>
            Push the length of the value at the given index on the stack. It is equivalent to the '#' operator in Lua (see ?.4.7) and may trigger a metamethod for the "length" event (see ?.4). The result is pushed on the stack. 
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Load(Comm.Utils.KeraLua.LuaReader,System.IntPtr,System.String,System.String)">
            <summary>
            Loads a Lua chunk without running it. If there are no errors, lua_load pushes the compiled chunk as a Lua function on top of the stack. Otherwise, it pushes an error message. 
            The lua_load function uses a user-supplied reader function to read the chunk (see lua_Reader). The data argument is an opaque value passed to the reader function. 
            </summary>
            <param name="reader"></param>
            <param name="data"></param>
            <param name="chunkName"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.NewTable">
            <summary>
            Creates a new empty table and pushes it onto the stack
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.NewThread">
            <summary>
            Creates a new thread, pushes it on the stack, and returns a pointer to a lua_State that represents this new thread. The new thread returned by this function shares with the original thread its global environment, but has an independent execution stack. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.NewUserData(System.Int32)">
            <summary>
            This function allocates a new block of memory with the given size, pushes onto the stack a new full userdata with the block address, and returns this address. The host program can freely use this memory
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Next(System.Int32)">
            <summary>
            Pops a key from the stack, and pushes a key杤alue pair from the table at the given index (the "next" pair after the given key).
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PCall(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calls a function in protected mode. 
            </summary>
            <param name="arguments"></param>
            <param name="results"></param>
            <param name="errorFunctionIndex"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PCallK(System.Int32,System.Int32,System.Int32,System.Int32,Comm.Utils.KeraLua.LuaKFunction)">
            <summary>
            This function behaves exactly like lua_pcall, but allows the called function to yield
            </summary>
            <param name="arguments"></param>
            <param name="results"></param>
            <param name="errorFunctionIndex"></param>
            <param name="context"></param>
            <param name="k"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Pop(System.Int32)">
            <summary>
            Pops n elements from the stack. 
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushBoolean(System.Boolean)">
            <summary>
            Pushes a boolean value with value b onto the stack. 
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushCClosure(Comm.Utils.KeraLua.LuaFunction,System.Int32)">
            <summary>
             Pushes a new C closure onto the stack. When a C function is created, it is possible to associate 
             some values with it, thus creating a C closure (see ?.4); these values are then accessible to the function 
             whenever it is called. To associate values with a C function, first these values must be pushed onto the 
             stack (when there are multiple values, the first value is pushed first). 
             Then lua_pushcclosure is called to create and push the C function onto the stack, 
             with the argument n telling how many values will be associated with the function. 
             lua_pushcclosure also pops these values from the stack. 
            </summary>
            <param name="function"></param>
            <param name="n"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushCFunction(Comm.Utils.KeraLua.LuaFunction)">
            <summary>
            Pushes a C function onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type function that, when called, invokes the corresponding C function. 
            </summary>
            <param name="function"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushGlobalTable">
            <summary>
            Pushes the global environment onto the stack. 
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushInteger(System.Int64)">
            <summary>
            Pushes an integer with value n onto the stack. 
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushLightUserData(System.IntPtr)">
            <summary>
            Pushes a light userdata onto the stack.
            Userdata represent C values in Lua. A light userdata represents a pointer, a void*. It is a value (like a number): you do not create it, it has no individual metatable, and it is not collected (as it was never created). A light userdata is equal to "any" light userdata with the same C address. 
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushObject``1(``0)">
            <summary>
            Pushes a reference data (C# object)  onto the stack. 
            This function uses lua_pushlightuserdata, but uses a GCHandle to store the reference inside the Lua side.
            The CGHandle is create as Normal, and will be freed when the value is pop
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushBuffer(System.Byte[])">
            <summary>
            Pushes binary buffer onto the stack (usually UTF encoded string) or any arbitraty binary data
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushString(System.String)">
            <summary>
            Pushes a string onto the stack
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushString(System.String,System.Object[])">
            <summary>
            Push a instring using string.Format 
            PushString("Foo {0}", 10);
            </summary>
            <param name="value"></param>
            <param name="args"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushNil">
            <summary>
            Pushes a nil value onto the stack. 
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushNumber(System.Double)">
            <summary>
            Pushes a double with value n onto the stack. 
            </summary>
            <param name="number"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushThread(Comm.Utils.KeraLua.Lua)">
            <summary>
            Pushes the thread represented by L onto the stack. Returns true if this thread is the main thread of its state. 
            </summary>
            <param name="thread"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.PushCopy(System.Int32)">
            <summary>
            Pushes a copy of the element at the given index onto the stack. (lua_pushvalue)
            The method was renamed, since pushvalue is a bit vague
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawEqual(System.Int32,System.Int32)">
            <summary>
            Returns true if the two values in indices index1 and index2 are primitively equal (that is, without calling the __eq metamethod). Otherwise returns false. Also returns false if any of the indices are not valid. 
            </summary>
            <param name="index1"></param>
            <param name="index2"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawGet(System.Int32)">
            <summary>
            Similar to GetTable, but does a raw access (i.e., without metamethods). 
            </summary>
            <param name="index"></param>
            <returns>Returns the type of the pushed value</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawGet(Comm.Utils.KeraLua.LuaRegistry)">
            <summary>
            Similar to GetTable, but does a raw access (i.e., without metamethods). 
            </summary>
            <param name="index"></param>
            <returns>Returns the type of the pushed value</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawGetInteger(System.Int32,System.Int64)">
            <summary>
            Pushes onto the stack the value t[n], where t is the table at the given index. The access is raw, that is, it does not invoke the __index metamethod. 
            </summary>
            <param name="index"></param>
            <param name="n"></param>
            <returns>Returns the type of the pushed value</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawGetInteger(Comm.Utils.KeraLua.LuaRegistry,System.Int64)">
            <summary>
            Pushes onto the stack the value t[n], where t is the table at the given index. The access is raw, that is, it does not invoke the __index metamethod. 
            </summary>
            <param name="index"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawGetByHashCode(System.Int32,System.Object)">
            <summary>
            Pushes onto the stack the value t[k], where t is the table at the given index and k is the pointer p represented as a light userdata. The access is raw; that is, it does not invoke the __index metamethod. 
            </summary>
            <param name="index"></param>
            <param name="obj"></param>
            <returns>Returns the type of the pushed value. </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawLen(System.Int32)">
            <summary>
            Returns the raw "length" of the value at the given index: for strings, this is the string length; for tables, this is the result of the length operator ('#') with no metamethods; for userdata, this is the size of the block of memory allocated for the userdata; for other values, it is 0. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawSet(System.Int32)">
            <summary>
            Similar to lua_settable, but does a raw assignment (i.e., without metamethods).
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawSet(Comm.Utils.KeraLua.LuaRegistry)">
            <summary>
            Similar to lua_settable, but does a raw assignment (i.e., without metamethods).
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawSetInteger(System.Int32,System.Int64)">
            <summary>
             Does the equivalent of t[i] = v, where t is the table at the given index and v is the value at the top of the stack.
             This function pops the value from the stack. The assignment is raw, that is, it does not invoke the __newindex metamethod. 
            </summary>
            <param name="index">index of table</param>
            <param name="i">value</param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawSetInteger(Comm.Utils.KeraLua.LuaRegistry,System.Int64)">
            <summary>
             Does the equivalent of t[i] = v, where t is the table at the given index and v is the value at the top of the stack.
             This function pops the value from the stack. The assignment is raw, that is, it does not invoke the __newindex metamethod. 
            </summary>
            <param name="index"></param>
            <param name="i"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RawSetByHashCode(System.Int32,System.Object)">
            <summary>
            Does the equivalent of t[p] = v, where t is the table at the given index, p is encoded as a light userdata, and v is the value at the top of the stack. 
            </summary>
            <param name="index"></param>
            <param name="obj"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Register(System.String,Comm.Utils.KeraLua.LuaFunction)">
            <summary>
            Sets the C# delegate f as the new value of global name
            </summary>
            <param name="name"></param>
            <param name="function"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Remove(System.Int32)">
            <summary>
            Removes the element at the given valid index, shifting down the elements above this index to fill the gap. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position. 
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Replace(System.Int32)">
            <summary>
            Moves the top element into the given valid index without shifting any element (therefore replacing the value at that given index), and then pops the top element.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Resume(Comm.Utils.KeraLua.Lua,System.Int32)">
            <summary>
             To start a coroutine, you push onto the thread stack the main function plus any arguments; then you call lua_resume,
             with nargs being the number of arguments. This call returns when the coroutine suspends or finishes its execution. 
             When it returns, the stack contains all values passed to lua_yield, or all values returned by the body function. 
             lua_resume returns LUA_YIELD if the coroutine yields, LUA_OK if the coroutine finishes its execution without errors, 
             or an error code in case of errors (see lua_pcall).
             In case of errors, the stack is not unwound, so you can use the debug API over it. 
             The error object is on the top of the stack.
             To resume a coroutine, you remove any results from the last lua_yield, put on its stack only the values to be passed as results from yield,
             and then call lua_resume.
             The parameter from represents the coroutine that is resuming L. 
             If there is no such coroutine, this parameter can be NULL. 
            </summary>
            <param name="from"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Rotate(System.Int32,System.Int32)">
            <summary>
             Rotates the stack elements between the valid index idx and the top of the stack. The elements are rotated n positions in the direction of the top, for a positive n, or -n positions in the direction of the bottom, for a negative n. The absolute value of n must not be greater than the size of the slice being rotated. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position. 
            </summary>
            <param name="index"></param>
            <param name="n"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetAllocFunction(Comm.Utils.KeraLua.LuaAlloc,System.IntPtr@)">
            <summary>
            Changes the allocator function of a given state to f with user data ud. 
            </summary>
            <param name="alloc"></param>
            <param name="ud"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetField(System.Int32,System.String)">
            <summary>
            Does the equivalent to t[k] = v, where t is the value at the given index and v is the value at the top of the stack.
            </summary>
            <param name="index"></param>
            <param name="key"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetHook(Comm.Utils.KeraLua.LuaHookFunction,Comm.Utils.KeraLua.LuaHookMask,System.Int32)">
            <summary>
            Sets the debugging hook function. 
            
            Argument f is the hook function. mask specifies on which events the hook will be called: it is formed by a bitwise OR of the constants
            </summary>
            <param name="hookFunction">Hook function callback</param>
            <param name="mask">hook mask</param>
            <param name="count">count (used only with LuaHookMas.Count)</param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetGlobal(System.String)">
            <summary>
            Pops a value from the stack and sets it as the new value of global name. 
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetInteger(System.Int32,System.Int64)">
            <summary>
            Does the equivalent to t[n] = v, where t is the value at the given index and v is the value at the top of the stack. 
            </summary>
            <param name="index"></param>
            <param name="n"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetLocal(System.IntPtr,System.Int32)">
            <summary>
            Sets the value of a local variable of a given activation record. It assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack. 
            </summary>
            <param name="ar"></param>
            <param name="n"></param>
            <returns>Returns NULL (and pops nothing) when the index is greater than the number of active local variables. </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetLocal(Comm.Utils.KeraLua.LuaDebug,System.Int32)">
            <summary>
            Sets the value of a local variable of a given activation record. It assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack. 
            </summary>
            <param name="ar"></param>
            <param name="n"></param>
            <returns>Returns NULL (and pops nothing) when the index is greater than the number of active local variables. </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetMetaTable(System.Int32)">
            <summary>
            Pops a table from the stack and sets it as the new metatable for the value at the given index. 
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetTable(System.Int32)">
            <summary>
             Does the equivalent to t[k] = v, where t is the value at the given index, v is the value at the top of the stack, and k is the value just below the top
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetTop(System.Int32)">
            <summary>
            Accepts any index, or 0, and sets the stack top to this index. If the new top is larger than the old one, then the new elements are filled with nil. If index is 0, then all stack elements are removed. 
            </summary>
            <param name="newTop"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetUpValue(System.Int32,System.Int32)">
            <summary>
            Sets the value of a closure's upvalue. It assigns the value at the top of the stack to the upvalue and returns its name. It also pops the value from the stack. 
            </summary>
            <param name="functionIndex"></param>
            <param name="n"></param>
            <returns>Returns NULL (and pops nothing) when the index n is greater than the number of upvalues. </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetUserValue(System.Int32)">
            <summary>
             Pops a value from the stack and sets it as the new value associated to the full userdata at the given index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:Comm.Utils.KeraLua.Lua.Status">
            <summary>
             The status can be 0 (LUA_OK) for a normal thread, an error code if the thread finished the execution of a lua_resume with an error, or LUA_YIELD if the thread is suspended. 
             You can only call functions in threads with status LUA_OK. You can resume threads with status LUA_OK (to start a new coroutine) or LUA_YIELD (to resume a coroutine). 
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.StringToNumber(System.String)">
            <summary>
            Converts the zero-terminated string s to a number, pushes that number into the stack,
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToBoolean(System.Int32)">
            <summary>
            Converts the Lua value at the given index to a C# boolean value
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToCFunction(System.Int32)">
            <summary>
            Converts a value at the given index to a C# function. That value must be a C# function; otherwise, returns NULL
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToInteger(System.Int32)">
            <summary>
            Converts the Lua value at the given index to the signed integral type lua_Integer. The Lua value must be an integer, or a number or string convertible to an integer (see ?.4.3); otherwise, lua_tointegerx returns 0. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToIntegerX(System.Int32)">
            <summary>
            Converts the Lua value at the given index to the signed integral type lua_Integer. The Lua value must be an integer, or a number or string convertible to an integer (see ?.4.3); otherwise, lua_tointegerx returns 0. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToBuffer(System.Int32)">
            <summary>
            Converts the Lua value at the given as byte array
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToBuffer(System.Int32,System.Boolean)">
            <summary>
            Converts the Lua value at the given index to a byte array.
            </summary>
            <param name="index"></param>
            <param name="callMetamethod">Calls __tostring field if present</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToString(System.Int32)">
            <summary>
            Converts the Lua value at the given index to a C# string
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToString(System.Int32,System.Boolean)">
            <summary>
            Converts the Lua value at the given index to a C# string
            </summary>
            <param name="index"></param>
            <param name="callMetamethod">Calls __tostring field if present</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToNumber(System.Int32)">
            <summary>
            Converts the Lua value at the given index to a C# double
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToNumberX(System.Int32)">
            <summary>
            Converts the Lua value at the given index to a C# double?
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToPointer(System.Int32)">
            <summary>
             Converts the value at the given index to a generic C pointer (void*). The value can be a userdata, a table, a thread, or a function; otherwise, lua_topointer returns NULL. Different objects will give different pointers. There is no way to convert the pointer back to its original value.
             Typically this function is used only for hashing and debug information. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToThread(System.Int32)">
            <summary>
            Converts the value at the given index to a Lua thread
            or return the self if is the main thread
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToObject``1(System.Int32,System.Boolean)">
            <summary>
            Return an object (refence) at the index
            Important if a object was push the object need to fetched using
            this method, otherwise the C# object will never be collected
            </summary>
            <typeparam name="T"></typeparam>
            <param name="index"></param>
            <param name="freeGCHandle">True to free the GCHandle</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ToUserData(System.Int32)">
            <summary>
            If the value at the given index is a full userdata, returns its block address. If the value is a light userdata, returns its pointer. Otherwise, returns NULL
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Type(System.Int32)">
            <summary>
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.TypeName(Comm.Utils.KeraLua.LuaType)">
            <summary>
            Returns the name of the type of the value at the given index. 
            </summary>
            <param name="type"></param>
            <returns>Name of the type of the value at the given index</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.UpValueId(System.Int32,System.Int32)">
            <summary>
             Returns a unique identifier for the upvalue numbered n from the closure at index funcindex.
            </summary>
            <param name="functionIndex"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.UpValueIndex(System.Int32)">
            <summary>
            Returns the pseudo-index that represents the i-th upvalue of the running function 
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.UpValueJoin(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Make the n1-th upvalue of the Lua closure at index funcindex1 refer to the n2-th upvalue of the Lua closure at index funcindex2
            </summary>
            <param name="functionIndex1"></param>
            <param name="n1"></param>
            <param name="functionIndex2"></param>
            <param name="n2"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Version">
            <summary>
            Return the version of Lua (e.g 503)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.XMove(Comm.Utils.KeraLua.Lua,System.Int32)">
            <summary>
             Exchange values between different threads of the same state.
             This function pops n values from the current stack, and pushes them onto the stack to. 
            </summary>
            <param name="to"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Yield(System.Int32)">
            <summary>
            This function is equivalent to lua_yieldk, but it has no continuation (see ?.7). Therefore, when the thread resumes, it continues the function that called the function calling lua_yield. 
            </summary>
            <param name="results"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.YieldK(System.Int32,System.Int32,Comm.Utils.KeraLua.LuaKFunction)">
            <summary>
             Yields a coroutine (thread). When a C function calls lua_yieldk, the running coroutine suspends its execution, and the call to lua_resume that started this coroutine returns
            </summary>
            <param name="results">Number of values from the stack that will be passed as results to lua_resume.</param>
            <param name="context"></param>
            <param name="continuation"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ArgumentCheck(System.Boolean,System.Int32,System.String)">
            <summary>
            Checks whether cond is true. If it is not, raises an error with a standard message
            </summary>
            <param name="condition"></param>
            <param name="argument"></param>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ArgumentError(System.Int32,System.String)">
            <summary>
            Raises an error reporting a problem with argument arg of the C function that called it, using a standard message that includes extramsg as a comment: 
            </summary>
            <param name="argument"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CallMetaMethod(System.Int32,System.String)">
            <summary>
            If the object at index obj has a metatable and this metatable has a field e, this function calls this field passing the object as its only argument.
            </summary>
            <param name="obj"></param>
            <param name="field"></param>
            <returns>If there is no metatable or no metamethod, this function returns false (without pushing any value on the stack)</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckAny(System.Int32)">
            <summary>
            Checks whether the function has an argument of any type (including nil) at position arg. 
            </summary>
            <param name="argument"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckInteger(System.Int32)">
            <summary>
            Checks whether the function argument arg is an integer (or can be converted to an integer)
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckBuffer(System.Int32)">
            <summary>
            Checks whether the function argument arg is a string and returns this string;
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckString(System.Int32)">
            <summary>
            Checks whether the function argument arg is a string and returns this string;
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckNumber(System.Int32)">
            <summary>
            Checks whether the function argument arg is a number and returns this number. 
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckOption(System.Int32,System.String,System.String[])">
            <summary>
            Checks whether the function argument arg is a string and searches for this string in the array lst 
            </summary>
            <param name="argument"></param>
            <param name="def"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckStack(System.Int32,System.String)">
            <summary>
            Grows the stack size to top + sz elements, raising an error if the stack cannot grow 
            </summary>
            <param name="newSize"></param>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckType(System.Int32,Comm.Utils.KeraLua.LuaType)">
            <summary>
            Checks whether the function argument arg has type type
            </summary>
            <param name="argument"></param>
            <param name="type"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckObject``1(System.Int32,System.String,System.Boolean)">
            <summary>
            Checks whether the function argument arg is a userdata of the type tname
            </summary>
            <typeparam name="T"></typeparam>
            <param name="argument"></param>
            <param name="typeName"></param>
            <param name="freeGCHandle">True to release the GCHandle</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.CheckUserData(System.Int32,System.String)">
            <summary>
            Checks whether the function argument arg is a userdata of the type tname (see luaL_newmetatable) and returns the userdata address
            </summary>
            <param name="argument"></param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.DoFile(System.String)">
            <summary>
            Loads and runs the given file
            </summary>
            <param name="file"></param>
            <returns>It returns false if there are no errors or true in case of errors. </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.DoString(System.String)">
            <summary>
            Loads and runs the given string
            </summary>
            <param name="file"></param>
            <returns>It returns false if there are no errors or true in case of errors. </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Error(System.String,System.Object[])">
            <summary>
            Raises an error. The error message format is given by fmt plus any extra arguments
            </summary>
            <param name="value"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.ExecResult(System.Int32)">
            <summary>
            This function produces the return values for process-related functions in the standard library
            </summary>
            <param name="stat"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.FileResult(System.Int32,System.String)">
            <summary>
            This function produces the return values for file-related functions in the standard library
            </summary>
            <param name="stat"></param>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetMetaField(System.Int32,System.String)">
            <summary>
            Pushes onto the stack the field e from the metatable of the object at index obj and returns the type of the pushed value
            </summary>
            <param name="obj"></param>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetMetaTable(System.String)">
            <summary>
            Pushes onto the stack the metatable associated with name tname in the registry (see luaL_newmetatable) (nil if there is no metatable associated with that name)
            </summary>
            <param name="tableName"></param>
            <returns>Returns the type of the pushed value. </returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.GetSubTable(System.Int32,System.String)">
            <summary>
            Ensures that the value t[fname], where t is the value at index idx, is a table, and pushes that table onto the stack. Returns true if it finds a previous table there and false if it creates a new table
            </summary>
            <param name="index"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Length(System.Int32)">
            <summary>
            Returns the "length" of the value at the given index as a number; it is equivalent to the '#' operator in Lua
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.LoadBuffer(System.Byte[],System.String,System.String)">
            <summary>
            Loads a buffer as a Lua chunk
            </summary>
            <param name="buffer"></param>
            <param name="name"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.LoadBuffer(System.Byte[],System.String)">
            <summary>
            </summary>
            <param name="buffer"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.LoadBuffer(System.Byte[])">
            <summary>
            Loads a buffer as a Lua chunk
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.LoadString(System.String,System.String)">
            <summary>
            Loads a string as a Lua chunk
            </summary>
            <param name="chunk"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.LoadString(System.String)">
            <summary>
            Loads a string as a Lua chunk
            </summary>
            <param name="chunk"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.LoadFile(System.String,System.String)">
            <summary>
            Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename
            </summary>
            <param name="file"></param>
            <param name="mode"></param>
            <returns>The status of operation</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.LoadFile(System.String)">
            <summary>
            Loads a file as a Lua chunk.
            </summary>
            <param name="file"></param>
            <returns>Return the status</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.NewLib(Comm.Utils.KeraLua.LuaRegister[])">
            <summary>
            Creates a new table and registers there the functions in list library. 
            </summary>
            <param name="library"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.NewLibTable(Comm.Utils.KeraLua.LuaRegister[])">
            <summary>
            Creates a new table with a size optimized to store all entries in the array l (but does not actually store them)
            </summary>
            <param name="library"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.NewMetaTable(System.String)">
            <summary>
            Creates a new table to be used as a metatable for userdata
            </summary>
            <param name="name"></param>
            <returns>If the registry already has the key tname, returns false.,</returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.OpenLibs">
            <summary>
            Opens all standard Lua libraries into the given state. 
            </summary>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.OptInteger(System.Int32,System.Int64)">
            <summary>
            If the function argument arg is an integer (or convertible to an integer), returns this integer. If this argument is absent or is nil, returns d
            </summary>
            <param name="argument"></param>
            <param name="d">default value</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.OptBuffer(System.Int32,System.Byte[])">
            <summary>
            If the function argument arg is a string, returns this string. If this argument is absent or is nil, returns d        /// </summary>
            <param name="index"></param>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.OptString(System.Int32,System.String)">
            <summary>
            If the function argument arg is a string, returns this string. If this argument is absent or is nil, returns d
            </summary>
            <param name="index"></param>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.OptNumber(System.Int32,System.Double)">
            <summary>
            If the function argument arg is a number, returns this number. If this argument is absent or is nil, returns d
            </summary>
            <param name="index"></param>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Ref(Comm.Utils.KeraLua.LuaRegistry)">
            <summary>
            Creates and returns a reference, in the table at index t, for the object at the top of the stack (and pops the object). 
            </summary>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.RequireF(System.String,Comm.Utils.KeraLua.LuaFunction,System.Boolean)">
            <summary>
            If modname is not already present in package.loaded, calls function openf with string modname as an argument and sets the call result in package.loaded[modname], as if that function has been called through require
            </summary>
            <param name="moduleName"></param>
            <param name="openFunction"></param>
            <param name="global"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetFuncs(Comm.Utils.KeraLua.LuaRegister[],System.Int32)">
            <summary>
            Registers all functions in the array l (see luaL_Reg) into the table on the top of the stack (below optional upvalues, see next).        /// </summary>
            <param name="library"></param>
            <param name="numberUpValues"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.SetMetaTable(System.String)">
            <summary>
            Sets the metatable of the object at the top of the stack as the metatable associated with name tname in the registry
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.TestObject``1(System.Int32,System.String,System.Boolean)">
            <summary>
            Test if the value at index is a reference data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="argument"></param>
            <param name="typeName"></param>
            <param name="freeGCHandle">True to release the GCHandle of object</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.TestUserData(System.Int32,System.String)">
            <summary>
            This function works like luaL_checkudata, except that, when the test fails, it returns NULL instead of raising an error.
            </summary>
            <param name="argument"></param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Traceback(Comm.Utils.KeraLua.Lua,System.Int32)">
            <summary>
            Creates and pushes a traceback of the stack L1
            </summary>
            <param name="state"></param>
            <param name="level"> Tells at which level to start the traceback</param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Traceback(Comm.Utils.KeraLua.Lua,System.String,System.Int32)">
            <summary>
            Creates and pushes a traceback of the stack L1
            </summary>
            <param name="state"></param>
            <param name="message">appended at the beginning of the traceback</param>
            <param name="level"> Tells at which level to start the traceback</param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.TypeName(System.Int32)">
            <summary>
            Returns the name of the type of the value at the given index. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Unref(Comm.Utils.KeraLua.LuaRegistry,System.Int32)">
            <summary>
            Releases reference ref from the table at index t (see luaL_ref). The entry is removed from the table, so that the referred object can be collected. The reference ref is also freed to be used again
            </summary>
            <param name="tableIndex"></param>
            <param name="reference"></param>
        </member>
        <member name="M:Comm.Utils.KeraLua.Lua.Where(System.Int32)">
            <summary>
            Pushes onto the stack a string identifying the current position of the control at level lvl in the call stack
            </summary>
            <param name="level"></param>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaCompare">
            <summary>
            Used by Compare
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaCompare.Equal">
            <summary>
             compares for equality (==)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaCompare.LessThen">
            <summary>
             compares for less than 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaCompare.LessOrEqual">
            <summary>
            compares for less or equal 
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaDebug">
            <summary>
            Structure for lua debug information
            </summary>
            <remarks>
            Do not change this struct because it must match the lua structure lua_Debug
            </remarks>
            <author>Reinhard Ostermeier</author>
        </member>
        <member name="M:Comm.Utils.KeraLua.LuaDebug.FromIntPtr(System.IntPtr)">
            <summary>
            Get a LuaDebug from IntPtr
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.Event">
            <summary>
            Debug event code
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.LuaDebug.Name">
            <summary>
             a reasonable name for the given function. Because functions in Lua are first-class values, they do not have a fixed name: some functions can be the value of multiple global variables, while others can be stored only in a table field
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.LuaDebug.NameWhat">
            <summary>
            explains the name field. The value of namewhat can be "global", "local", "method", "field", "upvalue", or "" (the empty string)
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.LuaDebug.What">
            <summary>
             the string "Lua" if the function is a Lua function, "C" if it is a C function, "main" if it is the main part of a chunk
            </summary>
        </member>
        <member name="P:Comm.Utils.KeraLua.LuaDebug.Source">
            <summary>
             the name of the chunk that created the function. If source starts with a '@', it means that the function was defined in a file where the file name follows the '@'.
            </summary>
            
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.CurrentLine">
            <summary>
             the current line where the given function is executing. When no line information is available, currentline is set to -1
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.LineDefined">
            <summary>
            
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.LastLineDefined">
            <summary>
             the line number where the definition of the function ends. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.NumberUpValues">
            <summary>
            number of upvalues
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.NumberParameters">
            <summary>
            number of parameters
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.IsVarArg">
            <summary>
             true if the function is a vararg function (always true for C functions).
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.IsTailCall">
            <summary>
             true if this function invocation was called by a tail call. In this case, the caller of this level is not in the stack.
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaDebug.ShortSource">
            <summary>
            a "printable" version of source, to be used in error messages
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaGC">
            <summary>
            Garbage Collector operations
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.Stop">
            <summary>
             Stops the garbage collector. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.Restart">
            <summary>
            Restarts the garbage collector. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.Collect">
            <summary>
            Performs a full garbage-collection cycle. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.Count">
            <summary>
             Returns the current amount of memory (in Kbytes) in use by Lua. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.Countb">
            <summary>
             Returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.Step">
            <summary>
             Performs an incremental step of garbage collection. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.SetPause">
            <summary>
            Sets data as the new value for the pause of the collector (see §2.5) and returns the previous value
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.SetStepMultiplier">
            <summary>
            sets data as the new value for the step multiplier of the collector
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaGC.IsRunning">
            <summary>
             returns a boolean that tells whether the collector is running
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaHookEvent">
            <summary>
            Whenever a hook is called, its ar argument has its field event set to the specific event that triggered the hook
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookEvent.Call">
            <summary>
            The call hook: is called when the interpreter calls a function. The hook is called just after Lua enters the new function, before the function gets its arguments. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookEvent.Return">
            <summary>
            The return hook: is called when the interpreter returns from a function. The hook is called just before Lua leaves the function. There is no standard way to access the values to be returned by the function. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookEvent.Line">
            <summary>
            The line hook: is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.) 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookEvent.Count">
            <summary>
             The count hook: is called after the interpreter executes every count instructions. (This event only happens while Lua is executing a Lua function.) 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookEvent.TailCall">
            <summary>
            Tail Call
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaHookMask">
            <summary>
            Lua Hook Event Masks
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookMask.Disabled">
            <summary>
            Disabled hook
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookMask.Call">
            <summary>
            The call hook: is called when the interpreter calls a function. The hook is called just after Lua enters the new function, before the function gets its arguments. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookMask.Return">
            <summary>
            The return hook: is called when the interpreter returns from a function. The hook is called just before Lua leaves the function. There is no standard way to access the values to be returned by the function. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookMask.Line">
            <summary>
            The line hook: is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.) 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaHookMask.Count">
            <summary>
             The count hook: is called after the interpreter executes every count instructions. (This event only happens while Lua is executing a Lua function.) 
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaOperation">
            <summary>
            Operation value used by Arith method
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Add">
            <summary>
            adition(+)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Sub">
            <summary>
             substraction (-)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Mul">
            <summary>
            Multiplication (*)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Mod">
            <summary>
            Modulo (%)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Pow">
            <summary>
            Exponentiation (^)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Div">
            <summary>
             performs float division (/)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Idiv">
            <summary>
             performs floor division (//)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Band">
            <summary>
            performs bitwise AND
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Bor">
            <summary>
            performs bitwise OR (|)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Bxor">
            <summary>
            performs bitwise exclusive OR (~)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Shl">
            <summary>
            performs left shift 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Shr">
            <summary>
             performs right shift
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Unm">
            <summary>
             performs mathematical negation (unary -)
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaOperation.Bnot">
            <summary>
            performs bitwise NOT (~)
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaRegister">
            <summary>
            LuaRegister store the name and the delegate to register a native function
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaRegister.name">
            <summary>
            Function name
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaRegister.function">
            <summary>
            Function delegate
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaRegistry">
            <summary>
            Enum for pseudo-index used by registry table
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaRegistry.Index">
            <summary>
            pseudo-index used by registry table
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaRegistryIndex">
            <summary>
            Registry index 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaRegistryIndex.MainThread">
            <summary>
             At this index the registry has the main thread of the state.
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaRegistryIndex.Globals">
            <summary>
            At this index the registry has the global environment. 
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaStatus">
            <summary>
            Lua Load/Call status return
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaStatus.OK">
            <summary>
             success
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaStatus.Yield">
            <summary>
            Yield
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaStatus.ErrRun">
            <summary>
            a runtime error. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaStatus.ErrSyntax">
            <summary>
            syntax error during precompilation
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaStatus.ErrMem">
            <summary>
             memory allocation error. For such errors, Lua does not call the message handler. 
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaStatus.ErrGCMM">
            <summary>
             error while running a __gc metamethod. For such errors, Lua does not call the message handler
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaStatus.ErrErr">
            <summary>
             error while running the message handler. 
            </summary>
        </member>
        <member name="T:Comm.Utils.KeraLua.LuaType">
            <summary>
            Lua types
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.Nil">
            <summary>
            LUA_TNIL
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.Boolean">
            <summary>
            LUA_TBOOLEAN
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.LightUserData">
            <summary>
            LUA_TLIGHTUSERDATA
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.Number">
            <summary>
            LUA_TNUMBER
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.String">
            <summary>
            LUA_TSTRING
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.Table">
            <summary>
            LUA_TTABLE
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.Function">
            <summary>
            LUA_TFUNCTION
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.UserData">
            <summary>
            LUA_TUSERDATA
            </summary>
        </member>
        <member name="F:Comm.Utils.KeraLua.LuaType.Thread">
            <summary>
            LUA_TTHREAD
            </summary>
            //
        </member>
        <member name="T:Comm.Utils.ILibReaderWriterLock">
            <summary>
             读，写锁接口
            </summary>
        </member>
        <member name="P:Comm.Utils.ILibReaderWriterLock.IsReaderLockHeld">
            <summary>
            获取一个值，该值指示当前线程是否持有读线程锁。
            </summary>
        </member>
        <member name="P:Comm.Utils.ILibReaderWriterLock.IsWriterLockHeld">
            <summary>
            获取一个值，该值指示当前线程是否持有写线程锁。
            </summary>
        </member>
        <member name="M:Comm.Utils.ILibReaderWriterLock.AcquireWriterLock">
            <summary>
            开启写锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.ILibReaderWriterLock.ReleaseWriterLock">
            <summary>
            释放写锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.ILibReaderWriterLock.AcquireReaderLock">
            <summary>
            开启读锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.ILibReaderWriterLock.ReleaseReaderLock">
            <summary>
            释放读锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.ILibReaderWriterLock.UpgradeToWriterLock">
            <summary>
             使用一个 Int32 超时值将读线程锁升级为写线程锁。
            </summary>
            <returns>System.Threading.LockCookie 值</returns>
            <example>System.ApplicationException:    millisecondsTimeout 在授予锁定请求前过期。</example>
        </member>
        <member name="M:Comm.Utils.ILibReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
            <summary>
              将线程的锁状态还原为调用 System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
              前的状态。
            </summary>
            <param name="lockCookie"></param>
        </member>
        <member name="T:Comm.Utils.LibReaderWriterLock">
            <summary>
            读,写锁类ReaderWriterLock再封装
            </summary>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.#ctor">
            <summary>
            默认构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.#ctor(System.String,System.Boolean)">
            <summary>
            调试构造函数
            </summary>
            <param name="lockName">锁定名称</param>
            <param name="traceSwitch">是否开启调试开关</param>
        </member>
        <member name="P:Comm.Utils.LibReaderWriterLock.IsReaderLockHeld">
            <summary>
            获取一个值，该值指示当前线程是否持有读线程锁。
            </summary>
        </member>
        <member name="P:Comm.Utils.LibReaderWriterLock.IsWriterLockHeld">
            <summary>
            获取一个值，该值指示当前线程是否持有写线程锁。
            </summary>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.AcquireWriterLock">
            <summary>
            开启写锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.ReleaseWriterLock">
            <summary>
            释放写锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.AcquireReaderLock(System.Int32)">
            <summary>
            开启读锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.AcquireReaderLock">
            <summary>
            开启读锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.ReleaseReaderLock">
            <summary>
            释放读锁定
            </summary>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.UpgradeToWriterLock">
            <summary>
             使用一个 Int32 超时值将读线程锁升级为写线程锁。
            </summary>
            <returns>System.Threading.LockCookie 值</returns>
            <example>System.ApplicationException:millisecondsTimeout 在授予锁定请求前过期。</example>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
            <summary>
            将线程的锁状态还原为调用 System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
            前的状态。
            </summary>
            <param name="lockCookie"></param>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.SendDebug(System.String)">
            <summary>
            发送DEBUG信息到Trace
            </summary>
            <param name="debugInfo"></param>
        </member>
        <member name="M:Comm.Utils.LibReaderWriterLock.SendError(System.Exception)">
            <summary>
            发送错误信息到Trace
            </summary>
            <param name="ex"></param>
        </member>
        <member name="T:Comm.Utils.LogHelper">
            <summary>
            日志帮助类(采用Log4net,默认日志文件存放在Log目录下)
            </summary>
        </member>
        <member name="E:Comm.Utils.LogHelper.OutputMessage">
            <summary>
            定义信息的二次处理
            </summary>
        </member>
        <member name="M:Comm.Utils.LogHelper.HandMessage(System.Object)">
            <summary>
            二次处理方式
            </summary>
            <param name="Msg"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.HandMessage(System.Object,System.Exception)">
            <summary>
            处理
            </summary>
            <param name="Msg"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.HandMessage(System.String,System.Object[])">
            <summary>
            处理
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.LoadADONetAppender(System.String)">
            <summary>
            初始数据库存储形式(第一步:在手动加载配置(只要加载一次,可放在全局Global中))
            </summary>
            <param name="connectionString">连接字符串(留空则默认本地的数据库名LogDB,用户:sa,密码:123456)</param>
            <remarks>日志表:Log(Date[DateTime],Thread[string:255],Level[string:50],Logger[string:255],Message[string:4000],Exception[string:4000])</remarks>
        </member>
        <member name="M:Comm.Utils.LogHelper.LoadFileAppender(System.String)">
            <summary>
            初始文件存储形式(第一步:在手动加载配置(只要加载一次,可放在全局Global中)
            </summary>
            <param name="logFile">日志路径文件,默认Log/error.log</param>
        </member>
        <member name="M:Comm.Utils.LogHelper.LoadRollingFileAppender(System.String)">
            <summary>
            初始多文件存储形式(第一步:在手动加载配置(只要加载一次,可放在全局Global中)
            </summary>
            <param name="logPath">日志路径,默认Log/</param>
        </member>
        <member name="M:Comm.Utils.LogHelper.LoadConsoleAppender">
            <summary>
            初始控制台输出形式(第一步:在手动加载配置(只要加载一次,可放在全局Global中)
            </summary>
        </member>
        <member name="M:Comm.Utils.LogHelper.LoadTraceAppender">
            <summary>
            初始Trace输出形式(第一步:在手动加载配置(只要加载一次,可放在全局Global中)
            </summary>
        </member>
        <member name="M:Comm.Utils.LogHelper.LoadEventLogAppender">
            <summary>
            初始系统日志存储形式(第一步:在手动加载配置(只要加载一次,可放在全局Global中)
            </summary>
        </member>
        <member name="M:Comm.Utils.LogHelper.LoadUnhandledException">
            <summary>
            处理程序域未处理的异常(第二步:定义程序域未处理的异常(同一步加载,可选))
            </summary>
        </member>
        <member name="M:Comm.Utils.LogHelper.Debug(System.Object)">
            <summary>
            Debug(第三步:调用日志输出)
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Debug(System.Object,System.Exception)">
            <summary>
            Debug(第三步:调用日志输出)
            </summary>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Error(System.Object)">
            <summary>
            Error第三步:调用日志输出
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Error(System.Object,System.Exception)">
            <summary>
            Error第三步:调用日志输出
            </summary>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.ErrorFormat(System.String,System.Object[])">
            <summary>
            Error第三步:调用日志输出
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Fatal(System.Object)">
            <summary>
            Fatal第三步:调用日志输出
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Fatal(System.Object,System.Exception)">
            <summary>
            Fatal第三步:调用日志输出
            </summary>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.FatalFormat(System.String,System.Object[])">
            <summary>
            Fatal第三步:调用日志输出
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Info(System.Object)">
            <summary>
            Info第三步:调用日志输出
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Info(System.Object,System.Exception)">
            <summary>
            Info第三步:调用日志输出
            </summary>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.InfoFormat(System.String,System.Object[])">
            <summary>
            Info第三步:调用日志输出
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Warn(System.Object)">
            <summary>
            Warn第三步:调用日志输出
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.Warn(System.Object,System.Exception)">
            <summary>
            Warn第三步:调用日志输出
            </summary>
            <param name="message"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Comm.Utils.LogHelper.WarnFormat(System.String,System.Object[])">
            <summary>
            Warn第三步:调用日志输出
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:Comm.Utils.MailHelper">
            <summary>
            邮件帮助类(使用MailMessage发送)
            </summary>
        </member>
        <member name="M:Comm.Utils.MailHelper.SendMail(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            发送邮件
            </summary>
            <param name="Subject">标题</param>
            <param name="Body">正文</param>
            <param name="FromEmail">发送人邮箱</param>
            <param name="FromName">发送人（用于显示）</param>
            <param name="ToEmail">收件人邮箱</param>
            <param name="MailServer">如果发送默认端口25对方禁止，可以加端口MailServer：xx</param>
            <param name="Port">默认端口25</param>
            <param name="MailServerUserName">邮件服务器分配的邮箱帐号</param>
            <param name="MailServerPassWord">邮件服务器分配的邮箱密码</param>
            <param name="IsHTMLBody">邮件正文是以HTML格式发送</param>
            <param name="IsSSl">是否使用安全SSL</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Exceptions.MqttClientException">
            <summary>
            MQTT client exception
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Exceptions.MqttClientException.#ctor(Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode)">
            <summary>
            Constructor
            </summary>
            <param name="code">Error code</param>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Exceptions.MqttClientException.ErrorCode">
            <summary>
            Error code
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode">
            <summary>
            MQTT client erroro code
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.WillWrong">
            <summary>
            Will error (topic, message or QoS level)
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.KeepAliveWrong">
            <summary>
            Keep alive period too large
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.TopicWildcard">
            <summary>
            Topic contains wildcards
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.TopicLength">
            <summary>
            Topic length wrong
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.QosNotAllowed">
            <summary>
            QoS level not allowed
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.TopicsEmpty">
            <summary>
            Topics list empty for subscribe
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.QosLevelsEmpty">
            <summary>
            Qos levels list empty for subscribe
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.TopicsQosLevelsNotMatch">
            <summary>
            Topics / Qos Levels not match in subscribe
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.WrongBrokerMessage">
            <summary>
            Wrong message from broker
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.WrongMessageId">
            <summary>
            Wrong Message Id
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.InflightQueueFull">
            <summary>
            Inflight queue is full
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.InvalidFlagBits">
            <summary>
            Invalid flag bits received 
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.InvalidConnectFlags">
            <summary>
            Invalid connect flags received
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.InvalidClientId">
            <summary>
            Invalid client id
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Exceptions.MqttClientErrorCode.InvalidProtocolName">
            <summary>
            Invalid protocol name
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Exceptions.MqttCommunicationException">
            <summary>
            Exception due to error communication with broker on socket
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Exceptions.MqttCommunicationException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Exceptions.MqttCommunicationException.#ctor(System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="e">Inner Exception</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Exceptions.MqttConnectionException">
            <summary>
            Connection to the broker exception
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Exceptions.MqttTimeoutException">
            <summary>
            Timeout on receiving from broker exception
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.IMqttNetworkChannel">
            <summary>
            MQTT网络通道接口
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.IMqttNetworkChannel.DataAvailable">
            <summary>
            是否有可接收的数据
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.IMqttNetworkChannel.Receive(System.Byte[])">
            <summary>
            从网络通道接收数据
            </summary>
            <param name="buffer">Data buffer for receiving data</param>
            <returns>Number of bytes received</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.IMqttNetworkChannel.Receive(System.Byte[],System.Int32)">
            <summary>
            在规定时间内接收服务端消息
            </summary>
            <param name="buffer">Data buffer for receiving data</param>
            <param name="timeout">Timeout on receiving (in milliseconds)</param>
            <returns>Number of bytes received</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.IMqttNetworkChannel.Send(System.Byte[])">
            <summary>
            向服务端发送数据
            </summary>
            <param name="buffer">Data buffer to send</param>
            <returns>Number of byte sent</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.IMqttNetworkChannel.Close">
            <summary>
            关闭网络通道
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.IMqttNetworkChannel.Connect">
            <summary>
            连接到服务器
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.IMqttNetworkChannel.Accept">
            <summary>
            接受客户端连接
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Internal.InternalEvent">
            <summary>
            Generic internal event for dispatching
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Internal.MsgInternalEvent">
            <summary>
            Internal event with a message
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Internal.MsgInternalEvent.Message">
            <summary>
            Related message
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Internal.MsgInternalEvent.#ctor(Comm.Utils.M2Mqtt.Messages.MqttMsgBase)">
            <summary>
            Constructor
            </summary>
            <param name="msg">Related message</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Internal.MsgPublishedInternalEvent">
            <summary>
            Internal event for a published message
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Internal.MsgPublishedInternalEvent.IsPublished">
            <summary>
            Message published (or failed due to retries)
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Internal.MsgPublishedInternalEvent.#ctor(Comm.Utils.M2Mqtt.Messages.MqttMsgBase,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="msg">Message published</param>
            <param name="isPublished">Publish flag</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgBase">
            <summary>
            Base class for all MQTT messages
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.Type">
            <summary>
            Message type
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.DupFlag">
            <summary>
            Duplicate message flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.QosLevel">
            <summary>
            Quality of Service level
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.Retain">
            <summary>
            Retain message flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.MessageId">
            <summary>
            Message identifier for the message
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.GetBytes(System.Byte)">
            <summary>
            Returns message bytes rapresentation
            </summary>
            <param name="protocolVersion">Protocol version</param>
            <returns>Bytes rapresentation</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.encodeRemainingLength(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encode remaining length and insert it into message buffer
            </summary>
            <param name="remainingLength">Remaining length value to encode</param>
            <param name="buffer">Message buffer for inserting encoded value</param>
            <param name="index">Index from which insert encoded value into buffer</param>
            <returns>Index updated</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.decodeRemainingLength(Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Decode remaining length reading bytes from socket
            </summary>
            <param name="channel">Channel from reading bytes</param>
            <returns>Decoded remaining length</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgBase.GetTraceString(System.String,System.Object[],System.Object[])">
            <summary>
            Returns a string representation of the message for tracing
            </summary>
            <param name="name">Message name</param>
            <param name="fieldNames">Message fields name</param>
            <param name="fieldValues">Message fields value</param>
            <returns>String representation of the message</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgConnack">
            <summary>
            Class for CONNACK message from broker to client
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnack.SessionPresent">
            <summary>
            Session present flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnack.ReturnCode">
            <summary>
            Return Code
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgConnack.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgConnack.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a CONNACK message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>CONNACK message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect">
            <summary>
            Class for CONNECT message from client to broker
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.ProtocolName">
            <summary>
            Protocol name
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.ProtocolVersion">
            <summary>
            Protocol version
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.ClientId">
            <summary>
            Client identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.WillRetain">
            <summary>
            Will retain flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.WillQosLevel">
            <summary>
            Will QOS level
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.WillFlag">
            <summary>
            Will flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.WillTopic">
            <summary>
            Will topic
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.WillMessage">
            <summary>
            Will message
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.Username">
            <summary>
            Username
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.Password">
            <summary>
            Password
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.CleanSession">
            <summary>
            Clean session flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.KeepAlivePeriod">
            <summary>
            Keep alive period
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="clientId">Client identifier</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.#ctor(System.String,System.String,System.String,System.Boolean,System.Byte,System.Boolean,System.String,System.String,System.Boolean,System.UInt16,System.Byte)">
            <summary>
            Constructor
            </summary>
            <param name="clientId">Client identifier</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="willRetain">Will retain flag</param>
            <param name="willQosLevel">Will QOS level</param>
            <param name="willFlag">Will flag</param>
            <param name="willTopic">Will topic</param>
            <param name="willMessage">Will message</param>
            <param name="cleanSession">Clean sessione flag</param>
            <param name="keepAlivePeriod">Keep alive period</param>
            <param name="protocolVersion">Protocol version</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgConnect.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a CONNECT message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>CONNECT message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgConnectEventArgs">
            <summary>
            Event Args class for CONNECT message received from client
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgConnectEventArgs.Message">
            <summary>
            Message received from client
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgConnectEventArgs.#ctor(Comm.Utils.M2Mqtt.Messages.MqttMsgConnect)">
            <summary>
            Constructor
            </summary>
            <param name="msg">CONNECT message received from client</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgContext">
            <summary>
            Context for MQTT message
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgContext.Message">
            <summary>
            MQTT message
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgContext.State">
            <summary>
            MQTT message state
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgContext.Flow">
            <summary>
            Flow of the message
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgContext.Timestamp">
            <summary>
            Timestamp in ticks (for retry)
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgContext.Attempt">
            <summary>
            Attempt (for retry)
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgContext.Key">
            <summary>
            Unique key
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgFlow">
            <summary>
            Flow of the message
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgFlow.ToPublish">
            <summary>
            To publish to subscribers
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgFlow.ToAcknowledge">
            <summary>
            To acknowledge to publisher
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgState">
            <summary>
            MQTT message state
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.QueuedQos0">
            <summary>
            QOS = 0, Message queued
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.QueuedQos1">
            <summary>
            QOS = 1, Message queued
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.QueuedQos2">
            <summary>
            QOS = 2, Message queued
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.WaitForPuback">
            <summary>
            QOS = 1, PUBLISH sent, wait for PUBACK
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.WaitForPubrec">
            <summary>
            QOS = 2, PUBLISH sent, wait for PUBREC
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.WaitForPubrel">
            <summary>
            QOS = 2, PUBREC sent, wait for PUBREL
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.WaitForPubcomp">
            <summary>
            QOS = 2, PUBREL sent, wait for PUBCOMP
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.SendPubrec">
            <summary>
            QOS = 2, start first phase handshake send PUBREC
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.SendPubrel">
            <summary>
            QOS = 2, start second phase handshake send PUBREL
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.SendPubcomp">
            <summary>
            QOS = 2, end second phase handshake send PUBCOMP
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.SendPuback">
            <summary>
            QOS = 1, PUBLISH received, send PUBACK
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.SendSubscribe">
            <summary>
            Send SUBSCRIBE message
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.SendUnsubscribe">
            <summary>
            Send UNSUBSCRIBE message
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.WaitForSuback">
            <summary>
            (QOS = 1), SUBSCRIBE sent, wait for SUBACK
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Messages.MqttMsgState.WaitForUnsuback">
            <summary>
            (QOS = 1), UNSUBSCRIBE sent, wait for UNSUBACK
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgDisconnect">
            <summary>
            Class for DISCONNECT message from client to broker
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgDisconnect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgDisconnect.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a DISCONNECT message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>DISCONNECT message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPingReq">
            <summary>
            Class for PINGREQ message from client to broker
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPingReq.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPingReq.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PINGREQ message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PINGREQ message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPingResp">
            <summary>
            Class for PINGRESP message from client to broker
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPingResp.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPingResp.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PINGRESP message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PINGRESP message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPuback">
            <summary>
            Class for PUBACK message from broker to client
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPuback.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPuback.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBACK message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBACK message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPubcomp">
            <summary>
            Class for PUBCOMP message from broker to client
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPubcomp.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPubcomp.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBCOMP message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBCOMP message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPublish">
            <summary>
            Class for PUBLISH message from client to broker
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublish.Topic">
            <summary>
            Message topic
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublish.Message">
            <summary>
            Message data
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPublish.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPublish.#ctor(System.String,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPublish.#ctor(System.String,System.Byte[],System.Boolean,System.Byte,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data</param>
            <param name="dupFlag">Duplicate flag</param>
            <param name="qosLevel">Quality of Service level</param>
            <param name="retain">Retain flag</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPublish.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBLISH message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBLISH message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishedEventArgs">
            <summary>
            Event Args class for published message
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishedEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishedEventArgs.IsPublished">
            <summary>
            Message published (or failed due to retries)
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishedEventArgs.#ctor(System.UInt16)">
            <summary>
            Constructor (published message)
            </summary>
            <param name="messageId">Message identifier published</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishedEventArgs.#ctor(System.UInt16,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier</param>
            <param name="isPublished">Publish flag</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishEventArgs">
            <summary>
            Event Args class for PUBLISH message received from broker
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishEventArgs.Topic">
            <summary>
            Message topic
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishEventArgs.Message">
            <summary>
            Message data
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishEventArgs.DupFlag">
            <summary>
            Duplicate message flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishEventArgs.QosLevel">
            <summary>
            Quality of Service level
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishEventArgs.Retain">
            <summary>
            Retain message flag
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPublishEventArgs.#ctor(System.String,System.Byte[],System.Boolean,System.Byte,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data</param>
            <param name="dupFlag">Duplicate delivery flag</param>
            <param name="qosLevel">Quality of Service level</param>
            <param name="retain">Retain flag</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPubrec">
            <summary>
            Class for PUBREC message from broker to client
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPubrec.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPubrec.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBREC message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBREC message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgPubrel">
            <summary>
            Class for PUBREL message from client top broker
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPubrel.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgPubrel.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBREL message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBREL message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgSuback">
            <summary>
            Class for SUBACK message from broker to client
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgSuback.GrantedQoSLevels">
            <summary>
            List of granted QOS Levels
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgSuback.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgSuback.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a SUBACK message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>SUBACK message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribe">
            <summary>
            Class for SUBSCRIBE message from client to broker
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribe.Topics">
            <summary>
            List of topics to subscribe
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribe.QoSLevels">
            <summary>
            List of QOS Levels related to topics
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribe.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribe.#ctor(System.String[],System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="topics">List of topics to subscribe</param>
            <param name="qosLevels">List of QOS Levels related to topics</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribe.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a SUBSCRIBE message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>SUBSCRIBE message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribedEventArgs">
            <summary>
            Event Args class for subscribed topics
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribedEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribedEventArgs.GrantedQoSLevels">
            <summary>
            List of granted QOS Levels
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribedEventArgs.#ctor(System.UInt16,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier for subscribed topics</param>
            <param name="grantedQosLevels">List of granted QOS Levels</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribeEventArgs">
            <summary>
            Event Args class for subscribe request on topics
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribeEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribeEventArgs.Topics">
            <summary>
            Topics requested to subscribe
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribeEventArgs.QoSLevels">
            <summary>
            List of QOS Levels requested
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgSubscribeEventArgs.#ctor(System.UInt16,System.String[],System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier for subscribe topics request</param>
            <param name="topics">Topics requested to subscribe</param>
            <param name="qosLevels">List of QOS Levels requested</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsuback">
            <summary>
            Class for UNSUBACK message from broker to client
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsuback.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsuback.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a UNSUBACK message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>UNSUBACK message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribe">
            <summary>
            Class for UNSUBSCRIBE message from client to broker
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribe.Topics">
            <summary>
            List of topics to unsubscribe
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribe.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribe.#ctor(System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="topics">List of topics to unsubscribe</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribe.Parse(System.Byte,System.Byte,Comm.Utils.M2Mqtt.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a UNSUBSCRIBE message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>UNSUBSCRIBE message instance</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribedEventArgs">
            <summary>
            Event Args class for unsubscribed topic
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribedEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribedEventArgs.#ctor(System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier for unsubscribed topic</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribeEventArgs">
            <summary>
            Event Args class for unsubscribe request on topics
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribeEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribeEventArgs.Topics">
            <summary>
            Topics requested to subscribe
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Messages.MqttMsgUnsubscribeEventArgs.#ctor(System.UInt16,System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier for subscribed topics</param>
            <param name="topics">Topics requested to subscribe</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttClient">
            <summary>
            MQTT客户端
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.IsConnected">
            <summary>
            Connection status between client and broker
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.ClientId">
            <summary>
            Client identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.CleanSession">
            <summary>
            Clean session flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.WillFlag">
            <summary>
            Will flag
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.WillQosLevel">
            <summary>
            Will QOS level
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.WillTopic">
            <summary>
            Will topic
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.WillMessage">
            <summary>
            Will message
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.ProtocolVersion">
            <summary>
            MQTT protocol version
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttClient.Settings">
            <summary>
            MQTT client settings
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.#ctor(System.Net.IPAddress)">
            <summary>
            构造函数
            </summary>
            <param name="brokerIpAddress">Broker IP address</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.#ctor(System.Net.IPAddress,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.M2Mqtt.MqttSslProtocols)">
            <summary>
            构造函数
            </summary>
            <param name="brokerIpAddress">Broker IP address</param>
            <param name="brokerPort">Broker port</param>
            <param name="secure">Using secure connection</param>
            <param name="caCert">CA certificate for secure connection</param>
            <param name="sslProtocol">SSL/TLS protocol version</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="brokerHostName">Broker Host Name or IP Address</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.#ctor(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.M2Mqtt.MqttSslProtocols)">
            <param name="caCert">CA certificate for secure connection</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.#ctor(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.M2Mqtt.MqttSslProtocols,System.Net.Security.RemoteCertificateValidationCallback)">
            <summary>
            构造函数
            </summary>
            <param name="brokerHostName">Broker Host Name or IP Address</param>
            <param name="brokerPort">Broker port</param>
            <param name="secure">Using secure connection</param>
            <param name="caCert">CA certificate for secure connection</param>
            <param name="sslProtocol">SSL/TLS protocol version</param>
            <param name="userCertificateValidationCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.#ctor(System.String,System.Int32,System.Boolean,Comm.Utils.M2Mqtt.MqttSslProtocols,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            构造函数
            </summary>
            <param name="brokerHostName">Broker Host Name or IP Address</param>
            <param name="brokerPort">Broker port</param>
            <param name="secure">Using secure connection</param>
            <param name="sslProtocol">SSL/TLS protocol version</param>
            <param name="userCertificateValidationCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
            <param name="userCertificateSelectionCallback">A LocalCertificateSelectionCallback delegate responsible for selecting the certificate used for authentication</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.#ctor(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.M2Mqtt.MqttSslProtocols,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            构造函数
            </summary>
            <param name="brokerHostName">Broker Host Name or IP Address</param>
            <param name="brokerPort">Broker port</param>
            <param name="secure">Using secure connection</param>
            <param name="caCert">CA certificate for secure connection</param>
            <param name="sslProtocol">SSL/TLS protocol version</param>
            <param name="userCertificateValidationCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
            <param name="userCertificateSelectionCallback">A LocalCertificateSelectionCallback delegate responsible for selecting the certificate used for authentication</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Init(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.M2Mqtt.MqttSslProtocols,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <param name="userCertificateSelectionCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
            <param name="userCertificateValidationCallback">A LocalCertificateSelectionCallback delegate responsible for selecting the certificate used for authentication</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Connect(System.String)">
            <summary>
            连接到代理服务端
            </summary>
            <param name="clientId">Client identifier</param>
            <returns>Return code of CONNACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Connect(System.String,System.String,System.String)">
            <summary>
            连接到代理服务端
            </summary>
            <param name="clientId">Client identifier</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <returns>Return code of CONNACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Connect(System.String,System.String,System.String,System.Boolean,System.UInt16)">
            <summary>
            连接到代理服务端
            </summary>
            <param name="clientId">Client identifier</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="cleanSession">Clean sessione flag</param>
            <param name="keepAlivePeriod">Keep alive period</param>
            <returns>Return code of CONNACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Connect(System.String,System.String,System.String,System.Boolean,System.Byte,System.Boolean,System.String,System.String,System.Boolean,System.UInt16)">
            <summary>
            连接到代理服务端
            </summary>
            <param name="clientId">Client identifier</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="willRetain">Will retain flag</param>
            <param name="willQosLevel">Will QOS level</param>
            <param name="willFlag">Will flag</param>
            <param name="willTopic">Will topic</param>
            <param name="willMessage">Will message</param>
            <param name="cleanSession">Clean sessione flag</param>
            <param name="keepAlivePeriod">Keep alive period</param>
            <returns>Return code of CONNACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Disconnect">
            <summary>
            断开与代理服务端连接
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Subscribe(System.String[],System.Byte[])">
            <summary>
            订阅消息主题
            </summary>
            <param name="topics">List of topics to subscribe</param>
            <param name="qosLevels">QOS levels related to topics</param>
            <returns>Message Id related to SUBSCRIBE message</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Unsubscribe(System.String[])">
            <summary>
            取消订阅消息主题
            </summary>
            <param name="topics">List of topics to unsubscribe</param>
            <returns>Message Id in UNSUBACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Publish(System.String,System.Byte[])">
            <summary>
            异步发布消息(QoS级别0，没有保留位)
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data (payload)</param>
            <returns>Message Id related to PUBLISH message</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Publish(System.String,System.Byte[],System.Byte,System.Boolean)">
            <summary>
            异步发布消息
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data (payload)</param>
            <param name="qosLevel">QoS Level</param>
            <param name="retain">Retain flag</param>
            <returns>Message Id related to PUBLISH message</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Close">
            <summary>
            关闭客户端
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Ping">
            <summary>
            Execute ping to broker for keep alive
            </summary>
            <returns>PINGRESP message from broker</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.OnInternalEvent(Comm.Utils.M2Mqtt.Internal.InternalEvent)">
            <summary>
            Wrapper method for raising events
            </summary>
            <param name="internalEvent">Internal event</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.OnConnectionClosing">
            <summary>
            Wrapper method for raising closing connection event
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.OnConnectionClosed">
            <summary>
            Wrapper method for peer/client disconnection
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Send(System.Byte[])">
            <summary>
            Send a message
            </summary>
            <param name="msgBytes">Message bytes</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.Send(Comm.Utils.M2Mqtt.Messages.MqttMsgBase)">
            <summary>
            Send a message
            </summary>
            <param name="msg">Message</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.SendReceive(System.Byte[])">
            <summary>
            Send a message to the broker and wait answer
            </summary>
            <param name="msgBytes">Message bytes</param>
            <returns>MQTT message response</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.SendReceive(System.Byte[],System.Int32)">
            <summary>
            Send a message to the broker and wait answer
            </summary>
            <param name="msgBytes">Message bytes</param>
            <param name="timeout">Timeout for receiving answer</param>
            <returns>MQTT message response</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.SendReceive(Comm.Utils.M2Mqtt.Messages.MqttMsgBase)">
            <summary>
            Send a message to the broker and wait answer
            </summary>
            <param name="msg">Message</param>
            <returns>MQTT message response</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.SendReceive(Comm.Utils.M2Mqtt.Messages.MqttMsgBase,System.Int32)">
            <summary>
            Send a message to the broker and wait answer
            </summary>
            <param name="msg">Message</param>
            <param name="timeout">Timeout for receiving answer</param>
            <returns>MQTT message response</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.EnqueueInflight(Comm.Utils.M2Mqtt.Messages.MqttMsgBase,Comm.Utils.M2Mqtt.Messages.MqttMsgFlow)">
            <summary>
            Enqueue a message into the inflight queue
            </summary>
            <param name="msg">Message to enqueue</param>
            <param name="flow">Message flow (publish, acknowledge)</param>
            <returns>Message enqueued or not</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.EnqueueInternal(Comm.Utils.M2Mqtt.Messages.MqttMsgBase)">
            <summary>
            Enqueue a message into the internal queue
            </summary>
            <param name="msg">Message to enqueue</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.RestoreSession">
            <summary>
            Restore session
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.GetMessageId">
            <summary>
            Generate the next message identifier
            </summary>
            <returns>Message identifier</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.OnMqttMsgPublishReceived(Comm.Utils.M2Mqtt.Messages.MqttMsgPublish)">
            <summary>
            Wrapper method for raising PUBLISH message received event
            </summary>
            <param name="publish">PUBLISH message received</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.OnMqttMsgPublished(System.UInt16,System.Boolean)">
            <summary>
            Wrapper method for raising published message event
            </summary>
            <param name="messageId">Message identifier for published message</param>
            <param name="isPublished">Publish flag</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.OnMqttMsgSubscribed(Comm.Utils.M2Mqtt.Messages.MqttMsgSuback)">
            <summary>
            Wrapper method for raising subscribed topic event
            </summary>
            <param name="suback">SUBACK message received</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.OnMqttMsgUnsubscribed(System.UInt16)">
            <summary>
            Wrapper method for raising unsubscribed topic event
            </summary>
            <param name="messageId">Message identifier for unsubscribed topic</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.ReceiveThread">
            <summary>
            Thread for receiving messages
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.KeepAliveThread">
            <summary>
            Thread for handling keep alive message
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.DispatchEventThread">
            <summary>
            Thread for raising event
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.ProcessInflightThread">
            <summary>
            Process inflight messages queue
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttClient.MqttMsgContextFinder">
            <summary>
            Finder class for PUBLISH message inside a queue
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttClient.MqttMsgContextFinder.#ctor(System.UInt16,Comm.Utils.M2Mqtt.Messages.MqttMsgFlow)">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message Id</param>
            <param name="flow">Message flow inside inflight queue</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttMsgPublishEventHandler">
            <summary>
            Delagate that defines event handler for PUBLISH message received
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttMsgPublishedEventHandler">
            <summary>
            Delegate that defines event handler for published message
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttMsgSubscribedEventHandler">
            <summary>
            Delagate that defines event handler for subscribed topic
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttMsgUnsubscribedEventHandler">
            <summary>
            Delagate that defines event handler for unsubscribed topic
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.ConnectionClosedEventHandler">
            <summary>
            Delegate that defines event handler for cliet/peer disconnection
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttProtocolVersion">
            <summary>
            MQTT protocol version
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttSslProtocols">
            <summary>
            支持SSL / TLS协议版本
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttSettings">
             <summary>
            MQTT客户端设置类
             </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttSettings.Instance">
            <summary>
            单例
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttSettings.Port">
            <summary>
            Listening connection port
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttSettings.SslPort">
            <summary>
            Listening connection SSL port
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttSettings.TimeoutOnConnection">
            <summary>
            默认接收服务端发送CONNACK消息的超时时间
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttSettings.TimeoutOnReceiving">
            <summary>
            Timeout on receiving
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttSettings.AttemptsOnRetry">
            <summary>
            Attempts on retry
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttSettings.DelayOnRetry">
            <summary>
            Delay on retry
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttSettings.InflightQueueSize">
            <summary>
            Inflight queue size
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttSettings.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Fx">
            <summary>
            Support methods fos specific framework
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttNetworkChannel">
            <summary>
            Channel to communicate over the network
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttNetworkChannel.RemoteHostName">
            <summary>
            Remote host name
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttNetworkChannel.RemoteIpAddress">
            <summary>
            Remote IP address
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttNetworkChannel.RemotePort">
            <summary>
            Remote port
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.MqttNetworkChannel.DataAvailable">
            <summary>
            Data available on the channel
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>
            Constructor
            </summary>
            <param name="socket">Socket opened with the client</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.#ctor(System.Net.Sockets.Socket,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.M2Mqtt.MqttSslProtocols,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <param name="userCertificateSelectionCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
            <param name="userCertificateValidationCallback">A LocalCertificateSelectionCallback delegate responsible for selecting the certificate used for authentication</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.#ctor(System.String,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="remoteHostName">Remote Host name</param>
            <param name="remotePort">Remote port</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.#ctor(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.M2Mqtt.MqttSslProtocols,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <param name="userCertificateSelectionCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
            <param name="userCertificateValidationCallback">A LocalCertificateSelectionCallback delegate responsible for selecting the certificate used for authentication</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.Connect">
            <summary>
            Connect to remote server
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.Send(System.Byte[])">
            <summary>
            Send data on the network channel
            </summary>
            <param name="buffer">Data buffer to send</param>
            <returns>Number of byte sent</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.Receive(System.Byte[])">
            <summary>
            Receive data from the network
            </summary>
            <param name="buffer">Data buffer for receiving data</param>
            <returns>Number of bytes received</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.Receive(System.Byte[],System.Int32)">
            <summary>
            Receive data from the network channel with a specified timeout
            </summary>
            <param name="buffer">Data buffer for receiving data</param>
            <param name="timeout">Timeout on receiving (in milliseconds)</param>
            <returns>Number of bytes received</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.Close">
            <summary>
            Close the network channel
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.MqttNetworkChannel.Accept">
            <summary>
            Accept connection from a remote client
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.IPAddressUtility">
            <summary>
            IPAddress Utility class
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.IPAddressUtility.GetAddressFamily(System.Net.IPAddress)">
            <summary>
            Return AddressFamily for the IP address
            </summary>
            <param name="ipAddress">IP address to check</param>
            <returns>Address family</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.MqttSslUtility">
            <summary>
            MQTT SSL utility class
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Session.MqttBrokerSession">
            <summary>
            MQTT代理端（服务端）会话
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Session.MqttBrokerSession.Client">
            <summary>
            Client related to the subscription
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Session.MqttBrokerSession.Subscriptions">
            <summary>
            Subscriptions for the client session
            </summary>
        </member>
        <member name="F:Comm.Utils.M2Mqtt.Session.MqttBrokerSession.OutgoingMessages">
            <summary>
            Outgoing messages to publish
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Session.MqttBrokerSession.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Session.MqttClientSession">
            <summary>
            MQTT客户端会话
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Session.MqttClientSession.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="clientId">Client Id to create session</param>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Session.MqttSession">
            <summary>
            MQTT会话基类
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Session.MqttSession.ClientId">
            <summary>
            Client Id
            </summary>
        </member>
        <member name="P:Comm.Utils.M2Mqtt.Session.MqttSession.InflightMessages">
            <summary>
            Messages inflight during session
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Session.MqttSession.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Session.MqttSession.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="clientId">根据Client Id创建会话</param>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Session.MqttSession.Clear">
            <summary>
            Clean session
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Utility.QueueExtension">
            <summary>
            Extension class for a Queue
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Utility.QueueExtension.QueuePredicate">
            <summary>
            Predicate for searching inside a queue
            </summary>
            <param name="item">Item of the queue</param>
            <returns>Result of predicate</returns>
        </member>
        <member name="M:Comm.Utils.M2Mqtt.Utility.QueueExtension.Get(System.Collections.Queue,Comm.Utils.M2Mqtt.Utility.QueueExtension.QueuePredicate)">
            <summary>
            Get (without removing) an item from queue based on predicate
            </summary>
            <param name="queue">Queue in which to search</param>
            <param name="predicate">Predicate to verify to get item</param>
            <returns>Item matches the predicate</returns>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Utility.TraceLevel">
            <summary>
            Tracing levels
            </summary>
        </member>
        <member name="T:Comm.Utils.M2Mqtt.Utility.Trace">
            <summary>
            Tracing class
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttCommunicationProtocols">
            <summary>
            允许通讯协议
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.MqttCommunicationProtocols.Both">
            <summary>
            全部
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.MqttCommunicationProtocols.OnlyMQTT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.MqttCommunicationProtocols.OnlyMqttWebSocket">
            <summary>
            
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Communication.MqttClientConnectedEventHandler">
            <summary>
            MQTT客户端连接事件委托
            </summary>
            <param name="sender">The object which raises event</param>
            <param name="e">Event args</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Communication.IMqttCommunicationLayer">
            <summary>
            MQTT通信层接口
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.IMqttCommunicationLayer.CommunicationProtocol">
            <summary>
            支持的通讯协议
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.IMqttCommunicationLayer.Start">
            <summary>
            开启监听
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.IMqttCommunicationLayer.Stop">
            <summary>
            关闭监听
            </summary>
        </member>
        <member name="E:Comm.Utils.MqttBroker.Communication.IMqttCommunicationLayer.ClientConnected">
            <summary>
            客户端连接事件
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Communication.MqttClientConnectedEventArgs">
            <summary>
            MQTT客户机连接的事件参数
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.MqttClientConnectedEventArgs.Client">
            <summary>
            已连接客户端
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.MqttClientConnectedEventArgs.#ctor(Comm.Utils.MqttBroker.MqttClient)">
            <summary>
            构造函数
            </summary>
            <param name="client">已连接客户端</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer">
            <summary>
            MQTT通信层类
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.Port">
            <summary>
            监听端口
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.Secure">
            <summary>
            是否(SSL/TLS)连接
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.ServerCert">
            <summary>
            X509服务器证书
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.Protocol">
            <summary>
            SSL/TLS协议版本
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.CommunicationProtocol">
            <summary>
            支持的通讯协议
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.UserCertificateValidationCallback">
            <summary>
            一个RemoteCertificateValidationCallback委托，负责验证远程方提供的证书
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.UserCertificateSelectionCallback">
            <summary>
            负责选择用于身份验证的证书的LocalCertificateSelectionCallback委托
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="port">监听端口</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.#ctor(System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <param name="userCertificateSelectionCallback">一个RemoteCertificateValidationCallback委托，负责验证远程方提供的证书</param>
            <param name="userCertificateValidationCallback">负责选择用于身份验证的证书的LocalCertificateSelectionCallback委托</param>
        </member>
        <member name="E:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.ClientConnected">
            <summary>
            客户端连接事件
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.Start">
            <summary>
            开启监听
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.Stop">
            <summary>
            关闭监听
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.ListenerThread">
            <summary>
            侦听线程（监听客户端连接请求）
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Communication.MqttTcpCommunicationLayer.OnClientConnected(Comm.Utils.MqttBroker.MqttClient)">
            <summary>
            触发MqttBroker对象订阅事件
            </summary>
            <param name="e">Event args</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Internal.InternalEvent">
            <summary>
            通用 internal 事件 for dispatching
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Internal.MsgInternalEvent">
            <summary>
            MsgInternalEvent
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Internal.MsgInternalEvent.Message">
            <summary>
            Related message
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Internal.MsgInternalEvent.#ctor(Comm.Utils.MqttBroker.Messages.MqttMsgBase)">
            <summary>
            Constructor
            </summary>
            <param name="msg">Related message</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Internal.MsgPublishedInternalEvent">
            <summary>
            Internal event for a published message
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Internal.MsgPublishedInternalEvent.IsPublished">
            <summary>
            Message published (or failed due to retries)
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Internal.MsgPublishedInternalEvent.#ctor(Comm.Utils.MqttBroker.Messages.MqttMsgBase,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="msg">Message published</param>
            <param name="isPublished">Publish flag</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Managers.MqttPublisherManager">
            <summary>
            发布消息管理器
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttPublisherManager.#ctor(Comm.Utils.MqttBroker.Managers.MqttSubscriberManager,Comm.Utils.MqttBroker.Managers.MqttSessionManager)">
            <summary>
            Constructor
            </summary>
            <param name="subscriberManager">Reference to subscriber manager</param>
            <param name="sessionManager">Reference to session manager</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttPublisherManager.Start">
            <summary>
            开启发布处理程序
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttPublisherManager.Stop">
            <summary>
            关闭发布处理程序
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttPublisherManager.Publish(Comm.Utils.MqttBroker.Messages.MqttMsgPublish)">
            <summary>
            发布消息
            </summary>
            <param name="publish">Message to publish</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttPublisherManager.PublishRetaind(System.String,System.String,System.String)">
            <summary>
            向主题订阅者发布Retaind消息
            </summary>
            <param name="topic">Topic to search for a retained message</param>
            <param name="clientId">Client Id to send retained message</param>
            <param name="username">Client Id to send retained message</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttPublisherManager.PublishSession(System.String)">
            <summary>
            Publish outgoing session messages for a client
            </summary>
            <param name="clientId">Client Id to send outgoing session messages</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttPublisherManager.PublishThread">
            <summary>
            Process the message queue to publish
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Managers.MqttSessionManager">
            <summary>
            会话管理器
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSessionManager.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSessionManager.SaveSession(System.String,Comm.Utils.MqttBroker.Session.MqttClientSession,System.Collections.Generic.List{Comm.Utils.MqttBroker.Managers.MqttSubscription})">
            <summary>
            为客户端保存会话
            </summary>
            <param name="clientId">客户端ID</param>
            <param name="clientSession">带有类似飞行模式消息的客户端会话</param>
            <param name="subscriptions">要保存的主题订阅内容</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSessionManager.GetSession(System.String)">
            <summary>
            根据客户端ID获取会话
            </summary>
            <param name="clientId">客户端ID</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSessionManager.GetSessions">
            <summary>
            获取所有会话
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSessionManager.ClearSession(System.String)">
            <summary>
            根据客户端ID清除会话
            </summary>
            <param name="clientId">客户端ID</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager">
            <summary>
            主题和订阅者的管理器
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.Subscribe(System.String,System.Byte,Comm.Utils.MqttBroker.MqttClient)">
            <summary>
            为主题添加订阅者
            </summary>
            <param name="topic">订阅的主题</param>
            <param name="qosLevel">QoS级别</param>
            <param name="client">订阅客户端</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.Unsubscribe(System.String,Comm.Utils.MqttBroker.MqttClient)">
            <summary>
            删除给定主题的订阅者
            </summary>
            <param name="topic">取消订阅主题</param>
            <param name="client">取消订阅客户端</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.Unsubscribe(Comm.Utils.MqttBroker.MqttClient)">
            <summary>
            Remove a subscriber for all topics
            </summary>
            <param name="client">Client to unsubscribe</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.GetSubscriptions(System.String,System.Byte)">
            <summary>
            Get subscription list for a specified topic and QoS Level
            </summary>
            <param name="topic">Topic to get subscription list</param>
            <param name="qosLevel">QoS level requested</param>
            <returns>Subscription list</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.GetSubscription(System.String,System.String)">
            <summary>
            Get a subscription for a specified topic and client
            </summary>
            <param name="topic">Topic to get subscription</param>
            <param name="clientId">Client Id to get subscription</param>
            <returns>Subscription list</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.GetSubscriptionsByTopic(System.String)">
            <summary>
            获取匹配主题的订阅列表
            </summary>
            <param name="topic">主题</param>
            <returns>Subscription list</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.GetSubscriptionsByClient(System.String)">
            <summary>
            Get subscription list for a specified client
            </summary>
            <param name="clientId">Client Id to get subscription list</param>
            <returns>Subscription lis</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.FilterReservedTopic(System.String[],System.String[])">
            <summary>
            过滤掉保留的主题,返回可订阅的主题 CS ADD 2019.4.28
            </summary>
            <param name="reservedTopics"></param>
            <param name="topics"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriberManager.GetTopicKey(System.String,System.String)">
            <summary>
            获取集合键的组合值 //CS ADD 2019.4.28
            </summary>
            <param name="topic"></param>
            <param name="username"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Managers.MqttSubscriptionComparer">
            <summary>
            MQTT subscription comparer
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Managers.MqttSubscriptionComparer.Type">
            <summary>
            MQTT subscription comparer type
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscriptionComparer.#ctor(Comm.Utils.MqttBroker.Managers.MqttSubscriptionComparer.MqttSubscriptionComparerType)">
            <summary>
            Constructor
            </summary>
            <param name="type">MQTT subscription comparer type</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Managers.MqttSubscriptionComparer.MqttSubscriptionComparerType">
            <summary>
            MQTT subscription comparer type
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Managers.MqttSubscription">
            <summary>
            MQTT subscription
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Managers.MqttSubscription.ClientId">
            <summary>
            Client Id
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Managers.MqttSubscription.Topic">
            <summary>
            Topic of subscription
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Managers.MqttSubscription.QosLevel">
            <summary>
            QoS level granted for the subscription
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Managers.MqttSubscription.Client">
            <summary>
            Client related to the subscription
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscription.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscription.#ctor(System.String,System.String,System.Byte,Comm.Utils.MqttBroker.MqttClient)">
            <summary>
            Constructor
            </summary>
            <param name="clientId">Client Id of the subscription</param>
            <param name="topic">Topic of subscription</param>
            <param name="qosLevel">QoS level of subscription</param>
            <param name="client">Client related to the subscription</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttSubscription.Dispose">
            <summary>
            Dispose subscription
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Managers.MqttUserAuthenticationDelegate">
            <summary>
            委托执行用户身份验证 CS MODIFY 2019.02.22
            </summary>
            <param name="client">客户端</param>
            <param name="connect">连接消息对象</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Managers.MqttUacManager">
            <summary>
            用于用户访问控制的管理器
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Managers.MqttUacManager.UserAuth">
            <summary>
            用户身份验证方法
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Managers.MqttUacManager.UserAuthentication(Comm.Utils.MqttBroker.MqttClient,Comm.Utils.MqttBroker.Messages.MqttMsgConnect)">
            <summary>
            执行用户身份验证
            </summary>
            <param name="client">客户端</param>
            <param name="connect">连接消息对象</param>
            <returns>授予结果代码值</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttBroker">
            <summary>
            MQTT broker business logic
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttBroker.ClientAuthorization">
            <summary>
            用户身份验证委托
            </summary>
        </member>
        <member name="E:Comm.Utils.MqttBroker.MqttBroker.ClientConnected">
            <summary>
            客户端连接事件（发送Connect报文时触发）
            </summary>
        </member>
        <member name="E:Comm.Utils.MqttBroker.MqttBroker.ClientDisconnected">
            <summary>
            客户端关闭事件（发送Disconnect报文时触发）
            </summary>
        </member>
        <member name="E:Comm.Utils.MqttBroker.MqttBroker.ClientPublishReceived">
            <summary>
            接收客户端发送Publish消息事件 CS ADD 2019.02.22
            </summary>
        </member>
        <member name="E:Comm.Utils.MqttBroker.MqttBroker.ClientSubscribeReceived">
            <summary>
            接收客户端发送Subscribe消息事件
            </summary>
        </member>
        <member name="E:Comm.Utils.MqttBroker.MqttBroker.ClientUnsubscribeReceived">
            <summary>
            接收客户端发送Unsubscribe消息事件
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.#ctor">
            <summary>
            构造函数 (默认1883端口和默认设置参数)
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32)">
            <summary>
            构造函数 (使用 SSL/TLS 默认8883端口和默认设置参数)
            </summary>
            <param name="serverCert">X509 Server certificate</param>
            <param name="sslProtocol">SSL/TLS protocol versiokn</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Int32)">
            <summary>
            构造函数 (使用 SSL/TLS 默认8883端口和默认设置参数)
            </summary>
            <param name="serverCert"></param>
            <param name="sslProtocol"></param>
            <param name="port"></param>
            <param name="connectTimeout"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            构造函数 (使用 SSL/TLS 默认8883端口和默认设置参数)
            </summary>
            <param name="serverCert">X509 Server certificate</param>
            <param name="sslProtocol">SSL/TLS protocol version</param>
            <param name="userCertificateSelectionCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
            <param name="userCertificateValidationCallback">A LocalCertificateSelectionCallback delegate responsible for selecting the certificate used for authentication</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.#ctor(Comm.Utils.MqttBroker.Communication.IMqttCommunicationLayer,Comm.Utils.MqttBroker.MqttSettings)">
            <summary>
            构造函数 
            </summary>
            <param name="commLayer">通信层对象 (TCP)</param>
            <param name="settings">Broker设置对象</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.GetClient(System.String)">
            <summary>
            根据客户端ID返回已连接的MqttClient客户端对象
            </summary>
            <param name="clientId">客户端ID</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.CloseClient(Comm.Utils.MqttBroker.MqttClient,System.Nullable{Comm.Utils.ExitType})">
            <summary>
            关闭客户端
            </summary>
            <param name="client">客户端</param>
            <param name="exitType">关闭类型 CS ADD 2019.02.22</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Comm.Utils.MqttBroker.MqttBroker.MqttConnectVerify(Comm.Utils.MqttBroker.MqttClient,Comm.Utils.MqttBroker.Messages.MqttMsgConnect)" -->
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.commLayer_ClientConnected(System.Object,Comm.Utils.MqttBroker.Communication.MqttClientConnectedEventArgs)">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.Client_MqttMsgConnected(System.Object,Comm.Utils.MqttBroker.Messages.MqttMsgConnectEventArgs)">
            <summary>
            接收客户端“Connect（连接消息）”事件处理程序
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.Client_MqttMsgDisconnected(System.Object,System.EventArgs)">
            <summary>
            接收客户端“Disconnect（断开连接消息）”事件处理程序
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.Client_MqttMsgPublishReceived(System.Object,Comm.Utils.MqttBroker.Messages.MqttMsgPublishEventArgs)">
            <summary>
            接收客户端“Publish（发送消息）”事件处理程序
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.Client_MqttMsgUnsubscribeReceived(System.Object,Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribeEventArgs)">
            <summary>
            接收客户端“Unsubscribe”事件处理程序
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.Client_MqttMsgSubscribeReceived(System.Object,Comm.Utils.MqttBroker.Messages.MqttMsgSubscribeEventArgs)">
            <summary>
             接收客户端“Subscribe”事件处理程序
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.Client_ConnectionClosed(System.Object,System.EventArgs)">
            <summary>
            接收客户端“Connection”事件处理程序
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.Start(Comm.Utils.MqttBroker.MqttCommunicationProtocols)">
            <summary>
            开启服务
            </summary>
            <param name="communicationProtocols"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttBroker.Stop">
            <summary>
            关闭服务
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient">
            <summary>
            MQTT客户端
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgPublishEventHandler">
            <summary>
            Delagate that defines event handler for PUBLISH message received
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgPublishedEventHandler">
            <summary>
            Delegate that defines event handler for published message
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgSubscribedEventHandler">
            <summary>
            Delagate that defines event handler for subscribed topic
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgUnsubscribedEventHandler">
            <summary>
            Delagate that defines event handler for unsubscribed topic
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgSubscribeEventHandler">
            <summary>
            Delagate that defines event handler for SUBSCRIBE message received
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgUnsubscribeEventHandler">
            <summary>
            Delagate that defines event handler for UNSUBSCRIBE message received
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgConnectEventHandler">
            <summary>
            Delagate that defines event handler for CONNECT message received
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgDisconnectEventHandler">
            <summary>
            Delegate that defines event handler for client disconnection (DISCONNECT message or not)
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.ConnectionClosedEventHandler">
            <summary>
            Delegate that defines event handler for cliet/peer disconnection
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.IsConnected">
            <summary>
            客户端和Broker之间的连接状态
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.ClientId">
            <summary>
            Client identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.Username">
            <summary>
            Username CS ADD 2019.4.26
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.CleanSession">
            <summary>
            Clean session flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.WillFlag">
            <summary>
            Will flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.WillQosLevel">
            <summary>
            Will QOS level
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.WillTopic">
            <summary>
            Will topic
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.WillMessage">
            <summary>
            Will message
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.ProtocolVersion">
            <summary>
            MQTT protocol version
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.Session">
            <summary>
            MQTT Client会话
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.RemoteEndPoint">
            <summary>
            连接到代理的客户机的IP地址
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.Settings">
            <summary>
            MQTT client settings
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttClient.TypeOfExit">
            <summary> 
            退出方式(CS ADD)
            </summary> 
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.#ctor(System.Net.IPAddress)">
            <summary>
            构造函数
            </summary>
            <param name="brokerIpAddress">BrokerIP地址</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.#ctor(System.Net.IPAddress,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols)">
            <summary>
            构造函数
            </summary>
            <param name="brokerIpAddress">BrokerIP地址</param>
            <param name="brokerPort">Broker端口</param>
            <param name="secure">使用安全连接</param>
            <param name="caCert">用于安全连接的CA证书</param>
            <param name="clientCert">客户端证书</param>
            <param name="sslProtocol">SSL / TLS协议版本</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="brokerHostName">Broker主机名或IP地址</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.#ctor(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32)">
            <param name="caCert">用于安全连接的CA证书</param>
            <param name="clientCert">客户端证书</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.#ctor(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Net.Security.RemoteCertificateValidationCallback)">
            <summary>
            构造函数
            </summary>
            <param name="brokerHostName">Broker主机名或IP地址</param>
            <param name="brokerPort">Broker端口</param>
            <param name="secure">使用安全连接</param>
            <param name="caCert">用于安全连接的CA证书</param>
            <param name="clientCert">客户端证书</param>
            <param name="sslProtocol">SSL / TLS协议版本</param>
            <param name="userCertificateValidationCallback">一个RemoteCertificateValidationCallback委托，负责验证远程方提供的证书</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.#ctor(System.String,System.Int32,System.Boolean,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            构造函数
            </summary>
            <param name="brokerHostName">Broker主机名或IP地址</param>
            <param name="brokerPort">Broker端口</param>
            <param name="secure">使用安全连接</param>
            <param name="sslProtocol">SSL / TLS协议版本</param>
            <param name="userCertificateValidationCallback">一个RemoteCertificateValidationCallback委托，负责验证远程方提供的证书</param>
            <param name="userCertificateSelectionCallback">负责选择用于身份验证的证书的LocalCertificateSelectionCallback委托</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.#ctor(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            构造函数
            </summary>
            <param name="brokerHostName">Broker主机名或IP地址</param>
            <param name="brokerPort">Broker端口</param>
            <param name="secure">使用安全连接</param>
            <param name="caCert">用于安全连接的CA证书</param>
            <param name="clientCert">客户端证书</param>
            <param name="sslProtocol">SSL / TLS协议版本</param>
            <param name="userCertificateValidationCallback">一个RemoteCertificateValidationCallback委托，负责验证远程方提供的证书</param>
            <param name="userCertificateSelectionCallback">负责选择用于身份验证的证书的LocalCertificateSelectionCallback委托</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.#ctor(Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            构造函数
            </summary>
            <param name="channel">通信网络通道</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Init(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <param name="userCertificateValidationCallback">一个RemoteCertificateValidationCallback委托，负责验证远程方提供的证书</param>
            <param name="userCertificateSelectionCallback">负责选择用于身份验证的证书的LocalCertificateSelectionCallback委托</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Connect(System.String)">
            <summary>
            连接broker
            </summary>
            <param name="clientId">客户端ID</param>
            <returns>Return code of CONNACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Connect(System.String,System.String,System.String)">
            <summary>
            连接broker
            </summary>
            <param name="clientId">客户端ID</param>
            <param name="username"></param>
            <param name="password"></param>
            <returns>Return code of CONNACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Connect(System.String,System.String,System.String,System.Boolean,System.UInt16)">
            <summary>
            连接broker
            </summary>
            <param name="clientId">客户端ID</param>
            <param name="username"></param>
            <param name="password"></param>
            <param name="cleanSession">Clean sessione flag</param>
            <param name="keepAlivePeriod">Keep alive period</param>
            <returns>Return code of CONNACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Connect(System.String,System.String,System.String,System.Boolean,System.Byte,System.Boolean,System.String,System.String,System.Boolean,System.UInt16)">
            <summary>
            连接broker
            </summary>
            <param name="clientId">Client identifier</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="willRetain">Will retain flag</param>
            <param name="willQosLevel">Will QOS level</param>
            <param name="willFlag">Will flag</param>
            <param name="willTopic">Will topic</param>
            <param name="willMessage">Will message</param>
            <param name="cleanSession">Clean sessione flag</param>
            <param name="keepAlivePeriod">Keep alive period</param>
            <returns>Return code of CONNACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Disconnect">
            <summary>
            从broker断开连接
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Open">
            <summary>
            打开客户端通信
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Close">
            <summary>
            关闭客户端通信
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.SetExitType(Comm.Utils.ExitType)">
            <summary>
            设置客户端退出类型，CS ADD 2019.02.22
            </summary>
            <param name="exitType"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Ping">
            <summary>
            Execute ping to broker for keep alive
            </summary>
            <returns>PINGRESP message from broker</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Connack(Comm.Utils.MqttBroker.Messages.MqttMsgConnect,System.Byte,System.String,System.Boolean)">
            <summary>
            Send CONNACK message to the client (connection accepted or not)
            </summary>
            <param name="connect">CONNECT message with all client information</param>
            <param name="returnCode">Return code for CONNACK message</param>
            <param name="clientId">If not null, client id assigned by broker</param>
            <param name="sessionPresent">Session present on the broker</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Suback(System.UInt16,System.Byte[])">
            <summary>
            Send SUBACK message to the client
            </summary>
            <param name="messageId">Message Id for the SUBSCRIBE message that is being acknowledged</param>
            <param name="grantedQosLevels">Granted QoS Levels</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Unsuback(System.UInt16)">
            <summary>
            Send UNSUBACK message to the client
            </summary>
            <param name="messageId">Message Id for the UNSUBSCRIBE message that is being acknowledged</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Subscribe(System.String[],System.Byte[])">
            <summary>
            Subscribe for message topics
            </summary>
            <param name="topics">List of topics to subscribe</param>
            <param name="qosLevels">QOS levels related to topics</param>
            <returns>Message Id related to SUBSCRIBE message</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Unsubscribe(System.String[])">
            <summary>
            Unsubscribe for message topics
            </summary>
            <param name="topics">List of topics to unsubscribe</param>
            <returns>Message Id in UNSUBACK message from broker</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Publish(System.String,System.Byte[])">
            <summary>
            Publish a message asynchronously (QoS Level 0 and not retained)
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data (payload)</param>
            <returns>Message Id related to PUBLISH message</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Publish(System.String,System.Byte[],System.Byte,System.Boolean)">
            <summary>
            Publish a message asynchronously
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data (payload)</param>
            <param name="qosLevel">QoS Level</param>
            <param name="retain">Retain flag</param>
            <returns>Message Id related to PUBLISH message</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnInternalEvent(Comm.Utils.MqttBroker.Internal.InternalEvent)">
            <summary>
            用于提升事件的包装方法
            </summary>
            <param name="internalEvent"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnConnectionClosing">
            <summary>
            用于引发关闭连接事件的包装器方法
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnMqttMsgPublishReceived(Comm.Utils.MqttBroker.Messages.MqttMsgPublish)">
            <summary>
            Wrapper method for raising PUBLISH message received event
            </summary>
            <param name="publish">PUBLISH message received</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnMqttMsgPublished(System.UInt16,System.Boolean)">
            <summary>
            Wrapper method for raising published message event
            </summary>
            <param name="messageId">Message identifier for published message</param>
            <param name="isPublished">Publish flag</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnMqttMsgSubscribed(Comm.Utils.MqttBroker.Messages.MqttMsgSuback)">
            <summary>
            Wrapper method for raising subscribed topic event
            </summary>
            <param name="suback">SUBACK message received</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnMqttMsgUnsubscribed(System.UInt16)">
            <summary>
            Wrapper method for raising unsubscribed topic event
            </summary>
            <param name="messageId">Message identifier for unsubscribed topic</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnMqttMsgSubscribeReceived(System.UInt16,System.String[],System.Byte[])">
            <summary>
            Wrapper method for raising SUBSCRIBE message event
            </summary>
            <param name="messageId">Message identifier for subscribe topics request</param>
            <param name="topics">Topics requested to subscribe</param>
            <param name="qosLevels">List of QOS Levels requested</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnMqttMsgUnsubscribeReceived(System.UInt16,System.String[])">
            <summary>
            Wrapper method for raising UNSUBSCRIBE message event
            </summary>
            <param name="messageId">Message identifier for unsubscribe topics request</param>
            <param name="topics">Topics requested to unsubscribe</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnMqttMsgConnected(Comm.Utils.MqttBroker.Messages.MqttMsgConnect)">
            <summary>
            Wrapper method for raising CONNECT message event
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnMqttMsgDisconnected">
            <summary>
            客户端断开事件的包装器方法
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.OnConnectionClosed">
            <summary>
            Wrapper method for peer/client disconnection
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Send(System.Byte[])">
            <summary>
            Send a message
            </summary>
            <param name="msgBytes">Message bytes</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.Send(Comm.Utils.MqttBroker.Messages.MqttMsgBase)">
            <summary>
            Send a message
            </summary>
            <param name="msg">Message</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.SendReceive(System.Byte[])">
            <summary>
            Send a message to the broker and wait answer
            </summary>
            <param name="msgBytes">Message bytes</param>
            <returns>MQTT message response</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.SendReceive(System.Byte[],System.Int32)">
            <summary>
            Send a message to the broker and wait answer
            </summary>
            <param name="msgBytes">Message bytes</param>
            <param name="timeout">Timeout for receiving answer</param>
            <returns>MQTT message response</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.SendReceive(Comm.Utils.MqttBroker.Messages.MqttMsgBase)">
            <summary>
            Send a message to the broker and wait answer
            </summary>
            <param name="msg">Message</param>
            <returns>MQTT message response</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.SendReceive(Comm.Utils.MqttBroker.Messages.MqttMsgBase,System.Int32)">
            <summary>
            Send a message to the broker and wait answer
            </summary>
            <param name="msg">Message</param>
            <param name="timeout">Timeout for receiving answer</param>
            <returns>MQTT message response</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.EnqueueInflight(Comm.Utils.MqttBroker.Messages.MqttMsgBase,Comm.Utils.MqttBroker.Messages.MqttMsgFlow)">
            <summary>
            Enqueue a message into the inflight queue
            </summary>
            <param name="msg">Message to enqueue</param>
            <param name="flow">Message flow (publish, acknowledge)</param>
            <returns>Message enqueued or not</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.EnqueueInternal(Comm.Utils.MqttBroker.Messages.MqttMsgBase)">
            <summary>
            Enqueue a message into the internal queue
            </summary>
            <param name="msg">Message to enqueue</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.ReceiveThread">
            <summary>
            从客户端接收消息的线程
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.KeepAliveThread">
            <summary>
            心跳包线程
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.DispatchEventThread">
            <summary>
            调度事件处理方法（用于接收到客户端消自后再提升消息处理）
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.ProcessInflightThread">
            <summary>
            Process inflight messages queue
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.RestoreSession">
            <summary>
            恢复会话。将保存的未处理信息添加到inflightQueue队列中
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.LoadSession(Comm.Utils.MqttBroker.Session.MqttClientSession)">
            <summary>
            加载给定会话
            </summary>
            <param name="session">MQTT Client session to load</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.GetMessageId">
            <summary>
            Generate the next message identifier
            </summary>
            <returns>Message identifier</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClient.MqttMsgContextFinder">
            <summary>
            Finder class for PUBLISH message inside a queue
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClient.MqttMsgContextFinder.#ctor(System.UInt16,Comm.Utils.MqttBroker.Messages.MqttMsgFlow)">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message Id</param>
            <param name="flow">Message flow inside inflight queue</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttProtocolVersion">
            <summary>
            MQTT protocol version
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttClientCollection">
            <summary>
            MQTT client collection
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttClientCollection.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Exceptions.MqttClientException">
            <summary>
            MQTT client exception
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Exceptions.MqttClientException.#ctor(Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode)">
            <summary>
            Constructor
            </summary>
            <param name="code">Error code</param>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Exceptions.MqttClientException.ErrorCode">
            <summary>
            Error code
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode">
            <summary>
            MQTT client erroro code
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.WillWrong">
            <summary>
            Will error (topic, message or QoS level)
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.KeepAliveWrong">
            <summary>
            Keep alive period too large
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.TopicWildcard">
            <summary>
            Topic contains wildcards
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.TopicLength">
            <summary>
            Topic length wrong
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.QosNotAllowed">
            <summary>
            QoS level not allowed
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.TopicsEmpty">
            <summary>
            Topics list empty for subscribe
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.QosLevelsEmpty">
            <summary>
            Qos levels list empty for subscribe
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.TopicsQosLevelsNotMatch">
            <summary>
            Topics / Qos Levels not match in subscribe
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.WrongBrokerMessage">
            <summary>
            Wrong message from broker
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.WrongMessageId">
            <summary>
            Wrong Message Id
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.InflightQueueFull">
            <summary>
            Inflight queue is full
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.InvalidFlagBits">
            <summary>
            Invalid flag bits received 
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.InvalidConnectFlags">
            <summary>
            Invalid connect flags received
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.InvalidClientId">
            <summary>
            Invalid client id
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Exceptions.MqttClientErrorCode.InvalidProtocolName">
            <summary>
            Invalid protocol name
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Exceptions.MqttCommunicationException">
            <summary>
            Exception due to error communication with broker on socket
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Exceptions.MqttCommunicationException.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Exceptions.MqttCommunicationException.#ctor(System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="e">Inner Exception</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Exceptions.MqttConnectionException">
            <summary>
            Connection to the broker exception
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Exceptions.MqttTimeoutException">
            <summary>
            Timeout on receiving from broker exception
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.IMqttNetworkChannel">
            <summary>
            Interface for channel under MQTT library
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.IMqttNetworkChannel.DataAvailable">
            <summary>
            Data available on channel
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.IMqttNetworkChannel.Receive(System.Byte[],System.Boolean)">
            <summary>
            Receive data from the network channel 
            </summary>
            <param name="buffer">Data buffer for receiving data</param>
            <param name="fixedHeader">固定头类型接收 CS ADD 2019.03.22</param>
            <returns>Number of bytes received</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.IMqttNetworkChannel.Receive(System.Byte[],System.Int32)">
            <summary>
            Receive data from the network channel with a specified timeout
            </summary>
            <param name="buffer">Data buffer for receiving data</param>
            <param name="timeout">Timeout on receiving (in milliseconds)</param>
            <returns>Number of bytes received</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.IMqttNetworkChannel.Send(System.Byte[])">
            <summary>
            Send data on the network channel to the broker
            </summary>
            <param name="buffer">Data buffer to send</param>
            <returns>Number of byte sent</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.IMqttNetworkChannel.Close">
            <summary>
            Close the network channel
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.IMqttNetworkChannel.Connect">
            <summary>
            Connect to remote server
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.IMqttNetworkChannel.Accept">
            <summary>
            Accept client connection
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgBase">
            <summary>
            Base class for all MQTT messages
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgBase.Type">
            <summary>
            Message type
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgBase.DupFlag">
            <summary>
            Duplicate message flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgBase.QosLevel">
            <summary>
            Quality of Service level
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgBase.Retain">
            <summary>
            Retain message flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgBase.MessageId">
            <summary>
            Message identifier for the message
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgBase.GetBytes(System.Byte)">
            <summary>
            Returns message bytes rapresentation
            </summary>
            <param name="protocolVersion">Protocol version</param>
            <returns>Bytes rapresentation</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgBase.encodeRemainingLength(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encode remaining length and insert it into message buffer
            </summary>
            <param name="remainingLength">Remaining length value to encode</param>
            <param name="buffer">Message buffer for inserting encoded value</param>
            <param name="index">Index from which insert encoded value into buffer</param>
            <returns>Index updated</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgBase.decodeRemainingLength(Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Decode remaining length reading bytes from socket
            </summary>
            <param name="channel">Channel from reading bytes</param>
            <returns>Decoded remaining length</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgBase.GetTraceString(System.String,System.Object[],System.Object[])">
            <summary>
            Returns a string representation of the message for tracing
            </summary>
            <param name="name">Message name</param>
            <param name="fieldNames">Message fields name</param>
            <param name="fieldValues">Message fields value</param>
            <returns>String representation of the message</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgConnack">
            <summary>
            Class for CONNACK message from broker to client
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnack.SessionPresent">
            <summary>
            Session present flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnack.ReturnCode">
            <summary>
            Return Code
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgConnack.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgConnack.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a CONNACK message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>CONNACK message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgConnect">
            <summary>
            Class for CONNECT message from client to broker
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.ProtocolName">
            <summary>
            Protocol name
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.ProtocolVersion">
            <summary>
            Protocol version
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.ClientId">
            <summary>
            Client identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.WillRetain">
            <summary>
            Will retain flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.WillQosLevel">
            <summary>
            Will QOS level
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.WillFlag">
            <summary>
            Will flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.WillTopic">
            <summary>
            Will topic
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.WillMessage">
            <summary>
            Will message
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.Username">
            <summary>
            Username
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.Password">
            <summary>
            Password
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.CleanSession">
            <summary>
            Clean session flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.KeepAlivePeriod">
            <summary>
            Keep alive period
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="clientId">Client identifier</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.#ctor(System.String,System.String,System.String,System.Boolean,System.Byte,System.Boolean,System.String,System.String,System.Boolean,System.UInt16,System.Byte)">
            <summary>
            Constructor
            </summary>
            <param name="clientId">Client identifier</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="willRetain">Will retain flag</param>
            <param name="willQosLevel">Will QOS level</param>
            <param name="willFlag">Will flag</param>
            <param name="willTopic">Will topic</param>
            <param name="willMessage">Will message</param>
            <param name="cleanSession">Clean sessione flag</param>
            <param name="keepAlivePeriod">Keep alive period</param>
            <param name="protocolVersion">Protocol version</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgConnect.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a CONNECT message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>CONNECT message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgConnectEventArgs">
            <summary>
            从客户端接收到的连接消息的事件参数类
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgConnectEventArgs.Message">
            <summary>
            从客户端接收到的消息
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgConnectEventArgs.#ctor(Comm.Utils.MqttBroker.Messages.MqttMsgConnect)">
            <summary>
            构造函数
            </summary>
            <param name="connect">从客户端接收到的消息t</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgContext">
            <summary>
            Context for MQTT message
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgContext.Message">
            <summary>
            MQTT message
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgContext.State">
            <summary>
            MQTT message state
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgContext.Flow">
            <summary>
            Flow of the message
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgContext.Timestamp">
            <summary>
            Timestamp in ticks (for retry)
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgContext.Attempt">
            <summary>
            Attempt (for retry)
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgContext.Key">
            <summary>
            Unique key
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgFlow">
            <summary>
            Flow of the message
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgFlow.ToPublish">
            <summary>
            To publish to subscribers
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgFlow.ToAcknowledge">
            <summary>
            To acknowledge to publisher
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgState">
            <summary>
            MQTT message state
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.QueuedQos0">
            <summary>
            QOS = 0, Message queued
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.QueuedQos1">
            <summary>
            QOS = 1, Message queued
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.QueuedQos2">
            <summary>
            QOS = 2, Message queued
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.WaitForPuback">
            <summary>
            QOS = 1, PUBLISH sent, wait for PUBACK
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.WaitForPubrec">
            <summary>
            QOS = 2, PUBLISH sent, wait for PUBREC
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.WaitForPubrel">
            <summary>
            QOS = 2, PUBREC sent, wait for PUBREL
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.WaitForPubcomp">
            <summary>
            QOS = 2, PUBREL sent, wait for PUBCOMP
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.SendPubrec">
            <summary>
            QOS = 2, start first phase handshake send PUBREC
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.SendPubrel">
            <summary>
            QOS = 2, start second phase handshake send PUBREL
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.SendPubcomp">
            <summary>
            QOS = 2, end second phase handshake send PUBCOMP
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.SendPuback">
            <summary>
            QOS = 1, PUBLISH received, send PUBACK
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.SendSubscribe">
            <summary>
            Send SUBSCRIBE message
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.SendUnsubscribe">
            <summary>
            Send UNSUBSCRIBE message
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.WaitForSuback">
            <summary>
            (QOS = 1), SUBSCRIBE sent, wait for SUBACK
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Messages.MqttMsgState.WaitForUnsuback">
            <summary>
            (QOS = 1), UNSUBSCRIBE sent, wait for UNSUBACK
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgDisconnect">
            <summary>
            Class for DISCONNECT message from client to broker
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgDisconnect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgDisconnect.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a DISCONNECT message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>DISCONNECT message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPingReq">
            <summary>
            Class for PINGREQ message from client to broker
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPingReq.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPingReq.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PINGREQ message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PINGREQ message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPingResp">
            <summary>
            Class for PINGRESP message from client to broker
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPingResp.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPingResp.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PINGRESP message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PINGRESP message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPuback">
            <summary>
            Class for PUBACK message from broker to client
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPuback.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPuback.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBACK message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBACK message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPubcomp">
            <summary>
            Class for PUBCOMP message from broker to client
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPubcomp.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPubcomp.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBCOMP message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBCOMP message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPublish">
            <summary>
            Class for PUBLISH message from client to broker
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublish.Topic">
            <summary>
            Message topic
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublish.Message">
            <summary>
            Message data
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublish.Username">
            <summary>
            connect时的用户名 ADD CS 2019.4.26
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPublish.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPublish.#ctor(System.String,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPublish.#ctor(System.String,System.Byte[],System.Boolean,System.Byte,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data</param>
            <param name="dupFlag">Duplicate flag</param>
            <param name="qosLevel">Quality of Service level</param>
            <param name="retain">Retain flag</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPublish.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBLISH message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBLISH message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPublishedEventArgs">
            <summary>
            Event Args class for published message
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublishedEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublishedEventArgs.IsPublished">
            <summary>
            Message published (or failed due to retries)
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPublishedEventArgs.#ctor(System.UInt16)">
            <summary>
            Constructor (published message)
            </summary>
            <param name="messageId">Message identifier published</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPublishedEventArgs.#ctor(System.UInt16,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier</param>
            <param name="isPublished">Publish flag</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPublishEventArgs">
            <summary>
            Event Args class for PUBLISH message received from broker
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublishEventArgs.Topic">
            <summary>
            Message topic
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublishEventArgs.Message">
            <summary>
            Message data
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublishEventArgs.DupFlag">
            <summary>
            Duplicate message flag
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublishEventArgs.QosLevel">
            <summary>
            Quality of Service level
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgPublishEventArgs.Retain">
            <summary>
            Retain message flag
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPublishEventArgs.#ctor(System.String,System.Byte[],System.Boolean,System.Byte,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="topic">Message topic</param>
            <param name="message">Message data</param>
            <param name="dupFlag">Duplicate delivery flag</param>
            <param name="qosLevel">Quality of Service level</param>
            <param name="retain">Retain flag</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPubrec">
            <summary>
            Class for PUBREC message from broker to client
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPubrec.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPubrec.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBREC message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBREC message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgPubrel">
            <summary>
            Class for PUBREL message from client top broker
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPubrel.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgPubrel.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a PUBREL message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>PUBREL message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgSuback">
            <summary>
            Class for SUBACK message from broker to client
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgSuback.GrantedQoSLevels">
            <summary>
            List of granted QOS Levels
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgSuback.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgSuback.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a SUBACK message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>SUBACK message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribe">
            <summary>
            Class for SUBSCRIBE message from client to broker
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribe.Topics">
            <summary>
            List of topics to subscribe
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribe.QoSLevels">
            <summary>
            List of QOS Levels related to topics
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribe.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribe.#ctor(System.String[],System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="topics">List of topics to subscribe</param>
            <param name="qosLevels">List of QOS Levels related to topics</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribe.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a SUBSCRIBE message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>SUBSCRIBE message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribedEventArgs">
            <summary>
            Event Args class for subscribed topics
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribedEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribedEventArgs.GrantedQoSLevels">
            <summary>
            List of granted QOS Levels
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribedEventArgs.#ctor(System.UInt16,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier for subscribed topics</param>
            <param name="grantedQosLevels">List of granted QOS Levels</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribeEventArgs">
            <summary>
            Event Args class for subscribe request on topics
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribeEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribeEventArgs.Topics">
            <summary>
            Topics requested to subscribe
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribeEventArgs.QoSLevels">
            <summary>
            List of QOS Levels requested
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgSubscribeEventArgs.#ctor(System.UInt16,System.String[],System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier for subscribe topics request</param>
            <param name="topics">Topics requested to subscribe</param>
            <param name="qosLevels">List of QOS Levels requested</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgUnsuback">
            <summary>
            Class for UNSUBACK message from broker to client
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgUnsuback.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgUnsuback.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a UNSUBACK message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>UNSUBACK message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribe">
            <summary>
            Class for UNSUBSCRIBE message from client to broker
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribe.Topics">
            <summary>
            List of topics to unsubscribe
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribe.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribe.#ctor(System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="topics">List of topics to unsubscribe</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribe.Parse(System.Byte,System.Byte,Comm.Utils.MqttBroker.IMqttNetworkChannel)">
            <summary>
            Parse bytes for a UNSUBSCRIBE message
            </summary>
            <param name="fixedHeaderFirstByte">First fixed header byte</param>
            <param name="protocolVersion">Protocol Version</param>
            <param name="channel">Channel connected to the broker</param>
            <returns>UNSUBSCRIBE message instance</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribedEventArgs">
            <summary>
            Event Args class for unsubscribed topic
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribedEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribedEventArgs.#ctor(System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier for unsubscribed topic</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribeEventArgs">
            <summary>
            Event Args class for unsubscribe request on topics
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribeEventArgs.MessageId">
            <summary>
            Message identifier
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribeEventArgs.Topics">
            <summary>
            Topics requested to subscribe
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Messages.MqttMsgUnsubscribeEventArgs.#ctor(System.UInt16,System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="messageId">Message identifier for subscribed topics</param>
            <param name="topics">Topics requested to subscribe</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttSslProtocols">
            <summary>
            支持SSL/TLS协议版本
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttSettings">
            <summary>
            MQTT服务器的设置类
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.Port">
            <summary>
            监听连接端口
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.SslPort">
            <summary>
            监听SSL连接端口
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.TimeoutOnConnection">
            <summary>
            客户端连接超时(在接收连接消息之前)
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.TimeoutOnReceiving">
            <summary>
            Timeout on receiving
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.AttemptsOnRetry">
            <summary>
            为QoS1/QoS2等级的发布、订阅、取消订阅重试的最多次数
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.DelayOnRetry">
            <summary>
            为QoS1/QoS2等级的重试发布、重试订阅、重试取消订阅的延迟时间
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.InflightQueueSize">
            <summary>
            Inflight queue size
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.TopicSubscribeReservedWord">
            <summary>
            订阅主题系统保留字，不能被设备订阅的主题,如"$"开头的
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttSettings.Instance">
            <summary>
            单例
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttSettings.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Fx">
            <summary>
            Support methods fos specific framework
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttNetworkChannel">
            <summary>
            Channel to communicate over the network
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttNetworkChannel.CommunicationProtocol">
            <summary>
            支持的通讯协议 //CS ADD 2019.03.20
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttNetworkChannel.WSocketWrapper">
            <summary>
            WSWrapper
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttNetworkChannel.RemoteHostName">
            <summary>
            Remote host name
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.MqttNetworkChannel.RemoteEndPoint">
            <summary>
            IP Address of the client connected to Broker
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttNetworkChannel.RemoteIpAddress">
            <summary>
            Remote IP address
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttNetworkChannel.RemotePort">
            <summary>
            Remote port
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttNetworkChannel.SslConnectMsgProcessed">
            <summary>
            SSL连接控制是否已处理
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.MqttNetworkChannel.DataAvailable">
            <summary>
            Data available on the channel
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>
            构造函数
            </summary>
            <param name="socket">Socket opened with the client</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.#ctor(System.Net.Sockets.Socket,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <param name="userCertificateSelectionCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
            <param name="userCertificateValidationCallback">A LocalCertificateSelectionCallback delegate responsible for selecting the certificate used for authentication</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.#ctor(System.String,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="remoteHostName">Remote Host name</param>
            <param name="remotePort">Remote port</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.#ctor(System.String,System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Certificate,Comm.Utils.MqttBroker.MqttSslProtocols,System.Int32,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <param name="userCertificateSelectionCallback">A RemoteCertificateValidationCallback delegate responsible for validating the certificate supplied by the remote party</param>
            <param name="userCertificateValidationCallback">A LocalCertificateSelectionCallback delegate responsible for selecting the certificate used for authentication</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.Connect">
            <summary>
            Connect to remote server
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.Send(System.Byte[])">
            <summary>
            Send data on the network channel
            </summary>
            <param name="buffer">Data buffer to send</param>
            <returns>Number of byte sent</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.SocketReceive(System.Byte[])">
            <summary>
            SocketReceive
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.Receive(System.Byte[],System.Boolean)">
            <summary>
            Receive data from the network
            </summary>
            <param name="buffer">Data buffer for receiving data</param>
            <param name="fixedHeader">固定头类型接收</param>
            <returns>Number of bytes received</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.Receive(System.Byte[],System.Int32)">
            <summary>
            Receive data from the network channel with a specified timeout
            </summary>
            <param name="buffer">Data buffer for receiving data</param>
            <param name="timeout">Timeout on receiving (in milliseconds)</param>
            <returns>Number of bytes received</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.Close">
            <summary>
            Close the network channel
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.MqttNetworkChannel.Accept">
            <summary>
            Accept connection from a remote client
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.IPAddressUtility">
            <summary>
            IPAddress Utility class
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.IPAddressUtility.GetAddressFamily(System.Net.IPAddress)">
            <summary>
            Return AddressFamily for the IP address
            </summary>
            <param name="ipAddress">IP address to check</param>
            <returns>Address family</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.MqttSslUtility">
            <summary>
            MQTT SSL utility class
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Session.MqttBrokerSession">
            <summary>
            MQTT Broker会话
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Session.MqttBrokerSession.Client">
            <summary>
            与订阅相关的客户端
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Session.MqttBrokerSession.Subscriptions">
            <summary>
            订阅信息
            </summary>
        </member>
        <member name="F:Comm.Utils.MqttBroker.Session.MqttBrokerSession.OutgoingMessages">
            <summary>
            Outgoing messages to publish
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Session.MqttBrokerSession.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Session.MqttClientSession">
            <summary>
            客户端会话
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Session.MqttClientSession.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="clientId">根据客户端ID创建会话</param>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Session.MqttSession">
            <summary>
            MQTT会话抽象基类
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Session.MqttSession.ClientId">
            <summary>
            客户端ID
            </summary>
        </member>
        <member name="P:Comm.Utils.MqttBroker.Session.MqttSession.InflightMessages">
            <summary>
            Messages inflight during session
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Session.MqttSession.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Session.MqttSession.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="clientId">根据客户端ID创建会话</param>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Session.MqttSession.Clear">
            <summary>
            清除会话及消息
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Utility.QueueExtension">
            <summary>
            Extension class for a Queue
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Utility.QueueExtension.QueuePredicate">
            <summary>
            Predicate for searching inside a queue
            </summary>
            <param name="item">Item of the queue</param>
            <returns>Result of predicate</returns>
        </member>
        <member name="M:Comm.Utils.MqttBroker.Utility.QueueExtension.Get(System.Collections.Queue,Comm.Utils.MqttBroker.Utility.QueueExtension.QueuePredicate)">
            <summary>
            Get (without removing) an item from queue based on predicate
            </summary>
            <param name="queue">Queue in which to search</param>
            <param name="predicate">Predicate to verify to get item</param>
            <returns>Item matches the predicate</returns>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Utility.TraceLevel">
            <summary>
            Tracing levels
            </summary>
        </member>
        <member name="T:Comm.Utils.MqttBroker.Utility.Trace">
            <summary>
            Tracing class
            </summary>
        </member>
        <member name="T:Comm.Utils.WebSocketWrapper">
            <summary>
            MQTT Over WebSocket 包装器 CS ADD 2019.03.20 
            </summary>
        </member>
        <member name="P:Comm.Utils.WebSocketWrapper.WebSocketJudged">
            <summary>
            是否已判断是WebSocket连接
            </summary>
        </member>
        <member name="P:Comm.Utils.WebSocketWrapper.WebSocket">
            <summary>
            是否WebSocket连接
            </summary>
        </member>
        <member name="M:Comm.Utils.WebSocketWrapper.#ctor(System.Net.Sockets.Socket,System.Boolean,System.Net.Security.SslStream)">
            <summary>
            构造函数
            </summary>
            <param name="socket"></param>
            <param name="secure"></param>
            <param name="sslStream"></param>
        </member>
        <member name="M:Comm.Utils.WebSocketWrapper.Receive(System.Byte[])">
            <summary>
            从当前缓存区Buffer接收数据，同时arrayBuffer左移
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WebSocketWrapper.JudgeAndSendHandshake">
            <summary>
            验证是否WebSocket请求，是的话发送握手确认
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WebSocketWrapper.BufferReceive(System.Net.Sockets.SocketFlags)">
            <summary>
            SOCKET缓存区数据接收
            </summary>
            <param name="socketFlags"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WebSocketWrapper.BufferAnalytic">
            <summary>
            解析WEBSOCKET缓冲区为MQTT缓冲区
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WebSocketWrapper.PackSendBuffer(System.Byte[])">
            <summary>
            打包WEBSOCKET要发送的数据
            </summary>
            <param name="returnBuffer">数据</param>
            <returns>数据包</returns>
        </member>
        <member name="T:Comm.Utils.RecResult">
            <summary>
            RecResult
            </summary>
        </member>
        <member name="P:Comm.Utils.RecResult.ReceiveType">
            <summary>
            ReceiveType
            </summary>
        </member>
        <member name="P:Comm.Utils.RecResult.ReceiveLength">
            <summary>
            ReceiveLength
            </summary>
        </member>
        <member name="M:Comm.Utils.RecResult.#ctor(System.Byte,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="receiveType"></param>
            <param name="receiveLength"></param>
        </member>
        <member name="T:Comm.Utils.NLua.Event.DebugHookEventArgs">
            <summary>
            Event args for hook callback event
            </summary>
        </member>
        <member name="P:Comm.Utils.NLua.Event.DebugHookEventArgs.LuaDebug">
            <summary>
            Lua Debug Information
            </summary>
        </member>
        <member name="T:Comm.Utils.NLua.Exceptions.LuaException">
            <summary>
            Exceptions thrown by the Lua runtime
            </summary>
        </member>
        <member name="T:Comm.Utils.NLua.Exceptions.LuaScriptException">
            <summary>
            Exceptions thrown by the Lua runtime because of errors in the script
            </summary>
            
        </member>
        <member name="P:Comm.Utils.NLua.Exceptions.LuaScriptException.IsNetException">
            <summary>
            Returns true if the exception has occured as the result of a .NET exception in user code
            </summary>
        </member>
        <member name="P:Comm.Utils.NLua.Exceptions.LuaScriptException.Source">
            <summary>
            The position in the script where the exception was triggered.
            </summary>
        </member>
        <member name="M:Comm.Utils.NLua.Exceptions.LuaScriptException.#ctor(System.String,System.String)">
            <summary>
            Creates a new Lua-only exception.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="source">The position in the script where the exception was triggered.</param>
        </member>
        <member name="M:Comm.Utils.NLua.Exceptions.LuaScriptException.#ctor(System.Exception,System.String)">
            <summary>
            Creates a new .NET wrapping exception.
            </summary>
            <param name="innerException">The .NET exception triggered by user-code.</param>
            <param name="source">The position in the script where the exception was triggered.</param>
        </member>
        <member name="M:Comm.Utils.NLua.Extensions.TypeExtensions.GetExtensionMethod(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Extends the System.Type-type to search for a given extended MethodeName.
            </summary>
            <param name="t"></param>
            <param name="name"></param>
            <param name="assemblies"></param>
            <returns></returns>
        </member>
        <member name="E:Comm.Utils.NLua.Lua.HookException">
            <summary>
            Event that is raised when an exception occures during a hook call.
            </summary>
        </member>
        <member name="E:Comm.Utils.NLua.Lua.DebugHook">
            <summary>
            Event when lua hook callback is called
            </summary>
            <remarks>
            Is only raised if SetDebugHook is called before.
            </remarks>
        </member>
        <member name="F:Comm.Utils.NLua.Lua._hookCallback">
            <summary>
            lua hook calback delegate
            </summary>
        </member>
        <member name="P:Comm.Utils.NLua.Lua.IsExecuting">
            <summary>
            True while a script is being executed
            </summary>
        </member>
        <member name="F:Comm.Utils.NLua.Lua._StatePassed">
            <summary>
            Used to ensure multiple .net threads all get serialized by this single lock for access to the lua stack/objects
            </summary>
        </member>
        <member name="P:Comm.Utils.NLua.Lua.Globals">
            <summary>
            An alphabetically sorted list of all globals (objects, methods, etc.) externally added to this Lua instance
            </summary>
            <remarks>Members of globals are also listed. The formatting is optimized for text input auto-completion.</remarks>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.ThrowExceptionFromError(System.Int32)">
            <summary>
            Assuming we have a Lua error string sitting on the stack, throw a C# exception out to the user's app
            </summary>
            <exception cref = "T:Comm.Utils.NLua.Exceptions.LuaScriptException">Thrown if the script caused an exception</exception>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.PushDebugTraceback(Comm.Utils.KeraLua.Lua,System.Int32)">
            <summary>
            Push a debug.traceback reference onto the stack, for a pcall function to use as error handler. (Remember to increment any top-of-stack markers!)
            </summary>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.GetDebugTraceback">
            <summary>
            <para>Return a debug.traceback() call result (a multi-line string, containing a full stack trace, including C calls.</para>
            <para>Note: it won't return anything unless the interpreter is in the middle of execution - that is, it only makes sense to call it from a method called from Lua, or during a coroutine yield.</para>
            </summary>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.SetPendingException(System.Exception)">
            <summary>
            Convert C# exceptions into Lua errors
            </summary>
            <returns>num of things on stack</returns>
            <param name = "e">null for no pending exception</param>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.LoadString(System.String,System.String)">
            <summary>
            
            </summary>
            <param name = "chunk"></param>
            <param name = "name"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.LoadString(System.Byte[],System.String)">
            <summary>
            
            </summary>
            <param name = "chunk"></param>
            <param name = "name"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.LoadFile(System.String)">
            <summary>
            Load a File on, and return a LuaFunction to execute the file loaded (useful to see if the syntax of a file is ok)
            </summary>
            <param name = "fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.DoString(System.Byte[],System.String)">
            <summary>
            Executes a Lua chunk and returns all the chunk's return values in an array.
            </summary>
            <param name = "chunk">Chunk to execute</param>
            <param name = "chunkName">Name to associate with the chunk. Defaults to "chunk".</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.DoString(System.String,System.String)">
            <summary>
            Executes a Lua chunk and returns all the chunk's return values in an array.
            </summary>
            <param name = "chunk">Chunk to execute</param>
            <param name = "chunkName">Name to associate with the chunk. Defaults to "chunk".</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.RegisterGlobal(System.String,System.Type,System.Int32)">
            <summary>
            Adds an entry to <see cref = "F:Comm.Utils.NLua.Lua._globals"/> (recursivley handles 2 levels of members)
            </summary>
            <param name = "path">The index accessor path ot the entry</param>
            <param name = "type">The type of the entry</param>
            <param name = "recursionCounter">How deep have we gone with recursion?</param>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.SetDebugHook(Comm.Utils.KeraLua.LuaHookMask,System.Int32)">
            <summary>
            Activates the debug hook
            </summary>
            <param name = "mask">Mask</param>
            <param name = "count">Count</param>
            <returns>see lua docs. -1 if hook is already set</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.RemoveDebugHook">
            <summary>
            Removes the debug hook
            </summary>
            <returns>see lua docs</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.GetHookMask">
            <summary>
            Gets the hook mask.
            </summary>
            <returns>hook mask</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.GetHookCount">
            <summary>
            Gets the hook count
            </summary>
            <returns>see lua docs</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.GetLocal(Comm.Utils.KeraLua.LuaDebug,System.Int32)">
            <summary>
            Gets local (see lua docs)
            </summary>
            <param name = "luaDebug">lua debug structure</param>
            <param name = "n">see lua docs</param>
            <returns>see lua docs</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.SetLocal(Comm.Utils.KeraLua.LuaDebug,System.Int32)">
            <summary>
            Sets local (see lua docs)
            </summary>
            <param name = "luaDebug">lua debug structure</param>
            <param name = "n">see lua docs</param>
            <returns>see lua docs</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.GetUpValue(System.Int32,System.Int32)">
            <summary>
            Gets up value (see lua docs)
            </summary>
            <param name = "funcindex">see lua docs</param>
            <param name = "n">see lua docs</param>
            <returns>see lua docs</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.SetUpValue(System.Int32,System.Int32)">
            <summary>
            Sets up value (see lua docs)
            </summary>
            <param name = "funcindex">see lua docs</param>
            <param name = "n">see lua docs</param>
            <returns>see lua docs</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.DebugHookCallback(System.IntPtr,System.IntPtr)">
            <summary>
            Delegate that is called on lua hook callback
            </summary>
            <param name = "luaState">lua state</param>
            <param name = "luaDebug">Pointer to LuaDebug (lua_debug) structure</param>
            
        </member>
        <member name="M:Comm.Utils.NLua.Lua.Pop">
            <summary>
            Pops a value from the lua stack.
            </summary>
            <returns>Returns the top value from the lua stack.</returns>
        </member>
        <member name="M:Comm.Utils.NLua.Lua.Push(System.Object)">
            <summary>
            Pushes a value onto the lua stack.
            </summary>
            <param name = "value">Value to push.</param>
        </member>
        <member name="T:Comm.Utils.NLua.LuaBase">
            <summary>
            Base class to provide consistent disposal flow across lua objects. Uses code provided by Yves Duhoux and suggestions by Hans Schmeidenbacher and Qingrui Li 
            </summary>
        </member>
        <member name="T:Comm.Utils.NLua.LuaGlobalAttribute">
            <summary>
            Marks a method for global usage in Lua scripts
            </summary>
            <see cref="M:Comm.Utils.NLua.LuaRegistrationHelper.TaggedInstanceMethods(Comm.Utils.NLua.Lua,System.Object)"/>
            <see cref="M:Comm.Utils.NLua.LuaRegistrationHelper.TaggedStaticMethods(Comm.Utils.NLua.Lua,System.Type)"/>
        </member>
        <member name="P:Comm.Utils.NLua.LuaGlobalAttribute.Name">
            <summary>
            An alternative name to use for calling the function in Lua - leave empty for CLR name
            </summary>
        </member>
        <member name="P:Comm.Utils.NLua.LuaGlobalAttribute.Description">
            <summary>
            A description of the function
            </summary>
        </member>
        <member name="T:Comm.Utils.NLua.LuaHideAttribute">
            <summary>
            Marks a method, field or property to be hidden from Lua auto-completion
            </summary>
        </member>
        <member name="M:Comm.Utils.NLua.LuaRegistrationHelper.TaggedInstanceMethods(Comm.Utils.NLua.Lua,System.Object)">
            <summary>
            Registers all public instance methods in an object tagged with <see cref="T:Comm.Utils.NLua.LuaGlobalAttribute"/> as Lua global functions
            </summary>
            <param name="lua">The Lua VM to add the methods to</param>
            <param name="o">The object to get the methods from</param>
        </member>
        <member name="M:Comm.Utils.NLua.LuaRegistrationHelper.TaggedStaticMethods(Comm.Utils.NLua.Lua,System.Type)">
            <summary>
            Registers all public static methods in a class tagged with <see cref="T:Comm.Utils.NLua.LuaGlobalAttribute"/> as Lua global functions
            </summary>
            <param name="lua">The Lua VM to add the methods to</param>
            <param name="type">The class type to get the methods from</param>
        </member>
        <member name="M:Comm.Utils.NLua.LuaRegistrationHelper.Enumeration``1(Comm.Utils.NLua.Lua)">
            <summary>
            Registers an enumeration's values for usage as a Lua variable table
            </summary>
            <typeparam name="T">The enum type to register</typeparam>
            <param name="lua">The Lua VM to add the enum to</param>
        </member>
        <member name="M:Comm.Utils.NLua.MetaFunctions.DumpStack(Comm.Utils.NLua.ObjectTranslator,Comm.Utils.KeraLua.Lua)">
            <summary>
            Debug tool to dump the lua stack
            </summary>
            FIXME, move somewhere else
        </member>
        <member name="M:Comm.Utils.NLua.MetaFunctions.IsMemberPresent(Comm.Utils.NLua.ProxyType,System.String)">
            <summary>
            Does this method exist as either an instance or static?
            </summary>
            <param name="objType"></param>
            <param name="methodName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NLua.MetaFunctions.TrySetMember(Comm.Utils.KeraLua.Lua,Comm.Utils.NLua.ProxyType,System.Object,System.Reflection.BindingFlags,System.String@)">
            <summary>
            Tries to set a named property or field
            </summary>
            <param name="luaState"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <param name="bindingType"></param>
            <returns>false if unable to find the named member, true for success</returns>
        </member>
        <member name="M:Comm.Utils.NLua.MetaFunctions.ThrowError(Comm.Utils.KeraLua.Lua,System.Exception)">
            <summary>
            Convert a C# exception into a Lua error
            </summary>
            <param name="e"></param>
            <param name="luaState"></param>
            We try to look into the exception to give the most meaningful description
        </member>
        <member name="M:Comm.Utils.NLua.MetaFunctions.IsTypeCorrect(Comm.Utils.KeraLua.Lua,System.Int32,System.Reflection.ParameterInfo,Comm.Utils.NLua.Method.ExtractValue@)">
            <summary>
            Returns true if the type is set and assigns the extract value
            </summary>
            <param name="luaState"></param>
            <param name="currentLuaParam"></param>
            <param name="currentNetParam"></param>
            <param name="extractValue"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.NLua.Method.EventHandlerContainer">
            <summary>
            We keep track of what delegates we have auto attached to an event - to allow us to cleanly exit a NLua session
            </summary>
        </member>
        <member name="M:Comm.Utils.NLua.Method.EventHandlerContainer.Dispose">
            <summary>
            Remove any still registered handlers
            </summary>
        </member>
        <member name="M:Comm.Utils.NLua.Method.LuaMethodWrapper.SetPendingException(System.Exception)">
            <summary>
            Convert C# exceptions into Lua errors
            </summary>
            <returns>num of things on stack</returns>
            <param name="e">null for no pending exception</param>
        </member>
        <member name="F:Comm.Utils.NLua.ObjectTranslator._nextObj">
            <summary>
            We want to ensure that objects always have a unique ID
            </summary>
        </member>
        <member name="M:Comm.Utils.NLua.ObjectTranslator.CollectObject(System.Int32)">
            <summary>
            Given the Lua int ID for an object remove it from our maps
            </summary>
            <param name = "udata"></param>
        </member>
        <member name="M:Comm.Utils.NLua.ObjectTranslator.CollectObject(System.Object,System.Int32)">
            <summary>
            Given an object reference, remove it from our maps
            </summary>
            <param name = "o"></param>
            <param name = "udata"></param>
        </member>
        <member name="T:Comm.Utils.NLua.ProxyType">
            <summary>
            Summary description for ProxyType.
            </summary>
        </member>
        <member name="M:Comm.Utils.NLua.ProxyType.ToString">
            <summary>
            Provide human readable short hand for this proxy object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.CommunicationMode">
            <summary>
            允许通讯方式
            </summary>
        </member>
        <member name="F:Comm.Utils.CommunicationMode.Both">
            <summary>
            全部
            </summary>
        </member>
        <member name="F:Comm.Utils.CommunicationMode.OnlyTCP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Comm.Utils.CommunicationMode.OnlyWebSocket">
            <summary>
            
            </summary>
        </member>
        <member name="T:Comm.Utils.StateObject">
            <summary>
            SOCKET状态对象
            </summary>
        </member>
        <member name="P:Comm.Utils.StateObject.WorkSocket">
            <summary>
            工作Socket
            </summary>
        </member>
        <member name="P:Comm.Utils.StateObject.Buffer">
            <summary> 
            接收数据缓冲区 
            </summary> 
        </member>
        <member name="P:Comm.Utils.StateObject.BytesRead">
            <summary>
            读取的字节长度
            </summary>
        </member>
        <member name="M:Comm.Utils.StateObject.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.KeepAlive">
            <summary>
            心跳包对象
            </summary>
        </member>
        <member name="P:Comm.Utils.KeepAlive.KeepAlivePeriod">
            <summary>
            心跳包的超时时间(单位：ms)，维持生命周期
            </summary>
        </member>
        <member name="P:Comm.Utils.KeepAlive.KeepAlivePacket">
            <summary>
            心跳包通信报文
            </summary>
        </member>
        <member name="P:Comm.Utils.KeepAlive.KeepAlivePacketAry">
            <summary>
            心跳包通信报文（字节）
            </summary>
        </member>
        <member name="M:Comm.Utils.KeepAlive.#ctor(System.Int32,System.String,Comm.Utils.Parser)">
            <summary>
            构造函数
            </summary>
            <param name="keepAlivePeriod"></param>
            <param name="keepAlivePacket"></param>
            <param name="parser"></param>
        </member>
        <member name="M:Comm.Utils.KeepAlive.IsKeepAlivePayload(System.String)">
            <summary>
            是否心跳包报文
            </summary>
            <param name="payload">客户端发送的报文</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.Session">
            <summary> 
            客户端与服务器之间的会话类 
            说明: 
            会话类包含远程通讯端的状态,这些状态包括Socket,报文内容, 
            客户端退出的类型(正常关闭,强制退出两种类型) 
            </summary> 
        </member>
        <member name="F:Comm.Utils.Session.ConnectionClosed">
            <summary>
            连接关闭事件
            </summary>
        </member>
        <member name="P:Comm.Utils.Session.ID">
            <summary> 
            返回会话的ID 
            </summary> 
        </member>
        <member name="P:Comm.Utils.Session.ClientSocket">
            <summary> 
            获得与客户端会话关联的Socket对象 
            </summary> 
        </member>
        <member name="P:Comm.Utils.Session.CommunicationState">
            <summary>
            通讯状态
            </summary>
        </member>
        <member name="P:Comm.Utils.Session.ConnectDateTime">
            <summary>
            连接时间
            </summary>
        </member>
        <member name="P:Comm.Utils.Session.ReceiveDateTime">
            <summary>
            最近接收报文时间
            </summary>
        </member>
        <member name="P:Comm.Utils.Session.TypeOfExit">
            <summary> 
            存取客户端的退出方式 
            </summary> 
        </member>
        <member name="P:Comm.Utils.Session.WebSocketJudged">
            <summary>
            是否已判断是WebSocket连接
            </summary>
        </member>
        <member name="P:Comm.Utils.Session.WebSocket">
            <summary>
            是否WebSocket连接
            </summary>
        </member>
        <member name="M:Comm.Utils.Session.#ctor(System.Net.Sockets.Socket,System.Boolean,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="cliSock">会话使用的Socket连接</param>
            <param name="brocker">是否服务端初始</param>
            <param name="keepAlivePeriod">心跳包的超时时间(单位：ms)，维持生命周期</param>
        </member>
        <member name="M:Comm.Utils.Session.#ctor(System.Net.Sockets.Socket,System.Int32,System.Byte[])">
            <summary>
            构造函数
            </summary>
            <param name="cliSock">会话使用的Socket连接</param>
            <param name="keepAlivePeriod">心跳包的超时时间(单位：ms)，维持生命周期</param>
            <param name="keepAlivePacket">客户端心跳包报文</param>
        </member>
        <member name="M:Comm.Utils.Session.GetHashCode">
            <summary> 
            使用Socket对象的Handle值作为HashCode,它具有良好的线性特征. 
            </summary> 
            <returns></returns> 
        </member>
        <member name="M:Comm.Utils.Session.Equals(System.Object)">
            <summary> 
            返回两个Session是否代表同一个客户端 
            </summary> 
            <param name="obj"></param> 
            <returns></returns> 
        </member>
        <member name="M:Comm.Utils.Session.ToString">
            <summary> 
            重载ToString()方法,返回Session对象的特征 
            </summary> 
            <returns></returns> 
        </member>
        <member name="M:Comm.Utils.Session.Init(System.Net.Sockets.Socket,System.Boolean,System.Int32,System.Byte[])">
            <summary>
            构造函数
            </summary>
            <param name="cliSock">会话使用的Socket连接</param>
            <param name="brocker">是否服务端初始</param>
            <param name="keepAlivePeriod">心跳包的超时时间(单位：ms)，维持生命周期</param>
            <param name="keepAlivePacket">客户端心跳包报文</param>
        </member>
        <member name="M:Comm.Utils.Session.KeepAliveThread">
            <summary>
            心跳包线程
            </summary>
        </member>
        <member name="M:Comm.Utils.Session.OnConnectionClosed">
            <summary>
            每次客户端断开连接的包装器方法
            </summary>
        </member>
        <member name="M:Comm.Utils.Session.Ping">
            <summary>
            发送Ping和对方保持在线
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.Session.PackData(System.Byte[])">
            <summary>
            打包要发送的数据
            </summary>
            <param name="message">数据</param>
            <returns>数据包</returns>
        </member>
        <member name="M:Comm.Utils.Session.Open">
            <summary>
            打开会话
            </summary>
        </member>
        <member name="M:Comm.Utils.Session.Close">
            <summary> 
            关闭会话 
            </summary> 
        </member>
        <member name="M:Comm.Utils.Session.JudgeAndSendHandshake(System.Byte[],System.Int32)">
            <summary>
            将Sec-WebSocket-Accept字符串打包成握手响应报文
            </summary>
            <param name="arrayBuffer"></param>
            <param name="dataLength"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.Session.AnalyticBuffer(Comm.Utils.StateObject)">
            <summary>
            分析缓冲区数据
            </summary>
            <param name="state">接收缓充区数据</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.Session.SendText(System.Byte[])">
            <summary> 
            发送数据 
            </summary> 
            <param name="datagram">数据报文</param> 
        </member>
        <member name="M:Comm.Utils.Session.SendDataEnd(System.IAsyncResult)">
            <summary> 
            发送数据完成处理函数 
            </summary> 
            <param name="iar">目标客户端Socket</param> 
        </member>
        <member name="M:Comm.Utils.Session.SendTextSync(System.Byte[])">
            <summary> 
            发送数据 (同发发送)
            </summary> 
            <param name="datagram">数据报文</param> 
        </member>
        <member name="M:Comm.Utils.Session.SetExitType(Comm.Utils.ExitType)">
            <summary>
            设置客户端退出类型
            </summary>
            <param name="exitType"></param>
        </member>
        <member name="T:Comm.Utils.SessionId">
            <summary> 
            唯一的标志一个Session,辅助Session对象在Hash表中完成特定功能 
            </summary> 
        </member>
        <member name="F:Comm.Utils.SessionId._id">
            <summary> 
            与Session对象的Socket对象的Handle值相同,必须用这个值来初始化它 
            </summary> 
        </member>
        <member name="P:Comm.Utils.SessionId.ID">
            <summary> 
            返回ID值 
            </summary> 
        </member>
        <member name="M:Comm.Utils.SessionId.#ctor(System.Int32)">
            <summary> 
            构造函数 
            </summary> 
            <param name="id">Socket的Handle值</param> 
        </member>
        <member name="M:Comm.Utils.SessionId.Equals(System.Object)">
            <summary> 
            重载.为了符合Hashtable键值特征 
            </summary> 
            <param name="obj"></param> 
            <returns></returns> 
        </member>
        <member name="M:Comm.Utils.SessionId.GetHashCode">
            <summary> 
            重载.为了符合Hashtable键值特征 
            </summary> 
            <returns></returns> 
        </member>
        <member name="M:Comm.Utils.SessionId.ToString">
            <summary> 
            重载,为了方便显示输出 
            </summary> 
            <returns></returns> 
        </member>
        <member name="T:Comm.Utils.TcpClient">
            <summary> 
            提供Tcp网络连接服务的客户端类 
            
            原理: 
            1.使用异步Socket通讯与服务器按照一定的通讯格式通讯,请注意与服务器的通 
            讯格式一定要一致,否则可能造成服务器程序崩溃,整个问题没有克服,怎么从byte[] 
            判断它的编码格式 
            2.支持带标记的数据报文格式的识别,以完成大数据报文的传输和适应恶劣的网 
            络环境. 
            </summary> 
        </member>
        <member name="E:Comm.Utils.TcpClient.ConnectedServer">
            <summary> 
            已经连接服务器事件 
            </summary> 
        </member>
        <member name="E:Comm.Utils.TcpClient.ReceivedDatagram">
            <summary> 
            接收到数据报文事件 
            </summary> 
        </member>
        <member name="E:Comm.Utils.TcpClient.DisConnectedServer">
            <summary> 
            连接断开事件 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpClient.ClientSession">
            <summary> 
            返回客户端与服务器之间的会话对象 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpClient.IsConnected">
            <summary> 
            返回客户端与服务器之间的连接状态 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpClient.ServerCoder">
            <summary> 
            编码解码器 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpClient.FilePath">
            <summary> 
            客户端文件保存路径 
            </summary> 
        </member>
        <member name="M:Comm.Utils.TcpClient.#ctor(System.String,System.Int32,System.Text.Encoding,System.String,System.Int32,System.String,System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="serverIp">服务端IP</param>
            <param name="port">端口</param>
            <param name="encoding">编码格式</param>
            <param name="endTag">帖包/分包标志</param>
            <param name="keepAlivePeriod">心跳包的超时时间(单位：ms)，维持生命周期</param>
            <param name="keepAlivePacket">PING心跳包报文（keepAlivePeriod > 0不可为空）</param>
            <param name="keepAliveRespPacket">服务端心跳包消息（keepAlivePeriod > 0不可为空）</param>
            <param name="saveFilePath">通讯文件保存路径</param>
        </member>
        <member name="M:Comm.Utils.TcpClient.#ctor(System.String,System.Int32,System.Text.Encoding,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="serverIp">服务端IP</param>
            <param name="port">端口</param>
            <param name="encoding">编码格式</param>
            <param name="endTag">帖包/分包标志</param>
        </member>
        <member name="M:Comm.Utils.TcpClient.CreateSession(System.Net.Sockets.Socket)">
            <summary>
            通过Socket创建新Session
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TcpClient.Connected(System.IAsyncResult)">
            <summary> 
            建立Tcp连接后处理过程 
            </summary> 
            <param name="iar">异步Socket</param> 
        </member>
        <member name="M:Comm.Utils.TcpClient.ReceiveData(System.IAsyncResult)">
            <summary> 
            数据接收处理函数 
            </summary> 
            <param name="iar">异步Socket</param> 
        </member>
        <member name="M:Comm.Utils.TcpClient.ReceiveHandle(Comm.Utils.StateObject)">
            <summary>
            接收处理
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Comm.Utils.TcpClient.TriggerReceiveEvent(System.Byte[])">
            <summary>
            触发事件接收
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Comm.Utils.TcpClient.GetStrDatagram(System.Byte[])">
            <summary>
            解析接收数据
            </summary>
            <param name="arrayDatagram"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TcpClient.Connect">
            <summary> 
            连接服务器 
            </summary> 
        </member>
        <member name="M:Comm.Utils.TcpClient.SendText(System.String)">
            <summary> 
            发送数据报文 
            </summary> 
            <param name="datagram"></param> 
        </member>
        <member name="M:Comm.Utils.TcpClient.SendText(System.Byte[])">
            <summary> 
            发送数据报文 
            </summary> 
            <param name="datagram"></param> 
        </member>
        <member name="M:Comm.Utils.TcpClient.SendFile(System.String)">
            <summary>
            发送文件
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Comm.Utils.TcpClient.Close">
            <summary> 
            关闭连接 
            </summary> 
        </member>
        <member name="T:Comm.Utils.Allocator`1">
            <summary>
            The allocator is the object that is able to create the real instance of the Singleton and the one that handles the creation policy.
            </summary>
            <remarks>
            Allocators are special objects that must have default parameterless constructors and the assembly that contains them must have private reflection security permissions.<br/>
            For more information about Allocator Policies and Generic Singletons please refer to the "Modern C++ Design: Generic Programming and Design Patterns Applied" from Andrei Alexandrescu.
            </remarks>
        </member>
        <member name="M:Comm.Utils.Allocator`1.#ctor">
            <summary>
            The parameterless protected Constructor.
            </summary>
        </member>
        <member name="P:Comm.Utils.Allocator`1.Instance">
            <summary>
            The property returns the only instance of the Singleton Object in question.
            </summary>
            <remarks>This property implementation must enforce the Single Object property of Singletons throwing an exception.</remarks>
        </member>
        <member name="M:Comm.Utils.Allocator`1.Dispose">
            <summary>
            The implementation of the IDisposable interface.
            </summary>
        </member>
        <member name="T:Comm.Utils.LazyAllocator`1">
            <summary>
            A lazy allocator that creates the object the first time a reference to the singleton is required, it is thread safe using a lock over the type parameter.
            </summary>
        </member>
        <member name="M:Comm.Utils.LazyAllocator`1.#ctor">
            <summary>
            The constructor of the LazyAllocator
            </summary>
        </member>
        <member name="P:Comm.Utils.LazyAllocator`1.Instance">
            <summary>
            The instance property creates the singleton object upon the first request.
            </summary>
            <remarks>The allocator ensure the thread safety using a lock and it enforces the Singleton uniqueness property.</remarks>
        </member>
        <member name="M:Comm.Utils.LazyAllocator`1.Dispose">
            <summary>
            dispose resource data
            </summary>
        </member>
        <member name="T:Comm.Utils.LazySingleton`1">
            <summary>
            A LazySingleton implementation using a LazyAllocator just to simplify the syntax of the Singleton inheritance.
            </summary>
        </member>
        <member name="T:Comm.Utils.LazyArgSingleton`1">
            <summary>
            A LazySingleton implementation using a args Contructor.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Comm.Utils.LazyArgSingleton`1.#ctor">
            <summary>
            Abstract class constructor hidden from general use.
            </summary>
        </member>
        <member name="M:Comm.Utils.LazyArgSingleton`1.GetInstance(System.Object[])">
            <summary>
            Retrieve or create (for the first time) an instance of the derrived type.
            </summary>
            <param name="args">
            Arguments for the non-public constructor of the derrived type.
            Ignored for all but the first successful call to this method.
            </param>
            <returns>An instance of the derrived class.</returns>
        </member>
        <member name="P:Comm.Utils.LazyArgSingleton`1.Instance">
            <summary>
            Retrieve or create (for the first time) an instance of the derrived type.
            </summary>
        </member>
        <member name="T:Comm.Utils.Singleton`2">
            <summary>
            The Singleton implementation, it resorts to the allocator to enforce the creation policy.
            </summary>
            <remarks>
            Depending on the allocator selected the creation policy will change, it is up to the designer to use the creation policy that better represent the needs of the whole system.<br/>
            It is a very good idea to inherit from Singleton with a default allocator to simplify the type definition for the application developers, but it is not a requirement. The library already provides LazySingleton and StaticSingleton as standard types, so you can use them instead of the full descriptive version.<br/>For more information about Allocator Policies and Generic Singletons please refer to the "Modern C++ Design: Generic Programming and Design Patterns Applied" from Andrei Alexandrescu.
            </remarks>
        </member>
        <member name="P:Comm.Utils.Singleton`2.Instance">
            <summary>
            The Singleton implementation of the Instance method defer the creation policy to its allocator, so this method just delegate the Instance retrieval to the Instance method of the allocator.
            </summary>
        </member>
        <member name="M:Comm.Utils.Singleton`2.#cctor">
            <summary>
            The protected parameterless constructor used to not allow the creation of multiple Singleton classes. This property must be enforced by the singleton users.
            </summary>
        </member>
        <member name="M:Comm.Utils.Singleton`2.Dispose">
            <summary>
            The standard Dispose pattern.
            </summary>
        </member>
        <member name="T:Comm.Utils.StaticAllocator`1">
            <summary>
            An static threadsafe allocator that creates the object on class loading by the framework.
            </summary>
            <remarks>The framework specifies that the static constructor is called in an isolated compartment so there is no posibility that multiple threads can access the static constructor.</remarks>
        </member>
        <member name="P:Comm.Utils.StaticAllocator`1.Instance">
            <summary>
            The static allocator Instance property returns the instance created on class loading.
            </summary>
            <remarks>This means that the singleton is instantiated at the moment in which a class has a reference to that type even if it never calls the Instance method.</remarks>
        </member>
        <member name="M:Comm.Utils.StaticAllocator`1.Dispose">
            <summary>
            dispose resource data
            </summary>
        </member>
        <member name="T:Comm.Utils.StaticSingleton`1">
            <summary>
            An StaticSingleton using an StaticAllocator used just to simplify the inheritance syntax.
            </summary>
        </member>
        <member name="T:Comm.Utils.StaticSingleton">
            <summary>
            An StaticSingleton support no parent 
            </summary>
        </member>
        <member name="M:Comm.Utils.StaticSingleton.#cctor">
            <summary>
            静态构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.StaticSingleton.GetInstance``1(System.Object[])">
            <summary>
            获取Singleton实例
            </summary>
            <typeparam name="T">构造的范型类型参数</typeparam>
            <param name="args">构造参数</param>
            <returns>返回Singleton实例</returns>
        </member>
        <member name="T:Comm.Utils.ExitType">
            <summary> 
            退出类型枚举 
            </summary> 
        </member>
        <member name="F:Comm.Utils.ExitType.NotExit">
            <summary>
            未退出
            </summary>
        </member>
        <member name="F:Comm.Utils.ExitType.NormalExit">
            <summary>
            正常退出
            </summary>
        </member>
        <member name="F:Comm.Utils.ExitType.TimeoutExit">
            <summary>
            超时退出
            </summary>
        </member>
        <member name="F:Comm.Utils.ExitType.ExceptionExit">
            <summary>
            异常退出
            </summary>
        </member>
        <member name="F:Comm.Utils.ExitType.ForceExit">
            <summary>
            被强制退出
            </summary>
        </member>
        <member name="T:Comm.Utils.SocketConnectState">
            <summary>
            连接状态
            </summary>
        </member>
        <member name="F:Comm.Utils.SocketConnectState.Connecting">
            <summary>
            开始连接
            </summary>
        </member>
        <member name="F:Comm.Utils.SocketConnectState.ConnectError">
            <summary>
            连接失败
            </summary>
        </member>
        <member name="F:Comm.Utils.SocketConnectState.ConnectSuccess">
            <summary>
            连接成功/握手成功
            </summary>
        </member>
        <member name="F:Comm.Utils.SocketConnectState.UnConnect">
            <summary>
            未连接/断开连接
            </summary>
        </member>
        <member name="T:Comm.Utils.IScheduler">
            <summary>
            调度器接口
            </summary>
        </member>
        <member name="M:Comm.Utils.IScheduler.Add(System.Threading.Tasks.Task)">
            <summary>
            添加任务
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Comm.Utils.IScheduler.Remove(System.Threading.Tasks.Task)">
            <summary>
            移除任务
            </summary>
            <param name="t"></param>
        </member>
        <member name="P:Comm.Utils.IScheduler.Count">
            <summary>
            任务个数
            </summary>
        </member>
        <member name="P:Comm.Utils.IScheduler.Item(System.Int32)">
            <summary>
            任务索引
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.SchedulerEnumerator">
            <summary>
            任务调度器枚举器
            </summary>
        </member>
        <member name="M:Comm.Utils.SchedulerEnumerator.#ctor(Comm.Utils.IScheduler)">
            <summary>
            构造函数
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Comm.Utils.SchedulerEnumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.LibTaskScheduler`1">
            <summary>
            任务调度器
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Comm.Utils.LibTaskScheduler`1.Scheduler">
            <summary>
            调度器
            </summary>
        </member>
        <member name="M:Comm.Utils.LibTaskScheduler`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.LibTaskScheduler`1.Process">
            <summary>
            开始
            </summary>
        </member>
        <member name="M:Comm.Utils.LibTaskScheduler`1.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:Comm.Utils.LibTaskScheduler`1.TryDequeue(System.Threading.Tasks.Task)">
            <summary>
            
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.LibTaskScheduler`1.GetScheduledTasks">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.LibTaskScheduler`1.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            
            </summary>
            <param name="task"></param>
            <param name="taskWasPreviouslyQueued"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.QueueScheduler">
            <summary>
            队列调度器（P产生1,2,3,4,5,6,3,2；C处理顺序应为1,2,3,4,5,6,3,2）
            </summary>
        </member>
        <member name="M:Comm.Utils.QueueScheduler.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.StackScheduler">
            <summary>
            堆叠调度器（P产生1,2,3,4,5,6,3,2;C处理顺序应为2,3,6,5,4,3,2,1）
            </summary>
        </member>
        <member name="M:Comm.Utils.StackScheduler.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Comm.Utils.DynamicQueueScheduler">
            <summary>
            动态队列调度器（P产生1,2,3,4,5,6,3,2;C处理顺序为1,4,5,6,3,2）
            </summary>
        </member>
        <member name="M:Comm.Utils.DynamicQueueScheduler.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Comm.Utils.DynamicStackScheduler">
            <summary>
            动态堆叠调度器（P产生1,2,3,4,5,6,3,2;C处理顺序为2,3,6,5,4,1）
            </summary>
        </member>
        <member name="M:Comm.Utils.DynamicStackScheduler.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Comm.Utils.ProcessHelper">
            <summary>
            进程助手
            </summary>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.CheckParentPrecessID(System.Collections.Generic.List{Comm.Utils.PROCESSENTRY32},Comm.Utils.PROCESSENTRY32,System.Int32)">
            <summary>
            检测指定的进程的父进程ID与传递的父进程ID是否相符,或父进程还在快照中
            </summary>
            <param name="ltProcess"></param>
            <param name="processEntry"></param>
            <param name="parentProcessID"></param>
            <returns>相符返回true</returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.GetProcess">
            <summary>
            获取进程快照列表
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.FindAndKillProcess(System.String,System.Int32)">
            <summary>
            查找且删除进程
            </summary>
            <param name="processName">进程名</param>
            <param name="parentProcessID">父进程ID</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.FindAndKillProcess(System.String)">
            <summary>
            查找且删除进程
            </summary>
            <param name="processName">进程名</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.GetProcessList">
            <summary>
            获取所有进程
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.ExistProcess(System.String)">
            <summary>
            指定进程是否存在
            </summary>
            <param name="processName">进程名</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.KillProcess(System.String)">
            <summary>
            删除指定进程
            </summary>
            <param name="proceName">进程名</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.KillProcess(System.Int32)">
            <summary>
            删除进程
            </summary>
            <param name="pid">进程ID</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.RemoveFolderByCMD(System.String[])">
            <summary>
            通过命令行静默删除指定目录， 不会卡程序
            </summary>
            <param name="folders">目录数组列表</param>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.StartProcess(System.String,System.String,System.String,System.Boolean)">
            <summary>
            启动进程（此方法等待被启动的进程主窗口句柄出现再返回）
            </summary>
            <param name="path">进程路径</param>
            <param name="programName">应用程序名</param>
            <param name="arguments">参数</param>
            <param name="isIncludeQuotes">参数是否包含引号</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.StartProcess(System.Diagnostics.ProcessStartInfo,System.Boolean)">
            <summary>
            启动进程
            </summary>
            <param name="psi"></param>
            <param name="waitWindowHandle">是否等待进程主句柄</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.StratProcess(System.String,System.String)">
            <summary>
            启动指定文件的进程，此方法通常是服务进程启动用户进程
            </summary>
            <param name="path">路径</param>
            <param name="arguments">参数</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.GetCurrentUserToken">
            <summary>
            取得当前账户令牌
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.WTSEnumerateSessions(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.Int32@)">
             <summary>
            检索指定的终端服务器上的会话列表
             </summary>
             <param name="hServer">到终端服务器的句柄。指定由WTSOpenServer函数打开的句柄，或指定WTS_CURRENT_SERVER_HANDLE的显示终端服务器上运行您的应用程序</param>
             <param name="Reserved">保留，必须为零</param>
             <param name="Version">指定枚举要求的版本。必须为1</param>
             <param name="ppSessionInfo">一个变量接收WTS_SESSION_INFO结构数组的指针的指针。数组中的每个结构包含指定的终端服务器上的会话信息。要释放返回的缓冲区，调用WTSFreeMemory功能</param>
             <param name="pCount">接收WTS_SESSION_INFO结构变量的指针在ppSessionInfo缓冲区的个数</param>
             <returns>如果函数成功，返回值是一个非零值。如果函数失败，返回值是零。为了获得更多的错误信息</returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.WTSQuerySessionInformation(System.IntPtr,System.Int32,Comm.Utils.ProcessHelper.WTS_INFO_CLASS,System.Text.StringBuilder@,System.Int32@)">
            <summary>
            检索指定的终端服务器上指定的会话的会话信息。它可用于查询在本地和远程终端服务器的会话信息。
            </summary>
            <param name="hServer">到终端服务器的句柄。指定由WTSOpenServer函数打开的句柄，或指定WTS_CURRENT_SERVER_HANDLE的显示终端服务器上运行您的应用程序</param>
            <param name="sessionId">一个终端服务会话标识符。为了表明会话在调用应用程序正在运行（或当前会话）指定WTS_CURRENT_SESSION。在本地服务器上获取会话信息时，只有指定WTS_CURRENT_SESSION。如果WTS_CURRENT_SESSION指定的远程服务器上的会话信息查询时，将返回一个错误</param>
            <param name="wtsInfoClass">查看<see cref="T:Comm.Utils.ProcessHelper.WTS_INFO_CLASS"/>说明</param>
            <param name="ppBuffer">接收所要求的信息的指针的变量的指针。数据的格式和内容取决于在WTSInfoClass参数中指定的信息类。要释放返回的缓冲区，调用WTSFreeMemory功能。</param>
            <param name="pBytesReturned">接收大小，以字节的数据，一个变量的指针返回ppBuffer</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.WTSFreeMemory(System.IntPtr)">
            <summary>
            释放分配的内存
            </summary>
            <param name="memory">指定的内存指针</param>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.WTSQueryUserToken(System.Int32,System.IntPtr@)">
            <summary>
            获取指定用户会话对应的令牌
            此方法获得初级会话ID指定的登录用户访问令牌。要成功地调用这个函数，
            调用应用程序必须运行在LocalSystem帐户的上下文有SE_TCB_NAME权限。
            它是没有必要的，终端服务的功能，以成功运行的，但如果终端服务没有运行
            ，唯一有效的会话标识符是零（0）。 Windows Vista和Windows Server 2008中唯一的服务和服务启动的进程运行在会话0。
            </summary>
            <param name="sessionId">用户会话标识</param>
            <param name="tokenHandle">对应的令牌 指针</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.DuplicateTokenEx(System.IntPtr,System.UInt32,System.IntPtr,Comm.Utils.ProcessHelper.SECURITY_IMPERSONATION_LEVEL,Comm.Utils.ProcessHelper.TOKEN_TYPE,System.IntPtr@)">
             <summary>
             创建一个主令牌或模拟令牌 当您完成使用新的令牌，调用CloseHandle函数关闭令牌处理。
             </summary>
             <param name="existingToken">一个访问令牌的句柄打开TOKEN_DUPLICATE访问</param>
             <param name="desiredAccess">指定新令牌的请求的访问权限。 DuplicateTokenEx功能比较现有令牌的随机访问控制列表（DACL），以确定哪些权利授予或拒绝请求的访问权限。要求现有令牌相同的访问权限，指定零。
             要求所有访问权限，有效的来电，指定MAXIMUM_ALLOWED。访问令牌的访问权限列表，请参阅访问令牌对象的访问权限。</param>
             <param name="tokenAttributes">一个一个SECURITY_ATTRIBUTES结构，指定为新的令牌一个安全描述符，并决定是否子进程可以继承令牌的指针。如果lpTokenAttributes是NULL，令牌获取默认的安全描述符的句柄不能被继承。
             如果安全描述符包含一个系统访问控制列表（SACL），令牌获得ACCESS_SYSTEM_SECURITY访问权，即使它不是在dwDesiredAccess要求。要设置新令牌的安全描述符中的所有者，调用者的进程令牌必须有SE_RESTORE_NAME权限集。</param>
             <param name="impersonationLevel">指定一个SECURITY_IMPERSONATION_LEVEL枚举，表示新的令牌的模拟级别值。</param>
             <param name="tokenType">指定从TOKEN_TYPE枚举下列值之一。</param>
             <param name="newToken">接收新的令牌句柄变量的指针。当您完成使用新的令牌，调用CloseHandle函数关闭令牌处理。</param>
             <returns>如果函数调用成功，函数返回一个非零值。如果函数失败，返回零。为了获得更多的错误信息，调用GetLastError。</returns>
             <remarks>DuplicateTokenEx功能允许您创建一个主令牌，您可以使用CreateProcessAsUser函数。这使得服务器应用程序，模拟客户端创建一个过程，
             有客户端的安全上下文。请注意，DuplicateToken功能可以创建模拟令牌，这是不CreateProcessAsUser有效。
            以下是一个典型的场景使用DuplicateTokenEx创建一个主令牌。服务器应用程序创建一个线程，调用模拟的功能，
            如ImpersonateNamedPipeClient，之一，以模拟一个客户端。模拟线程，然后调用OpenThreadToken的函数来获得其自己的道理，
            这是一个模拟客户端的安全上下文令牌。线程指定一个调用DuplicateTokenEx模拟令牌，指定TokenPrimary标志。
            DuplicateTokenEx函数创建一个主令牌，客户端的安全上下文。
            需求
            客户端
            需要Windows Vista中，Windows XP中，Windows 2000专业版，或Windows NT Workstation 4.0。
            服务器
            需要的Windows Server 2008，Windows Server 2003中，Windows 2000 Server的，或Windows NT Server 4.0。
            </remarks>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.CreateEnvironmentBlock(System.IntPtr@,System.IntPtr,System.Boolean)">
            <summary>
            检索指定用户的环境变量。然后可以调用CreateProcessAsUser函数
            </summary>
            <param name="lpEnvironment">这个函数返回时，收到一个新的环境块的指针。环境块是一个空结尾的Unicode字符串的数组。该列表两个空值（\ 0 \ 0）结束。</param>
            <param name="hToken">用户令牌，从LogonUser函数返回。如果这是一个主令牌，令牌必须有TOKEN_QUERY TOKEN_DUPLICATE访问。如果标记是一个模拟令牌，它必须有TOKEN_QUERY访问。对于更多信息，请访问令牌对象的访问权限。如果这个参数是NULL，返回的环境块只包含系统变量。</param>
            <param name="bInherit">指定是否继承当前进程的环境。如果这个值是TRUE，进程继承当前进程的环境。如果该值为false，过程中不继承当前进程的环境。返回值</param>
            <returns>如果成功，则为true，否则为false。为了获得更多的错误信息，调用GetLastError。</returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.DestroyEnvironmentBlock(System.IntPtr)">
            <summary>
            释放由CreateEnvironmentBlock函数创建的环境变量。
            </summary>
            <param name="lpEnvironment">CreateEnvironmentBlock创建环境块的指针。环境块是一个空结尾的Unicode字符串的数组。该列表两个空值（\ 0 \ 0）结束。</param>
            <returns>如果成功，则为true，否则为false。为了获得更多的错误信息，调用GetLastError。</returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.CreateProcessAsUser(System.IntPtr,System.String,System.String,Comm.Utils.ProcessHelper.SECURITY_ATTRIBUTES@,Comm.Utils.ProcessHelper.SECURITY_ATTRIBUTES@,System.Boolean,System.UInt32,System.IntPtr,System.String,Comm.Utils.ProcessHelper.STARTUPINFO@,Comm.Utils.ProcessHelper.PROCESS_INFORMATION@)">
             <summary>
             创建一个新的进程和它的主线程。新的进程运行在指定的令牌代表的用户的安全上下文。
             </summary>
             <param name="token">代表用户的主令牌的句柄。句柄必须TOKEN_QUERY，TOKEN_DUPLICATE，和TOKEN_ASSIGN_PRIMARY访问权限。对于更多信息，请访问令牌对象的访问权限。令牌代表的用户必须具有读取和执行lpApplicationName或lpCommandLine参数指定的应用程序的访问。
            为了得到一个表示指定用户的主令牌，调用LogonUser函数。另外，您可以调用DuplicateTokenEx的函数模拟令牌转换成一个主令牌。这使得服务器应用程序，模拟客户端创建一个过程，有客户端的安全上下文。
            终端服务：进程是运行在令牌中指定的会议。默认情况下，这是相同的会话调用LogonUser的。更改会话，使用SetTokenInformation功能。  </param>
             <param name="applicationName">要执行的模块的名称。此模块可基于Windows的应用程序。它可以是一些其它类型的模块（例如，MS - DOS或OS / 2），如果是本地计算机上的进行适当的子系统。
            该字符串可以指定完整的路径和文件的模块的名称来执行，也可以指定部分名称。在部分名称的情况下，该函数使用当前驱动器和当前目录中，以完成规范。该功能将不能使用的搜索路径。如果文件名不包含扩展名。exe是假设。因此，如果文件扩展名是。COM，这个参数必须包括。com扩展名。</param>
             <param name="commandLine">要执行的命令行。此字符串的最大长度为32K字符。如果lpApplicationName为NULL，lpCommandLine模块名称部分是有限的MAX_PATH个字符。</param>
             <param name="processAttributes"></param>
             <param name="threadAttributes"></param>
             <param name="inheritHandles"></param>
             <param name="creationFlags">标志控制的优先级和创造的过程。对于一个值的列表，请参见进程创建标志。</param>
             <param name="environment">一个新的进程环境块的指针。如果这个参数是NULL，新进程使用调用进程的环境。</param>
             <param name="currentDirectory">该进程的当前目录的完整路径。该字符串也可以指定一个UNC路径。</param>
             <param name="startupInfo">到一个STARTUPINFO或STARTUPINFOEX结构的指针。
            用户必须到指定的窗口站和桌面有充分的机会。如果你想的过程是互动的，指定winsta0 \默认。如果lpDesktop成员为NULL，则新进程继承它的父进程的桌面和窗口站。如果这个成员是一个空字符串“”，新的进程连接到窗口站，使用过程连接到窗口站规则。
            要设置扩展属性，使用STARTUPINFOEX的结构，并在dwCreationFlags参数指定EXTENDED_STARTUPINFO_PRESENT。</param>
             <param name="processInformation">收到关于新的进程的标识信息的一个PROCESS_INFORMATION结构的指针。</param>
             <returns></returns>
        </member>
        <member name="M:Comm.Utils.ProcessHelper.WTSGetActiveConsoleSessionId">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.ProcessHelper.WTS_SESSION_INFO">
            <summary>
            系统令牌信息结构体
            </summary>
            <remarks>包含一个终端服务器上的客户端会话的信息</remarks>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_SESSION_INFO.SessionID">
            <summary>
            会话的会话标识符
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_SESSION_INFO.pWinStationName">
            <summary>
            指向一个空结束的字符串，其中包含了本次会话的WinStation中的名称
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_SESSION_INFO.State">
             <summary>
            表示会话的当前连接状态的值
             </summary>
        </member>
        <member name="T:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS">
            <summary>
            表明终端服务会话的连接状态
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSActive">
            <summary>
            用户登录后，活动的
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSConnected">
            <summary>
            是连接到客户端
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSConnectQuery">
            <summary>
            是在连接到客户端的过程
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSDisconnected">
            <summary>
            WinStation中是积极的，但客户端断开
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSIdle">
            <summary>
            正在等待客户端连接
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSListen">
            <summary>
            监听一个连接。一位听众会等待新的客户端连接请求。一个监听会话没有用户登录。一位听众会话不能复位，阴影，或改为一个普通的客户端会话
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSReset">
            <summary>
            复位
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSDown">
            <summary>
            由于一个错误
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_CONNECTSTATE_CLASS.WTSInit">
            <summary>
            初始化
            </summary>
        </member>
        <member name="T:Comm.Utils.ProcessHelper.WTS_INFO_CLASS">
            <summary>
            枚举类型包含值表示会话信息检索在调用的WTSQuerySessionInformation函数的类型
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSInitialProgram">
            <summary>
            其中包含的初步方案的名称终端服务时运行用户登录
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSApplicationName">
            <summary>
            其中包含的会话正在运行的应用程序，公布的名称。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSWorkingDirectory">
            <summary>
            其中包含发射的初步方案时使用的默认目录。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSOEMId">
            <summary>
            This值不被使用。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSSessionId">
            <summary>
            ULONG值，其中包含会话标识符。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSUserName">
            <summary>
            其中包含了与会话相关联的用户的名称。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSWinStationName">
            <summary>
            其中包含了终端服务会话的名称。
            注意：尽管它的名字，指定这种类型的不返回窗口站的名称。相反，它返回
            终端服务会话的名称。每个终端服务会话与一个交互式窗口
             站。目前，因为支持的唯一的窗口交互式窗口站的站名，
              “WinSta0”，每届会议是与自己的“WinSta0”窗口站。欲了解更多信息，请参阅
              窗口站。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSDomainName">
            <summary>
            其中包含上登录的用户所属的域的名称。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSConnectState">
            <summary>
            会话的当前连接状态。欲了解更多信息，请参阅      WTS_CONNECTSTATE_CLASS。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientBuildNumber">
            <summary>
            ULONG值，其中包含的客户端建立。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientName">
            <summary>
            其中包含了客户端的名称。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientDirectory">
            <summary>
            其中包含在客户端的安装目录。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientProductId">
            <summary>
            T客户特定的产品标识。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientHardwareId">
            <summary>
            其中包含客户端特定的硬件标识符。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientAddress">
            <summary>
            网络类型和客户端的网络地址。欲了解更多信息，请参阅  WTS_CLIENT_ADDRESS。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientDisplay">
            <summary>
            客户端的显示分辨率。欲了解更多信息，请参阅   WTS_CLIENT_DISPLAY。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientProtocolType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSIdleTime">
            <summary>
            值不被使用。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSLogonTime">
            <summary>
            值不被使用。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSIncomingBytes">
            <summary>
            值不被使用。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSOutgoingBytes">
            <summary>
            值不被使用。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSIncomingFrames">
            <summary>
            值不被使用。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSOutgoingFrames">
            <summary>
            值不被使用。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSClientInfo">
             <summary>
              WTSClientInfoWTSClientInfo
              有关终端服务客户端。欲了解更多信息，请参阅WTSCLIENT。
            Windows Vista中，Windows Server 2003的，Windows XP中，Windows 2000中：这个值是不支持。此值是Windows Server 2008和Windows Vista SP1的支持。
             </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.WTS_INFO_CLASS.WTSSessionInfo">
             <summary>
             大约在终端服务器上的客户端会话。欲了解更多信息，请参阅WTSINFO“。
            Windows Vista中，Windows Server 2003的，Windows XP中，Windows 2000中：这个值是不支持。此值是Windows Server 2008和Windows Vista SP1的支持。
             </summary>
        </member>
        <member name="T:Comm.Utils.ProcessHelper.SECURITY_ATTRIBUTES">
            <summary>
            安全属性结构体
            </summary>
        </member>
        <member name="T:Comm.Utils.ProcessHelper.SECURITY_IMPERSONATION_LEVEL">
            <summary>
            安全模拟级别结构体
            </summary>
        </member>
        <member name="T:Comm.Utils.ProcessHelper.TOKEN_TYPE">
            <summary>
            令牌类型
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.TOKEN_TYPE.TokenPrimary">
            <summary>
            新标记是在CreateProcessAsUser函数，您可以使用一个主令牌。
            </summary>
        </member>
        <member name="F:Comm.Utils.ProcessHelper.TOKEN_TYPE.TokenImpersonation">
            <summary>
            新的令牌是一个模拟令牌。
            </summary>
        </member>
        <member name="T:Comm.Utils.ProcessHelper.STARTUPINFO">
            <summary>
            启动信息结构体
            </summary>
        </member>
        <member name="T:Comm.Utils.ProcessHelper.PROCESS_INFORMATION">
            <summary>
            进程信息结构体
            </summary>
        </member>
        <member name="T:Comm.Utils.SysLockWaitConst">
            <summary>
            系统锁定等待常量定义
            </summary>
        </member>
        <member name="F:Comm.Utils.SysLockWaitConst.ReadLockWaitTime">
            <summary>
            读锁定等待时间
            </summary>
        </member>
        <member name="F:Comm.Utils.SysLockWaitConst.WriteLockWaitTime">
            <summary>
            写锁定等待时间
            </summary>
        </member>
        <member name="T:Comm.Utils.XORCRC16">
            <summary>  
            校验值计算  
            支持按位异或校验（XOR),支持CRC16查表法校验,支持CRC16带多项式计算法校验  
            </summary>  
        </member>
        <member name="M:Comm.Utils.XORCRC16.GetXOR(System.Byte[])">
            <summary>  
            计算按位异或校验和（返回校验和值）  
            </summary>  
            <param name="cmd">命令数组</param>  
            <returns>校验和值</returns>  
        </member>
        <member name="M:Comm.Utils.XORCRC16.GetXORFull(System.Byte[])">
            <summary>  
            计算按位异或校验和（返回包含校验和的完整命令数组）  
            </summary>  
            <param name="cmd">命令数组</param>  
            <returns>包含校验和的完整命令数组</returns>  
        </member>
        <member name="M:Comm.Utils.XORCRC16.GetCRC16(System.Byte[],System.Boolean)">
            <summary>  
            计算CRC16循环校验码  
            </summary>  
            <param name="cmd">命令数组</param>  
            <param name="isHighBefore">高位是否在前</param>  
            <returns>高低位校验码</returns>  
        </member>
        <member name="M:Comm.Utils.XORCRC16.GetCRC16Full(System.Byte[],System.Boolean)">
            <summary>  
            计算CRC16循环校验码（返回包含校验码的完整命令数组）  
            </summary>  
            <param name="cmd">命令数组</param>  
            <param name="isHighBefore">高位是否在前</param>  
            <returns></returns>  
        </member>
        <member name="M:Comm.Utils.XORCRC16.CheckCRC(System.Byte[],System.Boolean)">
            <summary>
            验证校验码是否正确（传入的命令数组最后两位为要验证的校验码）
            </summary>
            <param name="cmd">命令数组（最后两位为校验码）</param>
            <param name="isHighBefore">高位是否在前</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.XORCRC16.GetCRC16ByPoly(System.Byte[],System.UInt16,System.Boolean)">
            <summary>  
            多项式参数 CRC16计算  
            </summary>  
            <param name="cmd">命令</param>  
            <param name="poly">多项式</param>  
            <param name="isHighBefore">高位是否在前</param>  
            <returns></returns>  
        </member>
        <member name="M:Comm.Utils.XORCRC16.GetCRC16ByPolyFull(System.Byte[],System.UInt16,System.Boolean)">
            <summary>  
            多项式参数 CRC16计算  
            </summary>  
            <param name="cmd">命令</param>  
            <param name="poly">多项式</param>  
            <param name="isHighBefore">高位是否在前</param>  
            <returns></returns>  
        </member>
        <member name="M:Comm.Utils.XORCRC16.CRC(System.UInt16,System.Byte)">
            <summary>
            CRC
            </summary>
            <param name="crc"></param>
            <param name="bye"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.XORCRC16.CalcCRC(System.Byte[])">
            <summary>
            CalcCRC
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.AES">
            <summary>
            高级加密标准 (AES) 算法（又称为 Rijndael）
            </summary>
        </member>
        <member name="M:Comm.Utils.AES.Encrypt(System.String,System.String)">
            <summary>
            加密
            </summary>
            <param name="plainText">待加密的文本</param>
            <param name="cipherkey">密钥</param>
            <returns>返回与此实例等效的加密文本</returns>
        </member>
        <member name="M:Comm.Utils.AES.EncryptBuffer(System.Byte[],System.String)">
            <summary>
            加密
            </summary>
            <param name="plainText">待加密的字节</param>
            <param name="cipherkey">密钥</param>
            <returns>返回与此实例等效的加密字节</returns>
        </member>
        <member name="M:Comm.Utils.AES.Decrypt(System.String,System.String)">
            <summary>
            解密
            </summary>
            <param name="cipherText">待解密的文本</param>
            <param name="cipherkey">密钥</param>
            <returns>返回与此实例等效的解密文本</returns>
        </member>
        <member name="M:Comm.Utils.AES.DecryptBuffer(System.Byte[],System.String)">
            <summary>
            解密
            </summary>
            <param name="cipherText">待解密的字节</param>
            <param name="cipherkey">密钥</param>
            <returns>返回与此实例等效的解密字节</returns>
        </member>
        <member name="T:Comm.Utils.ApplicationSettings">
            <summary>
            对ConfigurationSettings.AppSettings操作类
            </summary>
        </member>
        <member name="M:Comm.Utils.ApplicationSettings.Get(System.String)">
            <summary>
            获取web.config的配置项
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ApplicationSettings.GetList(System.String)">
            <summary>
            获取web.config的配置项
            </summary>
            <param name="containsKey">包含的关键词</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ApplicationSettings.Set(System.String,System.String)">
            <summary>
            设置web.config的配置项
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.BaseAttribute">
            <summary>
            所有描述属性的基类
            </summary>
        </member>
        <member name="P:Comm.Utils.BaseAttribute.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="M:Comm.Utils.BaseAttribute.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.BaseAttribute.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="description">该属性的描述</param>
        </member>
        <member name="M:Comm.Utils.BaseAttribute.GetAttributeDesc(System.Type)">
            <summary>
            获取枚举的描述文本
            </summary>
            <param name="enumType">枚举类型</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.LibExceptionBase">
            <summary>
            异常基类
            </summary>
        </member>
        <member name="M:Comm.Utils.LibExceptionBase.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.LibExceptionBase.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Comm.Utils.LibExceptionBase.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.LibExceptionBase.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            序列化构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:Comm.Utils.LibExceptionBase.StackTrace">
            <summary>
            获取堆栈跟踪信息
            </summary>
        </member>
        <member name="P:Comm.Utils.LibExceptionBase.StackTraceEx">
            <summary>
            扩展的堆栈跟踪信息
            </summary>
        </member>
        <member name="T:Comm.Utils.LibException">
            <summary>
            Lib 异常基类
            </summary>
        </member>
        <member name="M:Comm.Utils.LibException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.LibException.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Comm.Utils.LibException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.LibException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            序列化构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Comm.Utils.LibException.GetOriginalInnerException(System.Exception)">
            <summary>
            获取最原始的异常类，并将最外层异常转换为InnerException，这样方便错误信息的显示
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.LibAlert">
            <summary>
            Lib警告基类
            </summary>
        </member>
        <member name="M:Comm.Utils.LibAlert.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Comm.Utils.LibAlert.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.LibAlert.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            序列化构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Comm.Utils.CWHEncryptNet">
            <summary>
            异或对称加密
            </summary>
        </member>
        <member name="M:Comm.Utils.CWHEncryptNet.XorCrevasse(System.String)">
            <summary>
            解密
            </summary>
            <param name="encrypData"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CWHEncryptNet.XorEncrypt(System.String)">
            <summary>
            加密
            </summary>
            <param name="sourceData"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.DES">
            <summary>
            数据加密标准 (DES)是一种加密算法
            </summary>
        </member>
        <member name="M:Comm.Utils.DES.Decrypt(System.String,System.String)">
            <summary>
             DES解密
            </summary>
            <param name="decryptString">待解密的字符串</param>
            <param name="decryptKey">解密密钥,要求为8位,和加密密钥相同</param>
            <returns>解密成功返回解密后的字符串,失败返源串</returns>
        </member>
        <member name="M:Comm.Utils.DES.Encrypt(System.String,System.String)">
            <summary>
            DES加密
            </summary>
            <param name="encryptString">待加密的字符串</param>
            <param name="encryptKey">加密密钥,要求为8位</param>
            <returns>加密成功返回加密后的字符串,失败返回源串</returns>
        </member>
        <member name="T:Comm.Utils.EnumAttribute">
            <summary>
            枚举的字段属性
            </summary>
        </member>
        <member name="P:Comm.Utils.EnumAttribute.FieldInfo">
            <summary>
            FieldInfo
            </summary>
        </member>
        <member name="P:Comm.Utils.EnumAttribute.FieldName">
            <summary>
            字段名
            </summary>
        </member>
        <member name="P:Comm.Utils.EnumAttribute.FieldValue">
            <summary>
            字段值
            </summary>
        </member>
        <member name="P:Comm.Utils.EnumAttribute.Rank">
            <summary>
            等级
            </summary>
        </member>
        <member name="M:Comm.Utils.EnumAttribute.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="description">描述</param>
        </member>
        <member name="M:Comm.Utils.EnumAttribute.#ctor(System.String,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="description">描述</param>
            <param name="Rank">等级</param>
        </member>
        <member name="M:Comm.Utils.EnumAttribute.ExistsEnumValue(System.Type,System.Int32)">
            <summary>
            是否存在枚举值
            </summary>
            <param name="enumType">枚举类型</param>
            <param name="enumValue">枚举值</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.EnumAttribute.GetEnumDesc(System.Object)">
            <summary>
            获得指定枚举类型中，指定值的描述文本
            </summary>
            <param name="enumValue">枚举值，不要作任何类型转换</param>
            <returns>描述字符串</returns>
        </member>
        <member name="M:Comm.Utils.EnumAttribute.GetAttribute(System.Object)">
            <summary>
            获取枚举值的属性对象
            </summary>
            <param name="enumValue">枚举值</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.EnumAttribute.GetAttributes(System.Type)">
            <summary>
            获取枚举类型定义的所有文本，按定义的顺序返回
            </summary>
            <param name="enumType">枚举类型</param>
            <returns>所有定义的文本</returns>
        </member>
        <member name="M:Comm.Utils.EnumAttribute.GetAttributes(System.Type,Comm.Utils.SortType)">
            <summary>
            获取枚举类型定义的所有文本
            </summary>
            <param name="enumType">枚举类型</param>
            <param name="sortType">排序类型</param>
            <returns>枚举描述集合</returns>
        </member>
        <member name="T:Comm.Utils.ExceptionHelper">
            <summary>
            Provides helper methods for raising exceptions.
            </summary>
            <remarks>
            <para>
            The <c>ExceptionHelper</c> class provides a centralised mechanism for throwing exceptions. This helps to keep exception
            messages and types consistent.
            </para>
            <para>
            Exception information is stored in an embedded resource called <c>ExceptionHelper.xml</c>, which must reside in the
            <c>Properties</c> namespace for the calling assembly. For example, if the root namespace for an assembly is
            <c>Company.Product</c> then the exception information must be stored in a resource called
            <c>Company.Product.Properties.ExceptionHelper.xml</c>
            </para>
            <para>
            The format for the exception information XML includes a grouping mechanism such that exception keys are scoped to the
            type throwing the exception. Thus, different types can use the same exception key because they have different scopes in
            the XML structure. An example of the format for the exception XML can be seen below.
            </para>
            <note type="implementation">
            This class is designed to be efficient in the common case (ie. no exception thrown) but is quite inefficient if an
            exception is actually thrown. This is not considered a problem, however, since an exception usually indicates that
            execution cannot reliably continue.
            </note>
            </remarks>
            <example>
            The following example shows how an exception can be conditionally thrown:
            <code>
            ExceptionHelper.ThrowIf(foo == null, "myKey", "hello");
            </code>
            Assuming this code resides in a class called <c>Foo.Bar</c>, the XML configuration might look like this:
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?> 
            
            <exceptionHelper>
            	<exceptionGroup type="Foo.Bar">
            		<exception key="myKey" type="System.NullReferenceException">
            			Foo is null but I'll say '{0}' anyway.
            		</exception>
            	</exceptionGroup>
            </exceptionHelper>
            ]]>
            </code>
            With this configuration, a <see cref="T:System.NullReferenceException"/> will be thrown if <c>foo</c> is <see langword="null"/>.
            The exception message will be "Foo is null but I'll say 'hello' anyway.".
            </example>
        </member>
        <member name="F:Comm.Utils.ExceptionHelper._exceptionInfos">
            <summary>
            Caches exception information for each participating assembly.
            </summary>
        </member>
        <member name="F:Comm.Utils.ExceptionHelper._exceptionInfosLock">
            <summary>
            Synchronizes access to <see cref="F:Comm.Utils.ExceptionHelper._exceptionInfos"/>.
            </summary>
        </member>
        <member name="F:Comm.Utils.ExceptionHelper._typeAttributeName">
            <summary>
            The name of the attribute that holds the exception type.
            </summary>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.GetExceptionInfo(System.Reflection.Assembly)">
            <summary>
            Gets exception information for a specified assembly.
            </summary>
            <param name="assembly">
            The assembly for which exception information should be retrieved.
            </param>0
            <returns>
            The exception information.
            </returns>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrowIf(System.Boolean,System.String,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrowIf(System.Boolean,System.String,System.Exception,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrowIf(System.Boolean,System.String,System.Object[],System.Exception)">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrowIf(System.Boolean,System.String,System.Object[],System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrowIf(System.Boolean,System.String,System.Object[],System.Exception,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrow(System.String,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrow(System.String,System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrow(System.String,System.Object[],System.Exception)">
            <summary>
            Throws an exception.
            </summary>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrow(System.String,System.Object[],System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.KeyThrow(System.String,System.Object[],System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="exceptionKey">
            The exception key.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf``1(System.Boolean,System.String,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="message">
            the exception messagte
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf``1(System.Boolean,System.String,System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="message">
            the exception messagte
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf``1(System.Boolean,System.Object[],System.String,System.Exception)">
            <summary>
            Throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="message">
            </param>
            the exception messagte
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf``1(System.Boolean,System.Object[],System.String,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="message">
            the exception messagte
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf``1(System.Boolean,System.Object[],System.String,System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="message">
            the exception messagte
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw``1(System.String,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="message">
            the exception messagte
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw``1(System.String,System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="message">
            the exception messagte
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw``1(System.Object[],System.String,System.Exception)">
            <summary>
            Throws an exception.
            </summary>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="message">
            </param>
            the exception messagte
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw``1(System.Object[],System.String,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="message">
            the exception messagte
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw``1(System.Object[],System.String,System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="message">
            the exception messagte
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf(System.Boolean,System.String,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="message">
            The exception message.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf(System.Boolean,System.String,System.Exception,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="message">
            The exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf(System.Boolean,System.String,System.Object[],System.Exception)">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="message">
            The exception message.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf(System.Boolean,System.String,System.Object[],System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="message">
            The exception message.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.ThrowIf(System.Boolean,System.String,System.Object[],System.Exception,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="message">
            The exception message.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw(System.String,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="message">
            The exception message.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw(System.String,System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="message">
            The exception message.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw(System.String,System.Object[],System.Exception)">
            <summary>
            Throws an exception.
            </summary>
            <param name="message">
            The exception message.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw(System.String,System.Object[],System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="message">
            The exception message.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.Throw(System.String,System.Object[],System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="message">
            The exception message.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrowIf(System.Boolean,System.Object,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrowIf(System.Boolean,System.Object,System.Exception,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrowIf(System.Boolean,System.Object,System.Object[],System.Exception)">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrowIf(System.Boolean,System.Object,System.Object[],System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrowIf(System.Boolean,System.Object,System.Object[],System.Exception,System.Object[])">
            <summary>
            Conditionally throws an exception.
            </summary>
            <param name="condition">
            The condition.
            </param>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrow(System.Object,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrow(System.Object,System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrow(System.Object,System.Object[],System.Exception)">
            <summary>
            Throws an exception.
            </summary>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrow(System.Object,System.Object[],System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
        </member>
        <member name="M:Comm.Utils.ExceptionHelper.EnumResThrow(System.Object,System.Object[],System.Exception,System.Object[])">
            <summary>
            Throws an exception.
            </summary>
            <param name="resxEnumId">
            The exception resxEnumId.
            </param>
            <param name="constructorArgs">
            Additional arguments for the exception constructor.
            </param>
            <param name="messageArgs">
            Arguments to the exception message.
            </param>
            <param name="innerException">
            The inner exception - the cause of the new exception.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If any problem occurs locating the details of the exception to throw, or in constructing the exception to throw.
            </exception>
            <exception cref="T:System.Exception">
            This method always throws an exception. The exact type of the exception depends on the configuration.
            </exception>
        </member>
        <member name="T:Comm.Utils.FSOCategory">
            <summary>
            文件系统的处理对象枚举
            </summary>
        </member>
        <member name="F:Comm.Utils.FSOCategory.Folder">
            <summary>
            文件夹
            </summary>
        </member>
        <member name="F:Comm.Utils.FSOCategory.File">
            <summary>
            文件
            </summary>
        </member>
        <member name="F:Comm.Utils.FSOCategory.All">
            <summary>
            全部
            </summary>
        </member>
        <member name="T:Comm.Utils.FileEntity">
            <summary>
            文件夹实体类
            </summary>
        </member>
        <member name="P:Comm.Utils.FileEntity.ContentType">
            <summary>
            内容类型
            </summary>
        </member>
        <member name="P:Comm.Utils.FileEntity.FsoType">
            <summary>
            文件类型（文件夹、文件）
            </summary>
        </member>
        <member name="P:Comm.Utils.FileEntity.FullName">
            <summary>
            文件名
            </summary>
        </member>
        <member name="P:Comm.Utils.FileEntity.LastWriteTime">
            <summary>
            最后写入时间
            </summary>
        </member>
        <member name="P:Comm.Utils.FileEntity.Length">
            <summary>
            长度
            </summary>
        </member>
        <member name="P:Comm.Utils.FileEntity.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="P:Comm.Utils.FileEntity.Path">
            <summary>
            路径
            </summary>
        </member>
        <member name="P:Comm.Utils.FileEntity.Type">
            <summary>
            类型
            </summary>
        </member>
        <member name="T:Comm.Utils.FileHelper">
            <summary>
            文件/目录的处理类
            </summary>
        </member>
        <member name="M:Comm.Utils.FileHelper.CopyDirectoryInfo(System.IO.DirectoryInfo,System.String,System.String)">
            <summary>
            拷贝文件信息
            </summary>
            <param name="dInfo"></param>
            <param name="srcDir"></param>
            <param name="desDir"></param>
        </member>
        <member name="M:Comm.Utils.FileHelper.DirInfo(System.IO.DirectoryInfo)">
            <summary>
            目录信息
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.CopyDirectories(System.String,System.String)">
            <summary>
            复制文件夹中的所有内容及其子目录所有文件
            </summary>
            <param name="srcDir">源文件夹及其路径</param>
            <param name="desDir">目标文件夹及其路径</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.CopyFile(System.String,System.String)">
            <summary>
            复制文件，如果目标文件已经存在则覆盖掉
            </summary>
            <param name="srcFile">源文件</param>
            <param name="desFile">目标文件</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.CopyFileStream(System.String,System.String)">
            <summary>
            以流的形式复制拷贝文件
            </summary>
            <param name="srcFile">源文件</param>
            <param name="desFile">目标文件</param>
            <returns>返回成功 true,失败 false</returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.Create(System.String,Comm.Utils.FSOCategory)">
            <summary>
            新建文件或文件夹
            </summary>
            <param name="file">文件或文件夹及其路径</param>
            <param name="method">新建方式</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.Delete(System.String,Comm.Utils.FSOCategory)">
            <summary>
            删除文件或文件夹
            </summary>
            <param name="file">文件或文件夹及其路径</param>
            <param name="method">删除方式</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.Exists(System.String,Comm.Utils.FSOCategory)">
            <summary>
            判断文件或文件夹是否存在，存在为 true，否则为 false;
            </summary>
            <param name="file">指定文件及其路径</param>
            <param name="method">判断方式</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.Move(System.String,System.String,Comm.Utils.FSOCategory)">
            <summary>
            移动文件或文件夹
            </summary>
            <param name="srcFile">原始文件或文件夹</param>
            <param name="desFile">目标文件或文件夹</param>
            <param name="method">移动方式</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetDirectories(System.String)">
            <summary>
            获取子目录的名称
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetDirectories(System.String,System.String)">
            <summary>
            获取子目录的名称
            </summary>
            <param name="directory"></param>
            <param name="searchPattern"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetDirectories(System.String,System.String,System.IO.SearchOption)">
            <summary>
            获取子目录的名称
            </summary>
            <param name="directory"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetFiles(System.String)">
            <summary>
            获取指定目录文件名称
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetFiles(System.String,System.String)">
            <summary>
            获取指定目录文件名称
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            获取指定目录文件名称
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetDirectoryName(System.String)">
            <summary>
            获取文件所在的目录名
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetFileName(System.String)">
            <summary>
            获取文件名和扩展名
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetFileNameWithoutExtension(System.String)">
            <summary>
            获取文件名
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetDirectoryFilesList(System.String,Comm.Utils.FSOCategory)">
            <summary>
            获取指定目录的目录信息
            </summary>
            <param name="directory">目录</param>
            <param name="method">获取方式</param>
            <returns>返回目录文件列表的DataTable对象</returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetDirectoryInfo(System.String)">
            <summary>
            获取指定文件目录信息，如：文件夹大小，文件夹数，文件数
            </summary>
            <param name="directory">指定文件夹路径</param>
            <returns>返回文件目录信息数组</returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetDirectoryList(System.IO.DirectoryInfo,Comm.Utils.FSOCategory)">
            <summary>
            获取指定目录下的所有目录及其文件信息
            </summary>
            <param name="directoryInfo">目录</param>
            <param name="method">获取方式</param>
            <returns>返回目录文件列表的DataTable对象</returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.GetDirectoryList(System.String,Comm.Utils.FSOCategory)">
            <summary>
            获取指定目录下的所有目录及其文件信息
            </summary>
            <param name="directory"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.Merge(System.Data.DataTable,System.Data.DataTable)">
            <summary>
            将两个结构一样的 DataTable 组合成一个 DataTable
            </summary>
            <param name="parent"></param>
            <param name="child"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.ReadFile(System.String)">
            <summary>
            以文件流的形式读取指定文件的内容,默认(UTF8)编码
            </summary>
            <param name="file">指定的文件及其完全路径</param>
            <returns>返回文件内容</returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.ReadFile(System.String,System.Text.Encoding)">
            <summary>
            以文件流的形式读取指定文件的内容
            </summary>
            <param name="file">指定的文件及其完全路径</param>
            <param name="encoding">文件编码</param>
            <returns>返回文件内容</returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.ReadFileReturnBytes(System.String)">
            <summary>
            以字节数组的形式读取指定的文件内容
            </summary>
            <param name="filePath">指定文件及其完全路径</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.WriteBuffToFile(System.Byte[],System.String)">
            <summary>
            写字节数组到文件
            </summary>
            <param name="buff"></param>
            <param name="filePath"></param>
        </member>
        <member name="M:Comm.Utils.FileHelper.WriteBuffToFile(System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            写字节数组到文件
            </summary>
            <param name="buff"></param>
            <param name="offset">开始位置</param>
            <param name="len"></param>
            <param name="filePath"></param>
        </member>
        <member name="M:Comm.Utils.FileHelper.WriteFile(System.String,System.String)">
            <summary>
            以文件流的形式将内容写入到指定文件中（如果该文件或文件夹不存在则创建）文件编码 缺省 UTF-8
            </summary>
            <param name="file">文件名和指定路径</param>
            <param name="fileContent">文件内容</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.WriteFile(System.String,System.String,System.Text.Encoding)">
            <summary>
             以文件流的形式将内容写入到指定文件中（如果该文件或文件夹不存在则创建）
              默认是带签名的 UTF8
            </summary>
            <param name="file">文件名和指定路径</param>
            <param name="fileContent">文件内容</param>
            <param name="encoding">文件编码 缺省 UTF-8</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.WriteFile(System.String,System.String,System.Boolean)">
            <summary>
            以文件流的形式将内容写入到指定文件中（如果该文件或文件夹不存在则创建,存在则追加）
               不带签名的 UTF8 编码，生成 shtml 文件必用
            </summary>
            <param name="file">文件名和指定路径</param>
            <param name="fileContent">文件内容</param>
            <param name="append">是否追加指定内容到该文件中</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.WriteFile(System.String,System.String,System.Boolean,System.Text.Encoding)">
            <summary>
            以文件流的形式将内容写入到指定文件中（如果该文件或文件夹不存在则创建,存在则追加）
            </summary>
            <param name="file">文件名和指定路径</param>
            <param name="fileContent">文件内容</param>
            <param name="append">是否追加指定内容到该文件中</param>
            <param name="encoding">文件编码 缺省 UTF-8</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.WriteFile(System.String,System.String,System.String)">
            <summary>
            以指定的ContentType输出指定文件
            </summary>
            <param name="filepath">文件路径</param>
            <param name="filename">输出的文件名</param>
            <param name="filetype">将文件输出时设置的ContentType</param>
        </member>
        <member name="M:Comm.Utils.FileHelper.UploadFile``1(Comm.Utils.UploadReqEntityBase)">
            <summary>
            文件上传
            </summary>
            <param name="request">上传实体</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.UploadFile(Comm.Utils.UploadReqEntityBase)">
            <summary>
            文件上传
            </summary>
            <param name="request">上传实体</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.UploadFile(Comm.Utils.UploadImgReqEntity)">
            <summary>
            文件上传
            </summary>
            <param name="request">上传实体</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.FileHelper.ImageMakeWater(System.Drawing.Image,System.String,System.String,Comm.Utils.UploadWaterMarkPosition)">
            <summary>
            生成水印，可按左上、左下、右上、右下、居中生成文件，只对jpeg或jpg格式有效
            </summary>
            <param name="sourceImage">原图</param>
            <param name="waterMarkFile">水印图</param>
            <param name="saveFile">要保存的文件</param>
            <param name="position">位置：左上(1)、左下(2)、右上(3)、右下(4)、居中(5)</param>
            <returns>bool,是否成功</returns>
        </member>
        <member name="T:Comm.Utils.IniClass">
            <summary>
            操作ini文件
            </summary>
        </member>
        <member name="T:Comm.Utils.FrameworkVersion">
            <summary>
            Specifies the .NET Framework versions
            </summary>
        </member>
        <member name="F:Comm.Utils.FrameworkVersion.Fx10">
            <summary>
            .NET Framework 1.0
            </summary>
        </member>
        <member name="F:Comm.Utils.FrameworkVersion.Fx11">
            <summary>
            .NET Framework 1.1
            </summary>
        </member>
        <member name="F:Comm.Utils.FrameworkVersion.Fx20">
            <summary>
            .NET Framework 2.0
            </summary>
        </member>
        <member name="F:Comm.Utils.FrameworkVersion.Fx30">
            <summary>
            .NET Framework 3.0
            </summary>
        </member>
        <member name="F:Comm.Utils.FrameworkVersion.Fx35">
            <summary>
            .NET Framework 3.5 (Orcas)
            </summary>
        </member>
        <member name="F:Comm.Utils.FrameworkVersion.Fx40">
            <summary>
            .NET Framework 4.0
            </summary>
        </member>
        <member name="F:Comm.Utils.FrameworkVersion.Fx45">
            <summary>
            .NET Framework 4.5
            </summary>
        </member>
        <member name="T:Comm.Utils.FrameworkVersionDetection">
            <summary>
            Provides support for determining if a specific version of the .NET
            Framework runtime is installed and the service pack level for the
            runtime version.
            </summary>
        </member>
        <member name="M:Comm.Utils.FrameworkVersionDetection.IsInstalled(Comm.Utils.FrameworkVersion)">
            <summary>
            Determines if the specified .NET Framework version is installed
            on the local computer.
            </summary>
            <param name="frameworkVersion">One of the
            <see cref="T:Comm.Utils.FrameworkVersion"/> values.</param>
            <returns><see langword="true"/> if the specified .NET Framework
            version is installed; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Comm.Utils.FrameworkVersionDetection.IsInstalled(Comm.Utils.WindowsFoundationLibrary)">
            <summary>
            Determines if the specified .NET Framework Foundation Library is
            installed on the local computer.
            </summary>
            <param name="foundationLibrary">One of the
            <see cref="T:Comm.Utils.WindowsFoundationLibrary"/> values.</param>
            <returns><see langword="true"/> if the specified .NET Framework
            Foundation Library is installed; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Comm.Utils.FrameworkVersionDetection.GetServicePackLevel(Comm.Utils.FrameworkVersion)">
            <summary>
            Retrieves the service pack level for the specified .NET Framework
            version.
            </summary>
            <param name="frameworkVersion">One of the
            <see cref="T:Comm.Utils.FrameworkVersion"/> values.</param>
            <returns>An <see cref="T:System.Int32">integer</see> value representing
            the service pack level for the specified .NET Framework version. If
            the specified .NET Frameowrk version is not found, -1 is returned.
            </returns>
        </member>
        <member name="M:Comm.Utils.FrameworkVersionDetection.GetServicePackLevel(Comm.Utils.WindowsFoundationLibrary)">
            <summary>
            Retrieves the service pack level for the specified .NET Framework
            Foundation Library.
            </summary>
            <param name="foundationLibrary">One of the
            <see cref="T:Comm.Utils.WindowsFoundationLibrary"/> values.</param>
            <returns>An <see cref="T:System.Int32">integer</see> value representing
            the service pack level for the specified .NET Framework Foundation
            Library. If the specified .NET Frameowrk Foundation Library is not
            found, -1 is returned.
            </returns>
        </member>
        <member name="M:Comm.Utils.FrameworkVersionDetection.GetExactVersion(Comm.Utils.FrameworkVersion)">
            <summary>
            Retrieves the exact version number for the specified .NET Framework
            version.
            </summary>
            <param name="frameworkVersion">One of the
            <see cref="T:Comm.Utils.FrameworkVersion"/> values.</param>
            <returns>A <see cref="T:System.Version">version</see> representing
            the exact version number for the specified .NET Framework version.
            If the specified .NET Frameowrk version is not found, a 
            <see cref="T:System.Version"/> is returned that represents a 0.0.0.0 version
            number.
            </returns>
        </member>
        <member name="M:Comm.Utils.FrameworkVersionDetection.GetExactVersion(Comm.Utils.WindowsFoundationLibrary)">
            <summary>
            Retrieves the exact version number for the specified .NET Framework
            Foundation Library.
            </summary>
            <param name="foundationLibrary">One of the
            <see cref="T:Comm.Utils.WindowsFoundationLibrary"/> values.</param>
            <returns>A <see cref="T:System.Version">version</see> representing
            the exact version number for the specified .NET Framework Foundation
            Library. If the specified .NET Frameowrk Foundation Library is not
            found, a <see cref="T:System.Version"/> is returned that represents a 
            0.0.0.0 version number.
            </returns>
        </member>
        <member name="T:Comm.Utils.WindowsFoundationLibrary">
            <summary>
            Specifies the .NET 3.0 Windows Foundation Library
            </summary>
        </member>
        <member name="F:Comm.Utils.WindowsFoundationLibrary.WCF">
            <summary>
            Windows Communication Foundation
            </summary>
        </member>
        <member name="F:Comm.Utils.WindowsFoundationLibrary.WPF">
            <summary>
            Windows Presentation Foundation
            </summary>
        </member>
        <member name="F:Comm.Utils.WindowsFoundationLibrary.WF">
            <summary>
            Windows Workflow Foundation
            </summary>
        </member>
        <member name="F:Comm.Utils.WindowsFoundationLibrary.CardSpace">
            <summary>
            Windows CardSpace
            </summary>
        </member>
        <member name="T:Comm.Utils.Result">
            <summary>
            返回结果对象
            </summary>
        </member>
        <member name="P:Comm.Utils.Result.Status">
            <summary>
            返回状态
            </summary>
        </member>
        <member name="P:Comm.Utils.Result.StatusCode">
            <summary>
            返回的状态码
            </summary>
        </member>
        <member name="P:Comm.Utils.Result.Msg">
            <summary>
            返回的消息
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Comm.Utils.Result.ErrorObj" -->
        <member name="M:Comm.Utils.Result.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.Result.#ctor(Comm.Utils.ResultStatus)">
            <summary>
            构造函数
            </summary>
            <param name="Status">执行状态</param>
        </member>
        <member name="M:Comm.Utils.Result.#ctor(Comm.Utils.ResultStatus,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="Status">执行状态</param>
            <param name="Msg">返回的消息</param>
        </member>
        <member name="M:Comm.Utils.Result.SetSuccess">
            <summary>
            设置成功结果
            </summary>
        </member>
        <member name="M:Comm.Utils.Result.SetFailure(System.String)">
            <summary>
            设置失败结果
            </summary>
            <param name="msg">失败的原因</param>
        </member>
        <member name="M:Comm.Utils.Result.SetException(System.String)">
            <summary>
            设置异常结果
            </summary>
        </member>
        <member name="M:Comm.Utils.Result.SetUnknown(System.String)">
            <summary>
            设置未知结果
            </summary>
        </member>
        <member name="M:Comm.Utils.Result.IsSuccess">
            <summary>
            获取返回结果
            </summary>
        </member>
        <member name="M:Comm.Utils.Result.CopyTo(Comm.Utils.Result)">
            <summary>
            将本对象属性复制到另一个target对象
            </summary>
            <param name="target"></param>
        </member>
        <member name="T:Comm.Utils.ResultMsg`1">
            <summary>
            返回结果对象
            </summary>
            <typeparam name="T">返回结果对象</typeparam>
        </member>
        <member name="P:Comm.Utils.ResultMsg`1.ResultObj">
            <summary>
            返回对象
            </summary>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.#ctor(Comm.Utils.ResultStatus,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="Status">执行状态</param>
            <param name="Msg">返回的消息</param>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.#ctor(Comm.Utils.ResultStatus,`0)">
            <summary>
            构造函数（已过时）
            已过时：与ResultMsg(ResultStatus Status, string Msg)会产生歧义
            建议用：ResultMsg(ResultStatus Status, string Msg, T ResultObj)
            </summary>
            <param name="Status">执行状态</param>
            <param name="ResultObj">返回对象</param>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.#ctor(Comm.Utils.ResultStatus,System.String,`0)">
            <summary>
            构造函数
            </summary>
            <param name="Status">执行状态</param>
            <param name="Msg">返回的消息</param>
            <param name="ResultObj">返回对象</param>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.#ctor(Comm.Utils.Result)">
            <summary>
            构造函数
            </summary>
            <param name="Res">执行状态</param>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.#ctor(Comm.Utils.ResultStatus)">
            <summary>
            构造函数
            </summary>
            <param name="Status">执行状态</param>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.SetSuccess(`0)">
            <summary>
            设置成功结果
            </summary>
            <param name="ResultObj">返回的对象</param>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.SetSuccess">
            <summary>
            设置成功结果
            </summary>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.SetFailure(System.String)">
            <summary>
            设置失败结果
            </summary>
            <param name="msg">失败的原因</param>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.SetException(System.String)">
            <summary>
            设置异常结果
            </summary>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.SetUnknown(System.String)">
            <summary>
            设置未知结果
            </summary>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.Clone">
            <summary>
            克隆
            </summary>
        </member>
        <member name="M:Comm.Utils.ResultMsg`1.CopyTo``1(Comm.Utils.ResultMsg{``0})">
            <summary>
            将本对象属性复制到另一个ResultMsg对象
            </summary>
            <param name="target"></param>
        </member>
        <member name="T:Comm.Utils.ResultMsg">
            <summary>
            返回结果对象
            </summary>
        </member>
        <member name="M:Comm.Utils.ResultMsg.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.ResultMsg.#ctor(Comm.Utils.ResultStatus)">
            <summary>
            构造函数
            </summary>
            <param name="Status">执行状态</param>
            <param name="Msg">返回的消息</param>
        </member>
        <member name="M:Comm.Utils.ResultMsg.#ctor(Comm.Utils.ResultStatus,System.String)">
            <summary>
            /构造函数
            </summary>
            <param name="Status">执行状态</param>
            <param name="Msg">返回的消息</param>
        </member>
        <member name="T:Comm.Utils.ResultStatus">
            <summary>
            执行状态
            </summary>
        </member>
        <member name="F:Comm.Utils.ResultStatus.Success">
            <summary>
            成功
            </summary>
        </member>
        <member name="F:Comm.Utils.ResultStatus.Failure">
            <summary>
            失败
            </summary>
        </member>
        <member name="F:Comm.Utils.ResultStatus.Exception">
            <summary>
            异常
            </summary>
        </member>
        <member name="F:Comm.Utils.ResultStatus.Unknown">
            <summary>
            未知
            </summary>
        </member>
        <member name="T:Comm.Utils.JsonFormatter">
            <summary>
            Serializes and deserializes an object, or an entire graph of connected objects, in json format.
            </summary>
        </member>
        <member name="M:Comm.Utils.JsonFormatter.Serialize(System.Object)">
            <summary>
            序列化
            </summary>
            <param name="instance">对象</param>
            <returns>序列化后的字符串</returns>
        </member>
        <member name="M:Comm.Utils.JsonFormatter.Deserialize(System.String,System.Type)">
            <summary>
            反序列化
            </summary>
            <param name="json">序列化的字符串</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.JsonFormatter.Deserialize``1(System.String)">
            <summary>
            反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.Encodingkind">
            <summary>
            编码格式
            </summary>
        </member>
        <member name="F:Comm.Utils.Encodingkind.Default">
            <summary>
            默认编码 
            </summary>
        </member>
        <member name="F:Comm.Utils.Encodingkind.Unicode">
            <summary>
            Unicode编码
            </summary>
        </member>
        <member name="F:Comm.Utils.Encodingkind.UTF8">
            <summary>
            UTF8编码
            </summary>
        </member>
        <member name="F:Comm.Utils.Encodingkind.GB2312">
            <summary>
            GB2312编码
            </summary>
        </member>
        <member name="F:Comm.Utils.Encodingkind.ASCII">
            <summary>
            ASCII编码
            </summary>
        </member>
        <member name="T:Comm.Utils.Parser">
            <summary> 
            通讯编码格式提供者,为通讯服务提供编码和解码服务 
            你可以在继承类中定制自己的编码方式如:数据加密传输等 
            </summary> 
        </member>
        <member name="P:Comm.Utils.Parser.EndTag">
            <summary>
            帖包/分包标志
            </summary>
        </member>
        <member name="P:Comm.Utils.Parser.EndTagAry">
            <summary>
            帖包/分包标志
            </summary>
        </member>
        <member name="M:Comm.Utils.Parser.#ctor(System.Text.Encoding,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="encoder"></param>
            <param name="endTag"></param>
        </member>
        <member name="M:Comm.Utils.Parser.Resolve(System.String@)">
            <summary> 
            分解报文 
            </summary> 
            <param name="rawDatagram">原始数据,返回未使用的报文片断, 该片断会保存在Session的Datagram对象中</param> 
            <returns>报文数组,原始数据可能包含多个报文</returns> 
        </member>
        <member name="M:Comm.Utils.Parser.ResolveByte(System.Byte[]@)">
            <summary>
            分解报文数组
            </summary>
            <param name="rawDatagram"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.Parser.GetEncodingString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            数据解码
            </summary>
            <param name="dataBytes"></param>
            <param name="start"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.Parser.GetTextBytes(System.String,System.Boolean)">
            <summary> 
            数据编码 
            </summary> 
            <param name="datagram">需要编码的报文</param> 
            <param name="isFileName">是否文件名编码</param> 
            <returns>编码后的数据</returns> 
        </member>
        <member name="M:Comm.Utils.Parser.SaveFile(System.String,System.Byte[])">
            <summary>
            保存文件
            </summary>
            <param name="fileName"></param>
            <param name="result"></param>
        </member>
        <member name="M:Comm.Utils.Parser.GetFileBytes(System.String)">
            <summary>
            GetFileBytes
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.NetEvent">
            <summary> 
            网络通讯事件模型委托 
            </summary> 
        </member>
        <member name="T:Comm.Utils.NetReceiveEvent">
            <summary> 
            网络通讯事件模型委托 
            </summary> 
        </member>
        <member name="T:Comm.Utils.NetReceiveEventArgs">
            <summary> 
            服务器程序的消息接收事件参数
            </summary> 
        </member>
        <member name="P:Comm.Utils.NetReceiveEventArgs.ByteDatagram">
            <summary> 
            获得激发该事件的会话对象 
            </summary> 
        </member>
        <member name="P:Comm.Utils.NetReceiveEventArgs.Datagram">
            <summary> 
            获得激发该事件的会话对象 
            </summary> 
        </member>
        <member name="M:Comm.Utils.NetReceiveEventArgs.#ctor(Comm.Utils.Session,System.Byte[],System.String)">
            <summary>
            构造函数
            </summary>
            <param name="client"></param>
            <param name="bytedatagram"></param>
            <param name="datagram"></param>
        </member>
        <member name="T:Comm.Utils.NetEventArgs">
            <summary> 
            服务器程序的事件参数,包含了激发该事件的会话对象 
            </summary> 
        </member>
        <member name="F:Comm.Utils.NetEventArgs._client">
            <summary> 
            客户端与服务器之间的会话 
            </summary> 
        </member>
        <member name="M:Comm.Utils.NetEventArgs.#ctor(Comm.Utils.Session)">
            <summary> 
            构造函数 
            </summary> 
            <param name="client">客户端会话</param> 
        </member>
        <member name="P:Comm.Utils.NetEventArgs.Client">
            <summary> 
            获得激发该事件的会话对象 
            </summary> 
        </member>
        <member name="T:Comm.Utils.TcpServer">
            <summary> 
            提供TCP连接服务的服务器类 
            
            特点: 
            1.使用hash表保存所有已连接客户端的状态，收到数据时能实现快速查找.每当 
            有一个新的客户端连接就会产生一个新的会话(Session).该Session代表了客 
            户端对象. 
            2.使用异步的Socket事件作为基础，完成网络通讯功能. 
            3.支持带标记的数据报文格式的识别,以完成大数据报文的传输和适应恶劣的网 
            络环境.初步规定该类支持的最大数据报文为640K(即一个数据包的大小不能大于 
            640K,否则服务器程序会自动删除报文数据,认为是非法数据),防止因为数据报文 
            无限制的增长而导致服务器崩溃 
            4.通讯格式默认使用Encoding.Default格式这样就可以和以前32位程序的客户端 
            通讯.也可以使用U-16和U-8的的通讯方式进行.可以在该DatagramResolver类的 
            继承类中重载编码和解码函数,自定义加密格式进行通讯.总之确保客户端与服务 
            器端使用相同的通讯格式 
            5.使用C# native code,将来出于效率的考虑可以将C++代码写成的32位dll来代替 
            C#核心代码, 但这样做缺乏可移植性,而且是Unsafe代码(该类的C++代码也存在) 
            6.可以限制服务器的最大登陆客户端数目 
            7.比使用TcpListener提供更加精细的控制和更加强大异步数据传输的功能,可作为 
            TcpListener的替代类 
            8.使用异步通讯模式,完全不用担心通讯阻塞和线程问题,无须考虑通讯的细节 
            </summary> 
        </member>
        <member name="E:Comm.Utils.TcpServer.ClientConn">
            <summary> 
            客户端建立连接事件 
            </summary> 
        </member>
        <member name="E:Comm.Utils.TcpServer.ClientClose">
            <summary> 
            客户端关闭事件 
            </summary> 
        </member>
        <member name="E:Comm.Utils.TcpServer.RecvData">
            <summary> 
            服务器接收到数据事件 
            </summary> 
        </member>
        <member name="M:Comm.Utils.TcpServer.#ctor(System.Int32,System.Text.Encoding,System.String,System.Int32,System.String,System.String,System.UInt16,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="port">端口</param>
            <param name="encoding">数据通讯编码</param>
            <param name="endTag">帖包/分包标志</param>
            <param name="keepAlivePeriod">心跳包间隔</param>
            <param name="keepAlivePacket">心跳包消息（keepAlivePeriod > 0不可为空）</param>
            <param name="keepAliveRespPacket">服务端心跳包响应消息（keepAlivePeriod > 0不可为空）</param>
            <param name="maxClient">最大客户端连接数</param>
            <param name="saveFilePath">文件存储路径</param>
        </member>
        <member name="M:Comm.Utils.TcpServer.#ctor(System.Int32,System.Text.Encoding,System.String,System.Int32,System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="port">端口</param>
            <param name="encoding">数据通讯编码</param>
            <param name="endTag">帖包/分包标志</param>
            <param name="keepAlivePeriod">心跳包间隔</param>
            <param name="keepAlivePacket">心跳包消息</param>
            <param name="keepAliveRespPacket">心跳包响应消息</param>
        </member>
        <member name="M:Comm.Utils.TcpServer.#ctor(System.Int32,System.Text.Encoding,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="port">端口</param>
            <param name="encoding">数据通讯编码</param>
            <param name="endTag">帖包/分包标志</param>
        </member>
        <member name="P:Comm.Utils.TcpServer.ServerSocket">
            <summary> 
            服务器的Socket对象 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpServer.ServerIP">
            <summary>
            服务器程序监听的IP地址
            </summary>
        </member>
        <member name="P:Comm.Utils.TcpServer.ServerPort">
            <summary> 
            服务器程序使用的端口 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpServer.Coder">
            <summary> 
            通讯格式编码解码器 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpServer.SessionTable">
            <summary> 
            客户端会话数组,保存所有的客户端,不允许对该数组的内容进行修改 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpServer.Capacity">
            <summary> 
            服务器可以容纳客户端的最大能力 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpServer.SessionCount">
            <summary> 
            当前的客户端连接数 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpServer.IsRun">
            <summary> 
            服务器运行状态 
            </summary> 
        </member>
        <member name="P:Comm.Utils.TcpServer.FilePath">
            <summary> 
            服务器端文件保存路径 
            </summary> 
        </member>
        <member name="M:Comm.Utils.TcpServer.VerifyClient(Comm.Utils.Session)">
            <summary>
            验证客户端
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TcpServer.AcceptConn(System.IAsyncResult)">
            <summary> 
            客户端连接处理函数 
            </summary> 
            <param name="iar">欲建立服务器连接的Socket对象</param> 
        </member>
        <member name="M:Comm.Utils.TcpServer.CreateSession(System.Net.Sockets.Socket)">
            <summary>
            通过Socket创建新Session
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TcpServer.FindSession(System.Net.Sockets.Socket)">
            <summary> 
            通过Socket对象查找Session对象 
            </summary> 
            <param name="client"></param> 
            <returns>找到的Session对象,如果为null,说明并不存在该回话</returns> 
        </member>
        <member name="M:Comm.Utils.TcpServer.FindSession(Comm.Utils.SessionId)">
            <summary> 
            通过Socket对象查找Session对象 
            </summary> 
            <param name="sessionId"></param> 
            <returns>找到的Session对象,如果为null,说明并不存在该回话</returns> 
        </member>
        <member name="M:Comm.Utils.TcpServer.ReceiveData(System.IAsyncResult)">
            <summary> 
            接受数据完成处理函数，异步的特性就体现在这个函数中， 
            收到数据后，会自动解析为字符串报文 
            </summary> 
            <param name="iar">目标客户端Socket</param> 
        </member>
        <member name="M:Comm.Utils.TcpServer.ReceiveHandle(Comm.Utils.StateObject)">
            <summary>
            接收处理
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Comm.Utils.TcpServer.AnalyticMessage(Comm.Utils.Session,Comm.Utils.StateObject)">
            <summary>
            AnalyticMessage
            </summary>
            <param name="session"></param>
            <param name="state"></param>
        </member>
        <member name="M:Comm.Utils.TcpServer.TriggerReceiveEvent(Comm.Utils.Session,System.Byte[])">
            <summary>
            触发事件接收
            </summary>
            <param name="session">客户端</param>
            <param name="array">接入到数据</param>
        </member>
        <member name="M:Comm.Utils.TcpServer.GetStrDatagram(System.Byte[])">
            <summary>
            解析接收数据
            </summary>
            <param name="arrayDatagram"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TcpServer.Start(Comm.Utils.CommunicationMode)">
            <summary>
            启动服务器程序,开始监听客户端请求 
            </summary>
        </member>
        <member name="M:Comm.Utils.TcpServer.Stop">
            <summary> 
            停止服务器程序,所有与客户端的连接将关闭 
            </summary> 
        </member>
        <member name="M:Comm.Utils.TcpServer.CloseAllClient">
            <summary> 
            关闭所有的客户端会话,与所有的客户端连接会断开 
            </summary> 
        </member>
        <member name="M:Comm.Utils.TcpServer.CloseSession(Comm.Utils.Session,System.Nullable{Comm.Utils.ExitType})">
            <summary> 
            关闭一个与客户端之间的会话 
            </summary> 
            <param name="closeClient">需要关闭的客户端会话对象</param> 
            <param name="exitType">退回类型</param> 
        </member>
        <member name="M:Comm.Utils.TcpServer.SendText(Comm.Utils.Session,System.String)">
            <summary> 
            发送数据 
            </summary> 
            <param name="client">接收数据的客户端会话</param> 
            <param name="datagram">数据报文</param> 
        </member>
        <member name="M:Comm.Utils.TcpServer.SendText(Comm.Utils.Session,System.Byte[])">
            <summary> 
            发送数据 
            </summary> 
            <param name="client">接收数据的客户端会话</param> 
            <param name="datagram">数据报文</param> 
        </member>
        <member name="M:Comm.Utils.TcpServer.SendFile(Comm.Utils.Session,System.String)">
            <summary>
            发送文件
            </summary>
            <param name="client"></param>
            <param name="filePath"></param>
        </member>
        <member name="T:Comm.Utils.TimeoutTask">
            <summary>
            可能超时的任务
            </summary>
        </member>
        <member name="M:Comm.Utils.TimeoutTask.#ctor(System.Action{System.Delegate},System.Action{System.Delegate})">
            <summary>
            构造函数
            </summary>
            <param name="proc"></param>
            <param name="timeoutHandle"></param>
        </member>
        <member name="T:Comm.Utils.HttpHelper">
            <summary>
            封装HTTP请求的类，加上超时的判断机制
            </summary>
            <summary>
            Request 操作类
            </summary>
        </member>
        <member name="M:Comm.Utils.HttpHelper.CloseRequest(System.Net.HttpWebRequest,System.Net.HttpWebResponse)">
            <summary>
            关闭/中止连接请求
            </summary>
            <param name="req"></param>
            <param name="res"></param>
        </member>
        <member name="M:Comm.Utils.HttpHelper.webRequest(System.String,Comm.Utils.HttpReqEntity,System.Int32)">
            <summary>
            请求
            </summary>
            <param name="data">POST时的数据</param>
            <param name="url">地址</param>
            <param name="timeout">超时时间秒</param>
            <returns>返回HttpResEntity</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Post(System.String)">
            <summary>
            Post请求
            </summary>
            <param name="url">请求的地址</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Post(System.String,System.String)">
            <summary>
            Post请求
            </summary>
            <param name="data">发送的数据</param>
            <param name="url">请求的地址</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Post(System.String,System.String,System.Int32)">
            <summary>
            Post请求
            </summary>
            <param name="data">发送的数据</param>
            <param name="url">请求的地址</param>
            <param name="timeout">允许超时间，单位（秒）</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Get(System.String)">
            <summary>
            Get请求
            </summary>
            <param name="url">请求的地址</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Get(System.String,System.Int32)">
            <summary>
            Get请求
            </summary>
            <param name="url">请求的地址</param>
            <param name="timeout">允许超时间，单位（秒）</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Http(System.String,Comm.Utils.HttpReqEntity)">
            <summary>
            请求
            </summary>
            <param name="url">请求的URL</param>
            <param name="data">请求的包实体</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Http(System.String,Comm.Utils.HttpReqEntity,System.Int32)">
            <summary>
            请求
            </summary>
            <param name="url">请求的URL</param>
            <param name="data">请求的包实体</param>
            <param name="timeout">允许超时间，单位（秒）</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Http(System.String,System.String,System.String,Comm.Utils.HttpMethod)">
            <summary>
            请求
            </summary>
            <param name="url">请求地址</param>
            <param name="data">请求数据</param>
            <param name="cookie">附加请求COOKIE</param>
            <param name="method">请求方式</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.Http(System.String,System.String,System.String,Comm.Utils.HttpMethod,System.Int32)">
            <summary>
            请求
            </summary>
            <param name="url">请求地址</param>
            <param name="data">请求数据</param>
            <param name="cookie">附加请求COOKIE</param>
            <param name="method">请求方式</param>
            <param name="timeout">允许超时间，单位（秒）</param>
            <returns></returns>
        </member>
        <member name="P:Comm.Utils.HttpHelper.Request">
            <summary>
            当前 Http 请求对象
            </summary>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetCurrentFullHost">
            <summary>
            获取完整的主机名称及端口号
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetHost">
            <summary>
            获取主机名称
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetUserBrowser">
            <summary>
            获取访问者所使用的浏览器名
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetUserIP">
            <summary>
            获取客户端的 IP 信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetUserOsname">
            <summary>
            获取访问者所使用的操作系统名
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.ClearClientPageCache">
            <summary>
            清空客户端浏览器的缓存,设置页面不被缓存
            </summary>
        </member>
        <member name="M:Comm.Utils.HttpHelper.SetPageNoCache">
            <summary>
            设置页面不被缓存
            </summary>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetFloat(System.String,System.Single)">
            <summary>
            获取 Get 请求的float参数值
            </summary>
            <param name="strName">参数名称</param>
            <param name="defValue">设置参数的默认值，供返回使用</param>
            <returns>返回转换后的float参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetFormFloat(System.String,System.Single)">
            <summary>
             获取表单提交的float参数值
            </summary>
            <param name="strName">参数名称</param>
            <param name="defValue">设置参数的默认值，供返回使用</param>
            <returns>返回转换后的float参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetFormInt(System.String,System.Int32)">
            <summary>
            获取表单提交的int参数值
            </summary>
            <param name="strName">参数名称</param>
            <param name="defValue">设置参数的默认值，供返回使用</param>
            <returns>返回转换后的int参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetFormInt(System.Web.HttpRequest,System.String,System.Int32)">
            <summary>
            获取表单提交的int参数值
            </summary>
            <param name="request">请求对象</param>
            <param name="strName">参数名称</param>
            <param name="defValue">设置参数的默认值，供返回使用</param>
            <returns>返回转换后的int参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetFormString(System.String)">
            <summary>
            获取表单提交的string参数值
            </summary>
            <param name="strName">参数名称</param>
            <returns>返回转换后的string参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetFormString(System.Web.HttpRequest,System.String)">
            <summary>
            获取表单提交的string参数值
            </summary>
            <param name="request">请求对象</param>
            <param name="strName">参数名称</param>
            <returns>返回转换后的string参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetInt(System.String,System.Int32)">
            <summary>
            获取 Get 请求的int参数值
            </summary>
            <param name="strName">参数名称</param>
            <param name="defValue">设置参数的默认值，供返回使用</param>
            <returns>返回转换后的int参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetPageName">
            <summary>
            获取当前请求的文件名
            </summary>
            <returns>返回文件名</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetParamCount">
            <summary>
            返回表单或Url参数的总个数
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetQueryFloat(System.String,System.Single)">
            <summary>
            获取 Get 请求传递的float参数值
            </summary>
            <param name="strName">参数名称</param>
            <param name="defValue">设置参数的默认值，供返回使用</param>
            <returns>返回转换后的float参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetQueryInt(System.String,System.Int32)">
            <summary>
            获取 Get 请求传递的int参数值
            </summary>
            <param name="strName">参数名称</param>
            <param name="defValue">设置参数的默认值，供返回使用</param>
            <returns>返回转换后的int参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetQueryInt(System.Web.HttpRequest,System.String,System.Int32)">
            <summary>
            获取 Get 请求传递的int参数值
            </summary>
            <param name="request">请求对象</param>
            <param name="strName">参数名称</param>
            <param name="defValue">设置参数的默认值，供返回使用</param>
            <returns>返回转换后的int参数值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetQueryString(System.String)">
            <summary>
            获取 HTTP 查询字符串变量
            </summary>
            <param name="strName">参数名称</param>
            <returns>返回对应参数变量的值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetQueryString(System.Web.HttpRequest,System.String)">
            <summary>
            获取 HTTP 查询字符串变量
            </summary>
            <param name="request">请求对象</param>
            <param name="strName">参数名称</param>
            <returns>返回对应参数变量的值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetString(System.String)">
            <summary>
            获取 HTTP 查询字符串变量
            </summary>
            <param name="strName">参数变量名</param>
            <returns>返回对应参数变量的值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetString(System.Web.HttpRequest,System.String)">
            <summary>
            获取 HTTP 查询字符串变量
            </summary>
            <param name="request">请求对象</param>
            <param name="strName">参数变量名</param>
            <returns>返回对应参数变量的值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetRawUrl">
            <summary>
            获取当前请求的原始 URL 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetUrl">
            <summary>
            获取当前请求的URL 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetUrlPathAndQuery">
            <summary>
            获取当前请求的URL的AbsolutePath与Query的组合
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetUrlReferrer">
            <summary>
            获取客户端上次请求的 URL 路径，该请求链接到当前的 URL
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetUrlReferrerPathAndQuery">
            <summary>
            获取客户端上次请求的 URL的AbsolutePath与Query的组合
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetServerDomain">
            <summary>
            获取网站顶级域名
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetServerString(System.String)">
            <summary>
            获取 Web 服务器变量
            </summary>
            <param name="strName">参数变量名</param>
            <returns>返回对应参数变量的值</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetHostName">
            <summary>
            取机器名
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetOSVersion">
            <summary>
            获取操作系统版本
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.IsBrowserGet">
            <summary>
            获取是否是书籍的浏览器访问的信息
            </summary>
            <returns>返回浏览器的功能信息</returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.IsCrossSitePost">
            <summary>
            返回当前页面是否是跨站提交
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.IsCrossSitePost(System.String,System.String)">
            <summary>
            判断是否是跨站提交
            </summary>
            <param name="urlReferrer">上个页面地址</param>
            <param name="host">网站url</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.IsGet">
            <summary>
            客户端是否使用 GET 方法的 HTTP数据传输
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.IsPost">
            <summary>
            客户端是否使用 POST 方法的 HTTP数据传输
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.IsRobots">
            <summary>
            是否被判断为机器人
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.IsSearchEnginesGet">
            <summary>
            搜索引擎来源判断
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.SaveRequestFile(System.String)">
            <summary>
            保存上载文件的内容
            </summary>
            <param name="path">上载文件路径</param>
        </member>
        <member name="P:Comm.Utils.HttpHelper.IsPostFromAnotherDomain">
            <summary>
            是否从其他连接向本域名连接
            </summary>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetHtml(System.String,System.Text.Encoding)">
            <summary>
            获取网页HTML源代码
            </summary>
            <param name="URL"></param>
            <param name="encoder"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetHtml(System.String,System.String@,System.Text.Encoding)">
            <summary>
            获取网页HTML源代码、Cookie
            </summary>
            <param name="URL"></param>
            <param name="cookie"></param>
            <param name="encoder"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetHtml(System.String,System.String,System.String,System.String,System.String@,System.Text.Encoding)">
            <summary>
            模拟提交数据，获取html源代码、返回的header
            </summary>
            <param name="server">域名</param>
            <param name="URL">URL地址</param>
            <param name="postData">post的数据</param>
            <param name="cookie">模拟的cookie</param>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.HttpHelper.CookieAddInternetCallback">
            <summary>
            一个种cookie的委托，做为回调函数
            </summary>
            <param name="cContainer"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetHtml(System.String,System.String,System.String,System.String,System.String@,System.Text.Encoding,System.Boolean,Comm.Utils.HttpHelper.CookieAddInternetCallback)">
            <summary>
            模拟提交数据，获取html源代码、返回的header
            </summary>
            <param name="server">域名</param>
            <param name="URL">URL地址</param>
            <param name="postData">post的数据</param>
            <param name="cookie">模拟的cookie</param>
            <param name="header"></param>
            <param name="responseCookieAddInternet">是否将返回的cookie添加到浏览器中</param>
            <param name="cookieName">要添加到浏览器的cookie名称</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetHtmlByBytes(System.String,System.String,System.Byte[],System.String,System.String@,System.Text.Encoding,System.Boolean,Comm.Utils.HttpHelper.CookieAddInternetCallback)">
            <summary>
            模拟提交数据，获取html源代码、返回的header
            </summary>
            <param name="server">域名</param>
            <param name="URL">URL地址</param>
            <param name="byteRequest">post的数据</param>
            <param name="cookie">模拟的cookie</param>
            <param name="header"></param>
            <param name="responseCookieAddInternet">是否将返回的cookie添加到浏览器中</param>
            <param name="args">一些要进行responseCookieAddInternet处理的参数</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.HttpHelper.GetHtml(System.String,System.String,System.String,System.String@,System.Text.Encoding)">
            <summary>
            get方式模拟提交数据，获取html源代码、返回的header
            </summary>
            <param name="server"></param>
            <param name="URL"></param>
            <param name="cookie"></param>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.NetHelper">
            <summary>
            网络环境助手
            </summary>
        </member>
        <member name="M:Comm.Utils.NetHelper.CheckIPAddr(System.String)">
            <summary>  
            验证IP地址字符串的正确性  
            </summary>  
            <param name="strIP">要验证的IP地址字符串</param>  
            <returns>格式是否正确，正确为 true 否则为 false</returns>  
        </member>
        <member name="M:Comm.Utils.NetHelper.PingNetConnectity(System.String)">
            <summary>  
            验证某个IP是否可ping通  
            </summary>  
            <param name="strIP">要验证的IP</param>  
            <returns>是否可连通  是：true 否：false</returns>  
        </member>
        <member name="M:Comm.Utils.NetHelper.PingNetConnectity(System.String,System.Int32,System.Int32)">
            <summary>  
            连续几次查看是否某个IP可以PING通  
            </summary>  
            <param name="strIP">ping的IP地址</param>  
            <param name="WaitSecond">每次间隔时间，单位：秒</param>  
            <param name="iTestTimes">测试次数</param>  
            <returns>是否可以连通</returns>  
        </member>
        <member name="M:Comm.Utils.NetHelper.LocalNetworkIsAvailable">
            <summary>
            检查本地是否有可用的网络
            </summary>
            <returns>本地网络是否可用</returns>
        </member>
        <member name="M:Comm.Utils.NetHelper.GetLocalNetworkIP">
            <summary>
            获取本地可用网络IP地址（以太网卡与无线网卡，优先取以太网卡。去除虚拟机网卡/PPP宽带连接网卡）
            </summary>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.IntervalTimerRunEnum">
            <summary>
            轮循状态
            </summary>
        </member>
        <member name="T:Comm.Utils.IntervalTimer">
            <summary>
            轮循器
            </summary>
        </member>
        <member name="M:Comm.Utils.IntervalTimer.#ctor(Comm.Utils.DoHandle,System.Int32)">
            <summary>
            Timer
            </summary>
            <param name="proc">处理</param>
            <param name="interval">间隔毫秒</param>
        </member>
        <member name="M:Comm.Utils.IntervalTimer.#ctor(Comm.Utils.DoHandle,System.Int32,System.Int32)">
            <summary>
            Timer
            </summary>
            <param name="proc">处理</param>
            <param name="lazy_interval">lazy毫秒</param>
            <param name="interval">间隔毫秒</param>
        </member>
        <member name="M:Comm.Utils.IntervalTimer.#ctor(Comm.Utils.DoHandle,System.Int32,System.Int32,System.Int32)">
            <summary>
            Timer
            </summary>
            <param name="proc">处理</param>
            <param name="lazy_interval">lazy毫秒</param>
            <param name="interval">间隔毫秒</param>
            <param name="allowError">允许处理错误的次数</param>
        </member>
        <member name="M:Comm.Utils.IntervalTimer.DoHandleErr(System.Action)">
            <summary>
            运行Handle错误后的处理
            </summary>
            <param name="errMessage"></param>
        </member>
        <member name="M:Comm.Utils.IntervalTimer.Reset">
            <summary>
            运行Handle成功后重置标量
            </summary>
        </member>
        <member name="M:Comm.Utils.IntervalTimer.Start">
            <summary>
            开启/运行timer
            </summary>
        </member>
        <member name="M:Comm.Utils.IntervalTimer.Stop">
            <summary>
            关闭/释放timer
            </summary>
        </member>
        <member name="M:Comm.Utils.IntervalTimer.Pause">
            <summary>
            暂停timer
            </summary>
        </member>
        <member name="T:Comm.Utils.DynamicActivatorInst">
            <summary>
            动态实例(Activator形式)
            </summary>
        </member>
        <member name="M:Comm.Utils.DynamicActivatorInst.CreateInstance(System.Type,System.Object[])">
            <summary>
            动态创建实例
            </summary>
            <param name="type">类型</param>
            <param name="parameters">可变参数</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.DynamicILGeneratorInst">
            <summary>
            动态实例(ILGenerator形式)
            </summary>
        </member>
        <member name="M:Comm.Utils.DynamicILGeneratorInst.GetKey(System.Type,System.Type[])">
            <summary>
            获取参数组合的键
            </summary>
            <param name="type"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.DynamicILGeneratorInst.GetParameterTypes(System.Object[])">
            <summary>
            获取参数类型
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.DynamicILGeneratorInst.CreateInstance(System.Type,System.Object[])">
            <summary>
            动态创建实例
            </summary>
            <param name="type">类型</param>
            <param name="parameters">可变参数</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.DynamicExpInst">
            <summary>
            动态实例(Expression形式)
            </summary>
        </member>
        <member name="M:Comm.Utils.DynamicExpInst.BuildDeletgateObj(System.Type,System.Type[])">
            <summary>
            委托对象,使用它来生成一个实体类
            </summary>
            <param name="type">类型</param>
            <param name="typeList">参数类型</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.DynamicExpInst.GetExpressionArray(System.Type[],System.Linq.Expressions.ParameterExpression)">
            <summary>
            获取表达式数组
            </summary>
            <param name="typeList"></param>
            <param name="paramExp"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.DynamicExpInst.GetKey(System.Type,System.Object[])">
            <summary>
            获取参数组合的键
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.DynamicExpInst.CreateInstance(System.Type,System.Object[])">
            <summary>
            动态创建实例
            </summary>
            <param name="type">类型</param>
            <param name="parameters">可变参数</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.DynamicInvokeInst">
            <summary>
            动态实例(Activator形式)
            </summary>
        </member>
        <member name="M:Comm.Utils.DynamicInvokeInst.GetKey(System.Type,System.Type[])">
            <summary>
            获取参数组合的键
            </summary>
            <param name="type"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.DynamicInvokeInst.GetParameterTypes(System.Object[])">
            <summary>
            获取参数类型
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.DynamicInvokeInst.CreateInstance(System.Type,System.Object[])">
            <summary>
            动态创建实例
            </summary>
            <param name="type">类型</param>
            <param name="parameters">可变参数</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.Invokable">
            <summary>
            动态调用抽象类
            </summary>
        </member>
        <member name="M:Comm.Utils.Invokable.Invoke(System.String,System.Object[])">
            <summary>
            查看<see cref="!:IInvokable.Invoke"/>说明
            </summary> 
        </member>
        <member name="M:Comm.Utils.Invokable.Invoke``1(System.String,System.Object[])">
            <summary>
            查看<see cref="!:IInvokable.Invoke&lt;T&gt;"/>说明
            </summary> 
        </member>
        <member name="M:Comm.Utils.Invokable.GetProperty``1(System.String)">
            <summary>
            查看<see cref="!:IInvokable.GetProperty&lt;T&gt;"/>说明
            </summary> 
        </member>
        <member name="M:Comm.Utils.Invokable.SetProperty``1(System.String,``0)">
            <summary>
            查看<see cref="!:IInvokable.SetProperty&lt;T&gt;"/>说明
            </summary>
        </member>
        <member name="T:Comm.Utils.InvokeAttribute">
            <summary>
            表示Method或Property可被动态调用的属性
            </summary>
        </member>
        <member name="T:Comm.Utils.InvokeException">
            <summary>
            Invoke 时引发的异常
            </summary>
        </member>
        <member name="M:Comm.Utils.InvokeException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.InvokeException.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Comm.Utils.InvokeException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.InvokeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            序列化构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Comm.Utils.InvokeException.#ctor(System.Object,System.String)">
            <summary>
            指定Invoke的附加对象、成员名称的构造函数
            </summary>
            <param name="target"></param>
            <param name="memberName"></param>
        </member>
        <member name="P:Comm.Utils.InvokeException.Target">
            <summary>
            获取或设置Invoke的附加对象
            </summary>
        </member>
        <member name="P:Comm.Utils.InvokeException.TargetType">
            <summary>
            获取或设置Invoke的附加对象类型
            </summary>
        </member>
        <member name="P:Comm.Utils.InvokeException.MemberName">
            <summary>
            获取或设置Invoke的成员名称
            </summary>
        </member>
        <member name="T:Comm.Utils.QuickReflex">
            <summary>
            快速反射对象
            </summary>
        </member>
        <member name="F:Comm.Utils.QuickReflex.m_Ob">
            <summary>
            反射出的对象
            </summary>
        </member>
        <member name="M:Comm.Utils.QuickReflex.#ctor(System.String,System.String,System.String,Comm.Utils.ReflexWay)">
            <summary>
            构造函数
            </summary>
            <param name="assemblyPath">路径</param>
            <param name="assemblyName">程序集</param>
            <param name="typeName">类名</param>
            <param name="reflexWay">反射方式</param>
        </member>
        <member name="M:Comm.Utils.QuickReflex.GetPropertyValue(System.String)">
            <summary>
            获取反射对象的属性值
            </summary>
            <param name="PropertyName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.QuickReflex.InvokeMethod(System.String,System.Object[])">
            <summary>
            执行反射对象的方法
            </summary>
            <param name="methodName"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.ArgumentHelper">
            <summary>
            Provides helper methods for asserting arguments.
            </summary>
            <remarks>
            <para>
            This class provides helper methods for asserting the validity of arguments. It can be used to reduce the number of
            laborious <c>if</c>, <c>throw</c> sequences in your code.
            </para>
            <para>
            The <see cref="M:Comm.Utils.ArgumentHelper.AssertNotNull``1(``0,System.String)"/> method can be used to ensure that arguments are not <see langword="null"/>. The
            <see cref="M:Comm.Utils.ArgumentHelper.AssertNotNullOrEmpty(System.String,System.String)"/> overloads can be used to ensure that strings are not <see langword="null"/> or empty.
            The <see cref="M:Comm.Utils.ArgumentHelper.AssertEnumMember``1(``0,System.String)"/> overloads can be used to assert the validity of enumeration arguments.
            </para>
            </remarks>
            <example>
            The following code ensures that the <c>name</c> argument is not <see langword="null"/>:
            <code>
            public void DisplayDetails(string name)
            {
            	ArgumentHelper.AssertNotNull(name, "name");
            	//now we know that name is not null
            	...
            }
            </code>
            </example>
            <example>
            The following code ensures that the <c>name</c> argument is not <see langword="null"/> or an empty <c>string</c>:
            <code>
            public void DisplayDetails(string name)
            {
            	ArgumentHelper.AssertNotNullOrEmpty(name, "name", true);
            	//now we know that name is not null and is not an empty string (or blank)
            	...
            }
            </code>
            </example>
            <example>
            The following code ensures that the <c>day</c> parameter is a valid member of its enumeration:
            <code>
            public void DisplayInformation(DayOfWeek day)
            {
            	ArgumentHelper.AssertEnumMember(day);
            	//now we know that day is a valid member of DayOfWeek
            	...
            }
            </code>
            </example>
            <example>
            The following code ensures that the <c>day</c> parameter is either DayOfWeek.Monday or DayOfWeek.Thursday:
            <code>
            public void DisplayInformation(DayOfWeek day)
            {
            	ArgumentHelper.AssertEnumMember(day, DayOfWeek.Monday, DayOfWeek.Thursday);
            	//now we know that day is either Monday or Thursday
            	...
            }
            </code>
            </example>
            <example>
            The following code ensures that the <c>bindingFlags</c> parameter is either BindingFlags.Public, BindingFlags.NonPublic
            or both:
            <code>
            public void GetInformation(BindingFlags bindingFlags)
            {
            	ArgumentHelper.AssertEnumMember(bindingFlags, BindingFlags.Public, BindingFlags.NonPublic);
            	//now we know that bindingFlags is either Public, NonPublic or both
            	...
            }
            </code>
            </example>
            <example>
            The following code ensures that the <c>bindingFlags</c> parameter is either BindingFlags.Public, BindingFlags.NonPublic,
            both or neither (BindingFlags.None):
            <code>
            public void GetInformation(BindingFlags bindingFlags)
            {
            	ArgumentHelper.AssertEnumMember(bindingFlags, BindingFlags.Public, BindingFlags.NonPublic, BindingFlags.None);
            	//now we know that bindingFlags is either Public, NonPublic, both or neither
            	...
            }
            </code>
            </example>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertNotNull``1(``0,System.String)">
            <summary>
            Ensures that <paramref name="arg"/> is not <see langword="null"/>. If it is, an <see cref="T:System.ArgumentNullException"/>
            is thrown.
            </summary>
            <typeparam name="T">
            The type of the argument.
            </typeparam>
            <param name="arg">
            The argument to check for <see langword="null"/>.
            </param>
            <param name="argName">
            The name of the argument.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="arg"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertNotNull``1(System.Nullable{``0},System.String)">
            <summary>
            Ensures that <paramref name="arg"/> is not <see langword="null"/>. If it is, an <see cref="T:System.ArgumentNullException"/>
            is thrown.
            </summary>
            <typeparam name="T">
            The type of the nullable argument.
            </typeparam>
            <param name="arg">
            The nullable argument.
            </param>
            <param name="argName">
            The name of the argument.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="arg"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertGenericArgumentNotNull``1(``0,System.String)">
            <summary>
            Ensures that <paramref name="arg"/> is not <see langword="null"/>. If it is, an <see cref="T:System.ArgumentNullException"/>
            is thrown.
            </summary>
            <remarks>
            <para>
            This method can be used instead of one of the <see cref="M:Comm.Utils.ArgumentHelper.AssertNotNull``1(``0,System.String)"/> overloads in the case where the argument
            being checked is generic. It will ensure that <paramref name="arg"/> is not <see langword="null"/> if it is a
            reference type or if it is an instance of <see cref="T:System.Nullable`1"/>.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the argument.
            </typeparam>
            <param name="arg">
            The argument.
            </param>
            <param name="argName">
            The name of the argument.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="arg"/> is <see langword="null"/>.
            </exception>
            <example>
            The following code ensures that the <c>name</c> argument is not <see langword="null"/> or an empty <c>string</c>:
            <code>
            public void SomeMethod&lt;T&gt;(T arg)
            {
            	ArgumentHelper.AssertGenericArgumentNotNull(arg, "arg");
            	//now we know that arg is not null, regardless of whether it is a reference type or a Nullable type
            	...
            }
            </code>
            </example>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertNotNull``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Boolean)">
            <summary>
            Ensures that <paramref name="arg"/> is not <see langword="null"/>, optionally checking each item in it for
            <see langword="null"/>. If any checked items are <see langword="null"/>, an exception is thrown.
            </summary>
            <remarks>
            <para>
            This method throws an <see cref="T:System.ArgumentNullException"/> if <paramref name="arg"/> is <see langword="null"/>. If
            <paramref name="assertContentsNotNull"/> is <see langword="true"/> and one of the items in <paramref name="arg"/>
            is found to be <see langword="null"/>, an <see cref="T:System.ArgumentException"/> is thrown.
            </para>
            </remarks>
            <typeparam name="T">
            The type of the items in the <paramref name="arg"/> enumeration.
            </typeparam>
            <param name="arg">
            The argument to check for <see langword="null"/>.
            </param>
            <param name="argName">
            The name of the argument.
            </param>
            <param name="assertContentsNotNull">
            If <see langword="true"/>, each item inside the <paramref name="arg"/> enumeration is also checked for
            <see langword="null"/>. If <see langword="false"/>, only <paramref name="arg"/> itself is checked for
            <see langword="null"/>.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="assertContentsNotNull"/> is <see langword="true"/> and one of the items in <paramref name="arg"/>
            is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertNotNullOrEmpty(System.String,System.String)">
            <summary>
            Ensures that <paramref name="arg"/> is not <see langword="null"/> or an empty <c>string</c>. If it is, an
            <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <param name="arg">
            The argument to check for <see langword="null"/> or an empty <c>string</c>.
            </param>
            <param name="argName">
            The name of the argument.
            </param>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertNotNullOrEmpty(System.String,System.String,System.Boolean)">
            <summary>
            Ensures that <paramref name="arg"/> is not <see langword="null"/> or an empty <c>string</c>, optionally trimming
            <paramref name="arg"/> first. If it is, an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <param name="arg">
            The argument to check for <see langword="null"/> or an empty <c>string</c>.
            </param>
            <param name="argName">
            The name of the argument.
            </param>
            <param name="trim">
            If <see langword="true"/> and <paramref name="arg"/> is not <see langword="null"/> or an empty <c>string</c>, it is
            trimmed and re-tested for being empty.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="arg"/> is <see langword="null"/> or an empty <c>string</c>, or if it is a blank <c>string</c> and
            <paramref name="trim"/> is <see langword="true"/>.
            </exception>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertEnumMember``1(``0,System.String)">
            <summary>
            Ensures that <paramref name="enumValue"/> is a valid member of the <typeparamref name="TEnum"/> enumeration. If it
            is not, an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <remarks>
            <para>
            This method can be used to validate all publicly-supplied enumeration values. Without such an assertion, it is
            possible to cast any <c>int</c> value to the enumeration type and pass it in.
            </para>
            <para>
            This method works for both flags and non-flags enumerations. In the case of a flags enumeration, any combination of
            values in the enumeration is accepted. In the case of a non-flags enumeration, <paramref name="enumValue"/> must
            be equal to one of the values in the enumeration.
            </para>
            <para>
            This method is generic and quite slow as a result. You should prefer using the
            <see cref="M:Comm.Utils.ArgumentHelper.AssertEnumMember``1(``0,System.String,``0[])"/> overload where possible. That overload is both faster and
            safer. Faster because it does not incur reflection costs, and safer because you are able to specify the exact
            values accepted by your method.
            </para>
            </remarks>
            <typeparam name="TEnum">
            The enumeration type.
            </typeparam>
            <param name="enumValue">
            The value of the enumeration.
            </param>
            <param name="argName">
            The name of the argument.
            </param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="enumValue"/> is not a valid member of the <typeparamref name="TEnum"/> enumeration.
            </exception>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertEnumMember``1(``0,System.String,``0[])">
            <summary>
            Ensures that <paramref name="enumValue"/> is included in the values specified by <paramref name="validValues"/>. If
            it is not, an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <remarks>
            <para>
            This method can be used to ensure that an enumeration argument is valid for the context of the method. It works for
            both flags and non-flags enumerations. For flags enumerations, <paramref name="enumValue"/> must be any combination
            of values specified by <paramref name="validValues"/>. For non-flags enumerations, <paramref name="enumValue"/>
            must be one of the values specified by <paramref name="validValues"/>.
            </para>
            <para>
            This method is much faster than the <see cref="M:Comm.Utils.ArgumentHelper.AssertEnumMember``1(``0,System.String)"/> overload. This is because it does
            not use reflection to determine the values defined by the enumeration. For this reason you should prefer this method
            when validating enumeration arguments.
            </para>
            <para>
            Another reason why this method is prefered is because it allows you to explicitly specify the values that your code
            handles. If you use the<see cref="M:Comm.Utils.ArgumentHelper.AssertEnumMember``1(``0,System.String)"/> overload and a new value is later added to the
            enumeration, the assertion will not fail but your code probably will.
            </para>
            </remarks>
            <typeparam name="TEnum">
            The enumeration type.
            </typeparam>
            <param name="enumValue">
            The value of the enumeration.
            </param>
            <param name="argName">
            The name of the argument.
            </param>
            <param name="validValues">
            An array of all valid values.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="validValues"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="enumValue"/> is not present in <paramref name="validValues"/>, or (for flag enumerations) if
            <paramref name="enumValue"/> is not some combination of values specified in <paramref name="validValues"/>.
            </exception>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertRange(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Checks if the given int is between the min and max values and displays a message if it is not.
            </summary>
            <param name="value">Int value to check.</param>
            <param name="min">Minimum value.</param>
            <param name="max">Maximum value.</param>
            <param name="paramName">The name of the parameter</param>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertRange(System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Checks if the given int is between the min and max values and displays a message if it is not.
            </summary>
            <param name="value">Int value to check.</param>
            <param name="min">Minimum value.</param>
            <param name="max">Maximum value.</param>
            <param name="paramName">The name of the parameter</param>
        </member>
        <member name="M:Comm.Utils.ArgumentHelper.AssertRange(System.Double,System.Double,System.Double,System.String)">
            <summary>
            Checks if the given int is between the min and max values and displays a message if it is not.
            </summary>
            <param name="value">Int value to check.</param>
            <param name="min">Minimum value.</param>
            <param name="max">Maximum value.</param>
            <param name="paramName">The name of the parameter</param>
        </member>
        <member name="T:Comm.Utils.LazyTimer">
            <summary>
            延时启动类型，线程类型，非定时器类型
            在冗余时间内调用shart时，将延长冗余时间，直到在冗余时间内不调用start。
            </summary>
        </member>
        <member name="M:Comm.Utils.LazyTimer.#ctor(System.Int32,Comm.Utils.LazyTimer.LazyEvent)">
            <summary>
            构造
            </summary>
            <param name="nTimer">冗余时间</param>
            <param name="e">回调事件</param>
        </member>
        <member name="M:Comm.Utils.LazyTimer.#ctor(Comm.Utils.LazyTimer.LazyEvent)">
            <summary>
            构造
            </summary>
            <param name="e">回调事件</param>
        </member>
        <member name="M:Comm.Utils.LazyTimer.Start">
            <summary>
            
            </summary>
        </member>
        <member name="T:Comm.Utils.ReflexWay">
            <summary>
            反射方式
            </summary>
        </member>
        <member name="F:Comm.Utils.ReflexWay.Expression">
            <summary>
            表达式树
            </summary>
        </member>
        <member name="F:Comm.Utils.ReflexWay.ILGenerator">
            <summary>
            ILGeneratorEmit
            </summary>
        </member>
        <member name="F:Comm.Utils.ReflexWay.Activator">
            <summary>
            Activator
            </summary>
        </member>
        <member name="F:Comm.Utils.ReflexWay.MethodInvoke">
            <summary>
            传统Invoke
            </summary>
        </member>
        <member name="T:Comm.Utils.CultureEnumsResx">
            <summary>
            特定语系下的所有枚举资源, string1为枚举的全名（含namespace),也是外部多语言对应的ResourceName
            </summary>
        </member>
        <member name="M:Comm.Utils.CultureEnumsResx.#ctor(System.DateTime)">
            <summary>
            快速构造函数
            </summary>
            <param name="createTime"></param>
        </member>
        <member name="P:Comm.Utils.CultureEnumsResx.LoadTime">
            <summary>
            被加载时间
            </summary>
        </member>
        <member name="P:Comm.Utils.CultureEnumsResx.LastUseTime">
            <summary>
            最后使用时间
            </summary>
        </member>
        <member name="T:Comm.Utils.EnumItemsResx">
            <summary>
            单个枚举定义的所有成员语系资源， string1为枚举成员字符串或者枚举成员上标柱的资源Id，string2为枚举成员上标柱的资源信息
            </summary>
        </member>
        <member name="M:Comm.Utils.EnumItemsResx.#ctor(System.DateTime)">
            <summary>
            快速构造函数
            </summary>
            <param name="createTime"></param>
        </member>
        <member name="P:Comm.Utils.EnumItemsResx.LoadTime">
            <summary>
            被加载时间
            </summary>
        </member>
        <member name="P:Comm.Utils.EnumItemsResx.LastUseTime">
            <summary>
            最后使用时间
            </summary>
        </member>
        <member name="T:Comm.Utils.FastSmartWeakEvent`1">
            <summary>
            弱事件管理类.
            </summary>
        </member>
        <member name="T:Comm.Utils.LanguageChangedEventHandler">
            <summary>
            语言变更事件处理委托
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Comm.Utils.LanguageChangedArgs">
            <summary>
            语言变更参数
            </summary>
        </member>
        <member name="T:Comm.Utils.LanguageType">
            <summary>
            语言种类
            </summary>
        </member>
        <member name="F:Comm.Utils.LanguageType.zh_CN">
            <summary>
            简体
            </summary>
        </member>
        <member name="F:Comm.Utils.LanguageType.en_US">
            <summary>
            英语
            </summary>
        </member>
        <member name="F:Comm.Utils.LanguageType.ja_JP">
            <summary>
            日文
            </summary>
        </member>
        <member name="F:Comm.Utils.LanguageType.zh_TW">
            <summary>
            繁体中文
            </summary>
        </member>
        <member name="T:Comm.Utils.ResourceAttribute">
            <summary>
            多语系资源定义，如果标注此属性，该枚举类型可按多语系方式调用
            </summary>
        </member>
        <member name="T:Comm.Utils.ResxValueAttribute">
            <summary>
            与<see cref="T:Comm.Utils.ResourceAttribute"/>结合使用
            </summary>
        </member>
        <member name="M:Comm.Utils.ResxValueAttribute.#ctor(System.String)">
            <summary>
            快速构造函数
            </summary>
            <param name="resxValue">资源内容</param>
        </member>
        <member name="M:Comm.Utils.ResxValueAttribute.#ctor(System.String,System.String)">
            <summary>
            快速构造函数
            </summary>
            <param name="resxId">资源标识</param>
            <param name="resxValue">资源内容</param>
        </member>
        <member name="P:Comm.Utils.ResxValueAttribute.Id">
            <summary>
            资源标识
            </summary>
        </member>
        <member name="P:Comm.Utils.ResxValueAttribute.Value">
            <summary>
            资源内容
            </summary>
        </member>
        <member name="T:Comm.Utils.ResxManager">
            <summary>
            多语系资源管理类
            </summary>
        </member>
        <member name="M:Comm.Utils.ResxManager.#cctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:Comm.Utils.ResxManager.CurrentLanguageType">
            <summary>
            获取当前 语言类型
            </summary>
        </member>
        <member name="P:Comm.Utils.ResxManager.CurrentLanguageFont">
            <summary>
            当前语系对应字体
            </summary>
        </member>
        <member name="P:Comm.Utils.ResxManager.CurrentLanguageName">
            <summary>
            获取当前的语系名称
            </summary>
        </member>
        <member name="E:Comm.Utils.ResxManager.LanguageChanged">
            <summary>
            此事件为弱事件，无须反注册
            </summary>
        </member>
        <member name="M:Comm.Utils.ResxManager.GetString_Resc(System.Object,System.Globalization.CultureInfo)">
            <summary>
            获取Resc
            </summary>
            <param name="resxEnumId"></param>
            <param name="culture"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ResxManager.GetEnumFullName(System.Type)">
            <summary>
            获取类型完整名
            </summary>
            <param name="enumType"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ResxManager.LoadEnumItemsResx(System.Type,System.Globalization.CultureInfo)">
            <summary>
            LoadEnumItemsResx
            </summary>
            <param name="enumType"></param>
            <param name="culture"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ResxManager.EscpeString(System.String)">
            <summary>
            EscpeString
            </summary>
            <param name="org"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ResxManager.GetLanguageName(Comm.Utils.LanguageType)">
            <summary>
            GetLanguageName
            </summary>
            <param name="lang"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ResxManager.GetString(System.Object)">
            <summary>
            获取指定枚举资源的对应语系信息，默认获取当前线程语系.
            </summary>
            <param name="resxEnumId"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ResxManager.GetString(System.Object,System.Globalization.CultureInfo)">
            <summary>
            获取指定语系的枚举资源的信息
            </summary>
            <param name="resxEnumId"></param>
            <param name="culture"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ResxManager.ChangeLanguage(Comm.Utils.LanguageType)">
            <summary>
            转换语言
            </summary>
            <param name="lang">要转换的语言类开</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:Comm.Utils.SysResxString">
            <summary>
            资源字串定义枚举
            </summary>
        </member>
        <member name="T:Comm.Utils.ISerializer`1">
            <summary>
             A typed serializer facade for more efficient and unified serialization against different Formatters.
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>    
        </member>
        <member name="M:Comm.Utils.ISerializer`1.CreateInstance">
            <summary>
            Creates a new instance of TType
            </summary>
            <returns>Newly created instance</returns>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Deserialize(System.String,System.Boolean)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="fileName">The file that contains the data to deserialize.</param>
            <param name="throwIfFileDoesNotExists">True to throw a <see cref="T:System.IO.FileNotFoundException"/> if the file dos not exists, False to create a new instance of TType.</param>
            <returns>The top object of the deserialized graph (root).</returns>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Deserialize(System.String,System.Boolean,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="fileName">The file that contains the data to deserialize.</param>
            <param name="throwIfFileDoesNotExists">True to throw a <see cref="T:System.IO.FileNotFoundException"/> if the file dos not exists, False to create a new instance of TType.</param>
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm</param>
            <returns>The top object of the deserialized graph (root).</returns>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="stream">The stream that contains the data to deserialize.</param>        
            <returns>The top object of the deserialized graph (root).</returns>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Deserialize(System.IO.Stream,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="stream">The stream that contains the data to deserialize.</param> 
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm. Can be null</param>
            <returns>The top object of the deserialized graph (root).</returns>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Deserialize(System.String)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="strBuffer">The string that contains the data to deserialize.</param>
            <returns>The top object of the deserialized graph (root).</returns>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Deserialize(System.String,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="strBuffer">The string that contains the data to deserialize.</param>
            <returns>The top object of the deserialized graph (root).</returns>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Serialize(System.String,`0)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="fileName">The file where the formatter puts the serialized data.</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Serialize(System.String,`0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="fileName">The file where the formatter puts the serialized data.</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm. Can be null</param>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Serialize(System.IO.Stream,`0)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="stream"> The stream where the formatter puts the serialized data. This stream can reference a variety of backing stores (such as files, network, memory, and so on).</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Serialize(System.IO.Stream,`0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="stream"> The stream where the formatter puts the serialized data. This stream can reference a variety of backing stores (such as files, network, memory, and so on).</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm.</param>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Serialize(`0)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <returns>return serialize string</returns>
        </member>
        <member name="M:Comm.Utils.ISerializer`1.Serialize(`0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <param name="symmetricAlgorithm"></param>
            <returns>return serialize string</returns>
        </member>
        <member name="T:Comm.Utils.ISerializerCallback">
            <summary>
            Indicates that a class is to be notified when serialization/deserialization has been completed.
            </summary>
        </member>
        <member name="M:Comm.Utils.ISerializerCallback.Serializing">
            <summary>
            Called before serializing the type
            </summary>
        </member>
        <member name="M:Comm.Utils.ISerializerCallback.Serialized">
            <summary>
            Called after serializing the type.
            </summary>
        </member>
        <member name="M:Comm.Utils.ISerializerCallback.Deserialized">
            <summary>
            Called after deserializing the type.
            </summary>
        </member>
        <member name="T:Comm.Utils.ISerializerFormatter">
            <summary>
            Provides functionality for formatting serialized objects.
            </summary>
        </member>
        <member name="M:Comm.Utils.ISerializerFormatter.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="stream"> The stream where the formatter puts the serialized data. This stream can reference a variety of backing stores (such as files, network, memory, and so on).</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
        </member>
        <member name="M:Comm.Utils.ISerializerFormatter.Deserialize(System.IO.Stream,System.Type[])">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="stream">The stream that contains the data to deserialize.</param>
            <param name="extraTypes"></param>
            <returns>The top object of the deserialized graph (root).</returns>
        </member>
        <member name="T:Comm.Utils.SerializerException">
            <summary>
            Represents errors occured during (de)serializing execution
            </summary>        
        </member>
        <member name="M:Comm.Utils.SerializerException.#ctor">
            <summary>
            Initializes a new instance of the SerializerException class.
            </summary>
        </member>
        <member name="M:Comm.Utils.SerializerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SerializerException class.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Comm.Utils.SerializerException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SerializerException class.
            </summary>
            <param name="message"></param>
            <param name="inner"></param>
        </member>
        <member name="M:Comm.Utils.SerializerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the SerializerException class with serialized data.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Comm.Utils.CustomXmlFormatter">
            <summary>
            The <see cref="T:Comm.Utils.AXmlFormatter"/> class implements a custom XmlFormatter
            which uses the <see cref="T:System.Runtime.Serialization.ISerializable"/> interace. 
            The class implements the <see cref="T:System.Runtime.Serialization.IFormatter"/> interface to serialize
            and deserialize the object to an XML representation.
            </summary>
            <remarks>
            The class calls the methods of ISerializable on the object if the object
            supports this interface. If not, the class will use Reflection to examine the public
            fields and properties of the object.<br/>
            When adding objects that inherit or implement IList, ICollection, the 
            elements of the list should be passed as an array to <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.
            </remarks>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter._context">
            <summary>
            The context in which this formatter performs his work.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter._binder">
            <summary>
            The serialization binder used to map object types to names.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter._selector">
            <summary>
            The surrogate selector to select the object that will perform the serialization.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter._type">
            <summary>
            The System.Type to serialize or deserialize.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter._deserializationCallbackList">
            <summary>
            Contains a list with objects that implement the IDeserializationCallback interface.
            </summary>
        </member>
        <member name="P:Comm.Utils.CustomXmlFormatter.Binder">
            <summary>
            Gets or sets the type binder.
            </summary>
        </member>
        <member name="P:Comm.Utils.CustomXmlFormatter.Context">
            <summary>
            Gets or sets the StreamingContext.
            </summary>
        </member>
        <member name="P:Comm.Utils.CustomXmlFormatter.SurrogateSelector">
            <summary>
            Gets or sets the SurrogateSelector.
            </summary>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.#ctor(System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="objectType"></param>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serializes the passed object to the passed stream.
            </summary>
            <param name="serializationStream">The stream to serialize to.</param>
            <param name="objectToSerialize">The object to serialize.</param>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes an object from the passed stream.
            </summary>
            <param name="serializationStream">The stream to deserialize the object from.</param>
            <returns>The deserialized object.</returns>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.Serialize(System.Xml.XmlTextWriter,System.Runtime.Serialization.FormatterConverter,System.String,System.Object,System.Type)">
            <summary>
            Serializes the object using the passed XmlWriter.
            </summary>
            <param name="writer">The XmlWriter to write to.</param>
            <param name="converter">The converter to use when converting simple types.</param>
            <param name="elementName">The name of the element in the Xml.</param>
            <param name="objectToSerialize">The object to serialize.</param>
            <param name="objectType">The type of the object.</param>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.WriteAttributes(System.Xml.XmlTextWriter,System.Type,System.Boolean)">
            <summary>
            Writes the Type and includeArrayAttribute attributes to the element
            </summary>
            <param name="writer">The XmlWriter to write to.</param>
            <param name="objectType">The type of the object.</param>
            <param name="includeArrayAttribute">Indicates whether to write the isArray attribute.</param>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.WriteValueElement(System.Xml.XmlTextWriter,Comm.Utils.CustomXmlFormatter.CustomSerializationEntry)">
            <summary>
            Writes a simple element to the writer. The name of the element is the name of the object type.
            </summary>
            <param name="writer">The XmlWriter to write to.</param>
            <param name="entry">The entry to write to the element.</param>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.WriteValueElement(System.String,System.Xml.XmlTextWriter,Comm.Utils.CustomXmlFormatter.CustomSerializationEntry)">
            <summary>
            Writes a simple element to the writer. 
            </summary>
            <param name="tagName">The name of the tag to write.</param>
            <param name="writer">The XmlWriter to write to.</param>
            <param name="entry">The entry to write to the element.</param>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.GetMemberInfo(System.Object,System.Type,System.Runtime.Serialization.FormatterConverter)">
            <summary>
            Gets all the serializable members of an object and return an enumarable collection.
            </summary>
            <param name="objectToSerialize">The object to get the members from.</param>
            <param name="objectToSerializeType">The type of the object.</param>
            <param name="converter">The converter to use when converting simple types.</param>
            <returns>An IEnumerable list of <see cref="T:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry"/> entries.</returns>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.CanSerialize(System.Reflection.MemberInfo)">
            <summary>
            Determines if the passed member is public and writable.
            </summary>
            <param name="member">The member to investigate.</param>
            <returns>True if public and writable, False if not.</returns>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.GetMemberValue(System.Object,System.Reflection.MemberInfo)">
            <summary>
            Get the value of a member.
            </summary>
            <param name="item">The item to get the member from.</param>
            <param name="member">The member to get the value from.</param>
            <returns>The value of the member.</returns>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.Deserialize(System.IO.Stream,System.Type)">
            <summary>
            Deserializes an object from the given stream for the given type.
            </summary>
            <param name="serializationStream">The stream to read the object from.</param>
            <param name="objectType">The type of object to create.</param>
            <returns>The deserialized object.</returns>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.InitializeObject(System.Xml.XmlTextReader,System.Runtime.Serialization.FormatterConverter,System.Type)">
            <summary>
            Reads an object from the XML and initializes the object.
            </summary>
            <param name="reader">The XmlReader to read from.</param>
            <param name="converter">The converter used to parse the values from the XML.</param>
            <param name="objectType">The type of the object to create.</param>
            <returns>The recreated object.</returns>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.PopulateSerializationInfo(System.Xml.XmlTextReader,System.Runtime.Serialization.FormatterConverter,System.Type,System.Runtime.Serialization.SerializationInfo)">
            <summary>
            Populates the serialized members in the SerializationInfo.
            </summary>
            <param name="reader">The XmlReader to read from.</param>
            <param name="converter">The converter used to parse the values from the XML.</param>
            <param name="actualType">The type of the object to create.</param>
            <param name="info">The object to populate.</param>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.DetermineValue(System.Xml.XmlTextReader,System.Runtime.Serialization.FormatterConverter,System.Type)">
            <summary>
            Determines the value of an object.
            </summary>
            <param name="reader">The XML reader the read from.</param>
            <param name="converter">The converter used to parse the values from the XML.</param>
            <param name="objectType">The type of the object to create.</param>
            <returns>The value of the object.</returns>
        </member>
        <member name="T:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry">
            <summary>
            The <see cref="T:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry"/> mimics the <see cref="T:System.Runtime.Serialization.SerializationEntry"/> class
            to make it possible to create are own entries. The class acts as a placeholder for a type,
            it's name and it's value. This class is used in the <see cref="T:Comm.Utils.AXmlFormatter"/> class to 
            serialize objects.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry._name">
            <summary>
            The name of the object.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry._objectType">
            <summary>
            The type of the object.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry._value">
            <summary>
            The value of the object.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry._isList">
            <summary>
            Indicates whether the object is a list.
            </summary>
        </member>
        <member name="P:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry.Name">
            <summary>
            Gets the name of the object.
            </summary>
        </member>
        <member name="P:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry.ObjectType">
            <summary>
            Gets the System.Type of the object.
            </summary>
        </member>
        <member name="P:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry.Value">
            <summary>
            Gets or sets the value contained in the object.
            </summary>
        </member>
        <member name="P:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry.IsList">
            <summary>
            Gets or sets whether the object is a list type.
            </summary>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry.#ctor(System.String,System.Type,System.Boolean)">
            <summary>
            Constructor to create a <see cref="T:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry"/> without a value. 
            Value is set to null.
            </summary>
            <param name="name">The name of the object.</param>
            <param name="objectType">The System.Type of the object.</param>
            <param name="isList">Indicates whether the object is a list type.</param>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry.#ctor(System.String,System.Type,System.Boolean,System.Object)">
            <summary>
            Constructor to create a <see cref="T:Comm.Utils.CustomXmlFormatter.CustomSerializationEntry"/>. 
            </summary>
            <param name="name">The name of the object.</param>
            <param name="objectType">The System.Type of the object.</param>
            <param name="isList">Indicates whether the object is a list type.</param>
            <param name="value">The value of the object.</param>
        </member>
        <member name="T:Comm.Utils.CustomXmlFormatter.CustomBinder">
            <summary>
            The <see cref="T:Comm.Utils.CustomXmlFormatter.CustomBinder"/> class performs the mapping to types
            declared in this assembly. It accumulates all types defined in the assembly
            this class is defined in. Optionally, an assembly can be passed as an argument.
            </summary>
        </member>
        <member name="F:Comm.Utils.CustomXmlFormatter.CustomBinder._typeList">
            <summary>
            The list that holds the types and type names contained in the assembly.
            </summary>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.CustomBinder.#cctor">
            <summary>
            Static constructor to load a list of types contained in the assembly
            only once (during the first call).
            </summary>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.CustomBinder.LoadTypes(System.Reflection.Assembly)">
            <summary>
            Loads the types from the passed assembly in the list. The key of the list
            is the simple name of the type.
            </summary>
            <param name="assembly"></param>
            <remarks>
            Because the list uses the simple name of the type, it should be unique within the 
            assembly. Otherwise, a <see cref="T:System.ArgumentException"/> is thrown.
            </remarks>
            <returns>A Dictionary{string, Type} object.</returns>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.CustomBinder.BindToType(System.String,System.String)">
            <summary>
            Binds the passed typename to the type contained in the dictionary.
            </summary>
            <param name="assemblyName">The assembly to load the type from.</param>
            <param name="typeName">The simple name of the type.</param>
            <remarks>
            When the passed type is not found in the assembly, the method will try 
            to get the Type using System.GetType. If still not found, the method will
            return typeof (Object).
            </remarks>
            <returns>The Type reference of the type name.</returns>
        </member>
        <member name="M:Comm.Utils.CustomXmlFormatter.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="T:Comm.Utils.AXmlFormatter">
            <summary>
            Serializes and deserializes objects into and from XML documents. The System.Xml.Serialization.XmlSerializer enables you to control how objects are encoded into XML.
            </summary>
        </member>
        <member name="T:Comm.Utils.ABinaryFormatter">
            <summary>
            Serializes and deserializes an object, or an entire graph of connected objects, in binary format.
            </summary>
        </member>
        <member name="P:Comm.Utils.ABinaryFormatter.Formatter">
            <summary>
            Gets the formatter instance
            </summary>
        </member>
        <member name="T:Comm.Utils.Serializer`2">
            <summary>
            A typed serializer for more efficient (compressed, encrypted) and unified (formatters, callbacks) serialization.
            </summary>
            <seealso cref="T:Comm.Utils.SerializerFactory"/>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <typeparam name="TSerializerFormatter">The ISerializerFormatter that is used to serialize</typeparam>    
            <example>
            In the following example, the type DataStore is binary serialized and deserialized to the disk in deflate (compressed mode) 
            <code>
            System.Security.Cryptography.SymmetricAlgorithm symAlgo = System.Security.Cryptography.Rijndael.Create();
            //               
            // formatter: xml
            // compression: gzip 
            // crypto: Rijndael
            ISerializer<![CDATA[<DataStore>]]>xmlGzip = SerializerFactory.CreateXmlSerializerGZip<![CDATA[<DataStore>]]>();
            Console.WriteLine(xmlGzip);
            //
            DataStore dataStore = xmlGzip.CreateInstance();
            dataStore.Name = "HDD";
            dataStore.Location = "IsolatedStorage";
            //
            xmlGzip.Serialize("datastore.gip", dataStore, symAlgo);                      
            dataStore = xmlGzip.Deserialize("datastore.gip", true, symAlgo);                
            // formatter: xml
            // compression: deflate
            // crypto: Rijndael
            ISerializer<![CDATA[<DataStore>]]> xmlDeflate = SerializerFactory.CreateXmlSerializerDeflate<![CDATA[<DataStore>]]>();
            Console.WriteLine(xmlDeflate);
            xmlDeflate.Serialize("datastore.def", dataStore, symAlgo);
            dataStore = xmlDeflate.Deserialize("datastore.def", true, symAlgo);
            // Formatter: binary
            // compression: none
            // crypto: none
            ISerializer<![CDATA[<DataStore>]]> binary = SerializerFactory.CreateBinarySerializer<![CDATA[<DataStore>]]>();
            Console.WriteLine(binary);
            binary.Serialize("datastore.bin", dataStore);
            dataStore = binary.Deserialize("datastore.bin", true);
            // formatter: soap
            // compression: deflate
            // crypto: Rijndael
            ISerializer<![CDATA[<DataStore>]]> soapDeflate = SerializerFactory.CreateSoapSerializerGZip<![CDATA[<DataStore>]]>();
            Console.WriteLine(soapDeflate);
            soapDeflate.Serialize("datastore.soap", dataStore, symAlgo);
            dataStore = soapDeflate.Deserialize("datastore.soap", true, symAlgo);
            //
            System.Diagnostics.Debug.Assert(dataStore.Location == "IsolatedStorage");
            System.Diagnostics.Debug.Assert(dataStore.Name == "HDD");
            </code>
            </example>
            <remarks>
            You still need to pay attention to decorate the types you wish to serialize with the formatter specific requirements like attributes or interface implementations.
            This serializer implementation does not adress issues and limitations caused by underlying formatters
            </remarks>
        </member>
        <member name="M:Comm.Utils.Serializer`2.#ctor(Comm.Utils.CompressionAlgorithm)">
            <summary>
            Initialize a new instance of the Serializer class
            </summary>
            <param name="compression">Compression algorithm</param>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Serialize(System.IO.Stream,System.Boolean,`0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="stream"> The stream where the formatter puts the serialized data. This stream can reference a variety of backing stores (such as files, network, memory, and so on).</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.CreateInstance">
            <summary>
            Creates a new instance of TType
            </summary>
            <returns>Newly created instance</returns>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Serialize(System.String,`0)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="fileName">The file where the formatter puts the serialized data.</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Serialize(System.String,`0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="fileName">The file where the formatter puts the serialized data.</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Serialize(System.IO.Stream,`0)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="stream"> The stream where the formatter puts the serialized data. This stream can reference a variety of backing stores (such as files, network, memory, and so on).</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Serialize(System.IO.Stream,`0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="stream"> The stream where the formatter puts the serialized data. This stream can reference a variety of backing stores (such as files, network, memory, and so on).</param>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Serialize(`0)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <returns>return serialize string</returns>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Serialize(`0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes an object, or graph of objects with the given root to the provided stream.
            </summary>
            <param name="instance">The object, or root of the object graph, to serialize. All child objects of this root object are automatically serialized.</param>
            <param name="symmetricAlgorithm"></param>
            <returns>return serialize string</returns>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Deserialize(System.String,System.Boolean)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="fileName">The file that contains the data to deserialize.</param>
            <param name="throwIfFileDoesNotExists">True to throw a <see cref="T:System.IO.FileNotFoundException"/> if the file dos not exists, False to create a new instance of TType.</param>
            <returns>The top object of the deserialized graph (root).</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Deserialize(System.String,System.Boolean,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="fileName">The file that contains the data to deserialize.</param>
            <param name="throwIfFileDoesNotExists">True to throw a <see cref="T:System.IO.FileNotFoundException"/> if the file dos not exists, False to create a new instance of TType.</param>
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm</param>
            <returns>The top object of the deserialized graph (root).</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="stream">The stream that contains the data to deserialize.</param>        
            <returns>The top object of the deserialized graph (root).</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Deserialize(System.IO.Stream,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="stream">The stream that contains the data to deserialize.</param> 
            <param name="symmetricAlgorithm">Cryptographic object to perform the algorithm.</param>
            <returns>The top object of the deserialized graph (root).</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
            <exception cref="T:System.IO.IOException">Consult System.IO.FileStream documentation for more details.</exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Deserialize(System.String)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="strBuffer">The string that contains the data to deserialize.</param>
            <returns>The top object of the deserialized graph (root).</returns>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.Deserialize(System.String,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes the data on the provided stream and reconstitutes the graph of objects.
            </summary>
            <param name="strBuffer">The string that contains the data to deserialize.</param>
            <returns>The top object of the deserialized graph (root).</returns>
            <exception cref="T:Comm.Utils.SerializerException"></exception>
        </member>
        <member name="M:Comm.Utils.Serializer`2.ToString">
            <summary>        
            Creates and returns a string representation of the current serializer.
            </summary>
            <returns>A string representation of the current serializer.</returns>
        </member>
        <member name="M:Comm.Utils.Serializer`2.GetCompressionStream(System.IO.Stream,System.IO.Compression.CompressionMode)">
            <summary>
            Creates a suitable <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="stream"></param>
            <param name="cm"></param>
            <returns></returns>
        </member>
        <member name="P:Comm.Utils.Serializer`2.Formatter">
            <summary>
            Creates the formatter instance
            </summary>
        </member>
        <member name="T:Comm.Utils.CompressionAlgorithm">
            <summary>
            Defines the supported compression methods
            </summary>
        </member>
        <member name="F:Comm.Utils.CompressionAlgorithm.None">
            <summary>
            No compression
            </summary>
        </member>
        <member name="F:Comm.Utils.CompressionAlgorithm.GZip">
            <summary>
             Gzip data format, which uses an industry standard algorithm for lossless file compression and decompression. The format includes a cyclic redundancy check value for detecting data corruption. The gzip data format uses the same algorithm as the DeflateStream class, but can be extended to use other compression formats. The format can be readily implemented in a manner not covered by patents. The format for gzip is available from the RFC 1952, "GZIP file format specification 4.3." This class cannot be used to compress files larger than 4 GB.
            </summary>
        </member>
        <member name="F:Comm.Utils.CompressionAlgorithm.Deflate">
            <summary>
            Deflate algorithm, an industry standard algorithm for lossless file compression and decompression. It uses a combination of the LZ77 algorithm and Huffman coding. Data can be produced or consumed, even for an arbitrarily long, sequentially presented input data stream, using only previously bound amount of intermediate storage. The format can be implemented readily in a manner not covered by patents. For more information, see RFC 1951. "DEFLATE Compressed Data Format Specification version 1.3." This class cannot be used to compress files larger than 4 GB.
            </summary>
        </member>
        <member name="T:Comm.Utils.SerializerFactory">
            <summary>
            Creates typed versions of the ISerializer for more efficient (compressed, encrypted) and unified (formatters, callbacks) serialization.
            </summary>
            <example>
            In the following example, the type DataStore is binary serialized and deserialized to the disk in deflate (compressed mode) 
            <code>
            System.Security.Cryptography.SymmetricAlgorithm symAlgo = System.Security.Cryptography.Rijndael.Create();
            //               
            // formatter: xml
            // compression: gzip 
            // crypto: Rijndael
            ISerializer<![CDATA[<DataStore>]]>xmlGzip = SerializerFactory.CreateXmlSerializerGZip<![CDATA[<DataStore>]]>();
            Console.WriteLine(xmlGzip);
            //
            DataStore dataStore = xmlGzip.CreateInstance();
            dataStore.Name = "HDD";
            dataStore.Location = "IsolatedStorage";
            //
            xmlGzip.Serialize("datastore.gip", dataStore, symAlgo);                      
            dataStore = xmlGzip.Deserialize("datastore.gip", true, symAlgo);                
            // formatter: xml
            // compression: deflate
            // crypto: Rijndael
            ISerializer<![CDATA[<DataStore>]]> xmlDeflate = SerializerFactory.CreateXmlSerializerDeflate<![CDATA[<DataStore>]]>();
            Console.WriteLine(xmlDeflate);
            xmlDeflate.Serialize("datastore.def", dataStore, symAlgo);
            dataStore = xmlDeflate.Deserialize("datastore.def", true, symAlgo);
            // Formatter: binary
            // compression: none
            // crypto: none
            ISerializer<![CDATA[<DataStore>]]> binary = SerializerFactory.CreateBinarySerializer<![CDATA[<DataStore>]]>();
            Console.WriteLine(binary);
            binary.Serialize("datastore.bin", dataStore);
            dataStore = binary.Deserialize("datastore.bin", true);
            // formatter: soap
            // compression: deflate
            // crypto: Rijndael
            ISerializer<![CDATA[<DataStore>]]> soapDeflate = SerializerFactory.CreateSoapSerializerGZip<![CDATA[<DataStore>]]>();
            Console.WriteLine(soapDeflate);
            soapDeflate.Serialize("datastore.soap", dataStore, symAlgo);
            dataStore = soapDeflate.Deserialize("datastore.soap", true, symAlgo);
            //
            System.Diagnostics.Debug.Assert(dataStore.Location == "IsolatedStorage");
            System.Diagnostics.Debug.Assert(dataStore.Name == "HDD");
            </code>
            </example>
            <remarks>
            You still need to pay attention to decorate the types you wish to serialize with the formatter specific requirements like attributes or interface implementations.
            This serializer implementation does not adress issues and limitations caused by underlying formatters
            </remarks>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateXmlSerializer``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateXmlSerializerDeflate``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateXmlSerializerGZip``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateBinarySerializer``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateBinarySerializerDeflate``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateBinarySerializerGZip``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateCustomXmlSerializer``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateCustomXmlSerializerDeflate``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateCustomXmlSerializerZip``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateJsonSerializer``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateJsonSerializerDeflate``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="M:Comm.Utils.SerializerFactory.CreateJsonSerializerGZip``1">
            <summary>
            Creates a typed serializer for the given <seealso cref="T:System.Type"/>
            </summary>
            <typeparam name="TType">The <see cref="T:System.Type"/> of the object that gets serialized/deserialized.</typeparam>
            <returns>A typed serializer facade instance.</returns>
        </member>
        <member name="T:Comm.Utils.EnvironmentUtils">
            <summary>
            系统环境
            </summary>
        </member>
        <member name="M:Comm.Utils.EnvironmentUtils.#cctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:Comm.Utils.EnvironmentUtils.IsVsIdeEnv">
            <summary>
            获取是否在Vistual Studio设计期环境
            </summary>
        </member>
        <member name="P:Comm.Utils.EnvironmentUtils.IsVsHostEnv">
            <summary>
            获取是否在Vistual Studio宿主调试环境
            </summary>
        </member>
        <member name="P:Comm.Utils.EnvironmentUtils.IsSupportWpfEnv">
            <summary>
            判断是否支持WPF的运行环境
            </summary>
        </member>
        <member name="P:Comm.Utils.EnvironmentUtils.ServerDebugMode">
            <summary>
            是否为ServerDebug模式
            </summary>
        </member>
        <member name="P:Comm.Utils.EnvironmentUtils.ProgramIsExiting">
            <summary>
            程序已经处于退出状态
            </summary>
        </member>
        <member name="P:Comm.Utils.EnvironmentUtils.IsPreLoad">
            <summary>
            是否为预加载
            </summary>
        </member>
        <member name="P:Comm.Utils.EnvironmentUtils.IsCollectMemory">
            <summary>
            获取或设置是否要回收内存 true 表示需要，false 表示不需要
            </summary>
        </member>
        <member name="M:Comm.Utils.EnvironmentUtils.CheckInitializeEnv">
            <summary>
            检测环境
            </summary>
        </member>
        <member name="M:Comm.Utils.EnvironmentUtils.CollectMemory">
            <summary>
            回收内存
            </summary>
        </member>
        <member name="M:Comm.Utils.EnvironmentUtils.AsyncCollectMemory">
            <summary>
            异步执行回收内存
            </summary>
        </member>
        <member name="M:Comm.Utils.EnvironmentUtils.SwitchCpuExec">
            <summary>
            切换当前CPU执行片段，默认为50毫秒，来解决背景线程CPU占用100%的问题
            </summary>
        </member>
        <member name="M:Comm.Utils.EnvironmentUtils.SwitchCpuExec(System.Int32)">
            <summary>
            切换当前CPU执行片段
            </summary>
            <param name="milliseconds">交换的时间片段</param>
        </member>
        <member name="T:Comm.Utils.StringUtils">
            <summary>
            字符串处理函数
            </summary>
        </member>
        <member name="M:Comm.Utils.StringUtils.SubReplaceStr(System.String,System.Int32,System.Int32)">
            <summary>
            区字符串固定长度，其余的省略
            
            规则：
             1.如果startIndex大于字符串长度，则自动调整到取最后maxLangth长度。如果此时maxLangth长度比字符串长度还要大，那么startIndex回到0
             2.如果在startIndex基础上，取maxLangth长度大于比字符串长度,那么maxLangth自动取到可能的最大值，即从startIndex一直取到字符串末尾
             3.结果中，字符串只要有削减的地方，都以".."替代
            </summary>
            <param name="str">原字符串</param>
            <param name="startIndex">起始字符串位置</param>
            <param name="maxLangth">最长字符个数</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.IncludeTrailingPathDelimiter(System.String)">
            <summary>
            returns the path with a PathDelimiter
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.IncludeTrailingPathDelimiter(System.String,System.Boolean)">
            <summary>
            returns the path with a PathDelimiter
            </summary>
            <param name="str"></param>
            <param name="createDir">目录不存在是否创建</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.ExcludeTrailingPathDelimiter(System.String)">
            <summary>
            returns the path without a PathDelimiter
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.GetRelativePath(System.String,System.String)">
            <summary>
            获取路径2相对于路径1的相对路径
            </summary>
            <param name="strPath1">路径1</param>
            <param name="strPath2">路径2</param>
            <returns>返回路径2相对于路径1的路径</returns>
            <example>
            string strPath = GetRelativePath(@"C:\WILibOWS\system32", @"C:\WILibOWS\system\*.*" );
            //strPath == @"..\system\*.*"
            </example>
        </member>
        <member name="M:Comm.Utils.StringUtils.QuoteStr(System.String,System.String)">
            <summary>
            添加引号
            </summary>
            <param name="str"></param>
            <param name="quoteChar"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.PadLeftRight(System.String,System.String)">
            <summary>
            填补字符串左边和右边指定的字符
            </summary>
            <param name="str"></param>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.ByteArrayToHexStr(System.Byte[])">
            <summary>
            字节数组转换为十六进制标识的字串， 可供直接下语法使用
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.ByteArrayToHexStr(System.Byte[],System.Boolean)">
            <summary>
            字节数组转换为十六进制标识的字串， 可供直接下语法使用
            </summary>
            <param name="bytes"></param>
            <param name="addOx">是否自动添加0x的前导</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.HexStrToByteArray(System.String)">
            <summary>
            十六进制标识的字串转换为字节数组
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.GBLength(System.String)">
            <summary>
            获取GB2312编码长度
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.Chop(System.String,System.Int32)">
            <summary>
            Strips the last specified chars from a string.
            </summary>
            <param name="sourceString">The source string.</param>
            <param name="removeFromEnd">The remove from end.</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.Chop(System.String,System.String)">
            <summary>
            Strips the last specified chars from a string.
            </summary>
            <param name="sourceString">The source string.</param>
            <param name="backDownTo">The back down to.</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.ndTrimStart(System.String,System.String[])">
            <summary>
            从此实例的结尾移除数组中第一个匹配的项（一次）
            </summary>
            <param name="text">字符串</param>
            <param name="args">要移除的字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.ndTrimEnd(System.String,System.String[])">
            <summary>
            将字符的右边移除掉指定的字符（一次）
            </summary>
            <param name="text">字符串</param>
            <param name="args">要移除的字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.PhoneNumberFormat(System.String,System.Boolean)">
            <summary>
            电话号码格式化
            </summary>
            <param name="tel">电话号码</param>
            <param name="TrimPrefixion">是否去除特殊号</param>
            <returns>格式化后的电话号码</returns> 
        </member>
        <member name="M:Comm.Utils.StringUtils.PhoneNumberFormat(System.String)">
            <summary>
            电话号码格式化
            </summary>
            <param name="tel">电话号码</param> 
            <returns>格式化后的电话号码</returns>
            <remarks>不去除特殊号</remarks>
        </member>
        <member name="M:Comm.Utils.StringUtils.PhoneNumberFormatXing(System.String)">
            <summary>
            电话号码格式化
            </summary>
            <param name="tel">电话号码</param>
            <param name="TrimPrefixion">是否去除特殊号</param>
            <returns>格式化后的电话号码</returns> 
        </member>
        <member name="M:Comm.Utils.StringUtils.GetShortString(System.String)">
            <summary>
            获取字符串的缩略长度，将超出长度的字符串用...表示
            </summary>
            <param name="value">字符串</param>
            <returns>缩略的字符串</returns>
            <remarks></remarks>
        </member>
        <member name="M:Comm.Utils.StringUtils.GetShortString(System.String,System.Int32)">
            <summary>
            获取字符串的缩略长度，将超出长度的字符串用...表示
            </summary>
            <param name="value">字符串</param>
            <param name="maxLength">最大长度</param>
            <returns>缩略的字符串</returns>
            <remarks></remarks>
        </member>
        <member name="M:Comm.Utils.StringUtils.GetShortString(System.String,System.Int32,System.Int32)">
            <summary>
            获取字符串的缩略长度，将超出长度的字符串用...表示
            </summary>
            <param name="value">字符串</param>
            <param name="maxLength">最大长度</param>
            <param name="rightPaddingLength">右边保留字符长度</param>
            <returns>缩略的字符串</returns>
            <remarks></remarks>
        </member>
        <member name="M:Comm.Utils.StringUtils.ReplaceSQL(System.String)">
            <summary>
            字符串sql合法化处理
            </summary>
            <param name="pstrSQL"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.GetValue``1(System.Object,System.Object)">
            <summary>
            获取类型转换后的值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="DBData"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringUtils.IsNullOrWhiteSpace(System.String)">
            <summary>
            指示指定的字符串是 null、空还是仅由空白字符组成（string类在Net4.0以上已具备该方法）
            </summary>
            <param name="value">要检测的字符串</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.TraceDumper">
            <summary>
            This class is used to build the dump strings for verious .NET objects.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceDumper.GetCallingMethod(System.Diagnostics.StackFrame)">
            <summary>
            Get the formated string of the filename and
            </summary>
            <param name="stackFrame">The stack frame the represents the calling point on the stack</param>
            <returns>A string with the filename and the line number of the calling method</returns>
        </member>
        <member name="M:Comm.Utils.TraceDumper.BuildDumpException(System.Int32,System.Exception,System.String,System.Object[])">
            <summary>
            Dumps the exception to the debug stream.
            </summary>
            <param name="level">Stack level of the source code</param>
            <param name="e">The exception to dump.</param>
            <param name="messageFormat">A message to display containing zero or more format items.</param>
            <param name="args">An object array containing zero or more objects to format.</param>
            <returns>A string with all the object information in it.</returns>
        </member>
        <member name="M:Comm.Utils.TraceDumper.BuildDumpWebRequest(System.Web.HttpRequest)">
            <summary>
            Dumps the web request
            </summary>
            <param name="request">The request to dump.</param>
            <returns>A string with all the object information in it.</returns>
        </member>
        <member name="M:Comm.Utils.TraceDumper.BuildDumpWebResponse(System.Web.HttpResponse)">
            <summary>
            Dumps the web response 
            </summary>
            <param name="response">The response to dump.</param>
            <returns>A string with all the object information in it.</returns>
        </member>
        <member name="T:Comm.Utils.PROCESSENTRY32">
            <summary>
            用来存放快照进程信息的一个结构体
            </summary>
        </member>
        <member name="T:Comm.Utils.SystemMetric">
            <summary>
            Flags used with the Windows API GetSystemMetrics(SystemMetric smIndex)
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXSCREEN">
            <summary>
             Width of the screen of the primary display monitor, in pixels. 
            This is the same values obtained by calling GetDeviceCaps as 
            follows: GetDeviceCaps( hdcPrimaryMonitor, HORZRES).
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYSCREEN">
            <summary>
            Height of the screen of the primary display monitor, in pixels. 
            This is the same values obtained by calling GetDeviceCaps as 
            follows: GetDeviceCaps( hdcPrimaryMonitor, VERTRES).
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYVSCROLL">
            <summary>
            Width of a horizontal scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXVSCROLL">
            <summary>
            Height of a horizontal scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYCAPTION">
            <summary>
            Height of a caption area, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXBORDER">
            <summary>
            Width of a window border, in pixels. This is equivalent to the
            SM_CXEDGE value for windows with the 3-D look. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYBORDER">
            <summary>
            Height of a window border, in pixels. This is equivalent to the 
            SM_CYEDGE value for windows with the 3-D look. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXDLGFRAME">
            <summary>
            Thickness of the frame around the perimeter of a window that has
            a caption but is not sizable, in pixels. SM_CXFIXEDFRAME is the
            height of the horizontal border and SM_CYFIXEDFRAME is the width
            of the vertical border. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYDLGFRAME">
            <summary>
            Thickness of the frame around the perimeter of a window that has
            a caption but is not sizable, in pixels. SM_CXFIXEDFRAME is the
            height of the horizontal border and SM_CYFIXEDFRAME is the width
            of the vertical border. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYVTHUMB">
            <summary>
            Height of the thumb box in a vertical scroll bar, in pixels
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXHTHUMB">
            <summary>
            Width of the thumb box in a horizontal scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXICON">
            <summary>
            Default width of an icon, in pixels. The LoadIcon function can 
            load only icons with the dimensions specified by SM_CXICON and
            SM_CYICON
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYICON">
            <summary>
            Default height of an icon, in pixels. The LoadIcon function can 
            load only icons with the dimensions SM_CXICON and SM_CYICON.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXCURSOR">
            <summary>
            Width of a cursor, in pixels. The system cannot create 
            cursors of other sizes.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYCURSOR">
            <summary>
            Height of a cursor, in pixels. The system cannot create cursors
             of other sizes.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMENU">
            <summary>
            Height of a single-line menu bar, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXFULLSCREEN">
            <summary>
            Width of the client area for a full-screen window on the primary
            display monitor, in pixels. To get the coordinates of the portion 
            of the screen not obscured by the system taskbar or by application 
            desktop toolbars, call the SystemParametersInfo function with the
            SPI_GETWORKAREA value.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYFULLSCREEN">
            <summary>
            Height of the client area for a full-screen window on the primary
            display monitor, in pixels. To get the coordinates of the portion
            of the screen not obscured by the system taskbar or by application
            desktop toolbars, call the SystemParametersInfo function with the
            SPI_GETWORKAREA value.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYKANJIWINDOW">
            <summary>
            For double byte character set versions of the system, this is the
            height of the Kanji window at the bottom of the screen, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_MOUSEWHEELPRESENT">
            <summary>
            Nonzero if a mouse with a wheel is installed; zero otherwise
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYHSCROLL">
            <summary>
            Height of the arrow bitmap on a vertical scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXHSCROLL">
            <summary>
            Width of the arrow bitmap on a horizontal scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_DEBUG">
            <summary>
            Nonzero if the debug version of User.exe is installed; zero
            otherwise.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_SWAPBUTTON">
            <summary>
            Nonzero if the left and right mouse buttons are reversed; zero
            otherwise.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_RESERVED1">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_RESERVED2">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_RESERVED3">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_RESERVED4">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXMIN">
            <summary>
            Minimum width of a window, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMIN">
            <summary>
            Minimum height of a window, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXSIZE">
            <summary>
            Width of a button in a window's caption or title bar, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYSIZE">
            <summary>
            Height of a button in a window's caption or title bar, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXFRAME">
            <summary>
            Thickness of the sizing border around the perimeter of a window 
            that can be resized, in pixels. SM_CXSIZEFRAME is the width of the
            horizontal border, and SM_CYSIZEFRAME is the height of the
            vertical border. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYFRAME">
            <summary>
            Thickness of the sizing border around the perimeter of a window 
            that can be resized, in pixels. SM_CXSIZEFRAME is the width of the
            horizontal border, and SM_CYSIZEFRAME is the height of the 
            vertical border. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXMINTRACK">
            <summary>
            Minimum tracking width of a window, in pixels. The user cannot drag
            the window frame to a size smaller than these dimensions. A window
            can override this value by processing the WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMINTRACK">
            <summary>
            Minimum tracking height of a window, in pixels. The user cannot 
            drag the window frame to a size smaller than these dimensions. A 
            window can override this value by processing the WM_GETMINMAXINFO
            message
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXDOUBLECLK">
            <summary>
            Width of the rectangle around the location of a first click in a 
            double-click sequence, in pixels. The second click must occur 
            within the rectangle defined by SM_CXDOUBLECLK and SM_CYDOUBLECLK 
            for the system to consider the two clicks a double-click
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYDOUBLECLK">
            <summary>
            Height of the rectangle around the location of a first click in a
            double-click sequence, in pixels. The second click must occur 
            within the rectangle defined by SM_CXDOUBLECLK and SM_CYDOUBLECLK
            for the system to consider the two clicks a double-click. (The two
            clicks must also occur within a specified time.) 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXICONSPACING">
            <summary>
            Width of a grid cell for items in large icon view, in pixels. Each
            item fits into a rectangle of size SM_CXICONSPACING by 
            SM_CYICONSPACING when arranged. This value is always greater 
            than or equal to SM_CXICON
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYICONSPACING">
            <summary>
            Height of a grid cell for items in large icon view, in pixels. 
            Each item fits into a rectangle of size SM_CXICONSPACING by 
            SM_CYICONSPACING when arranged. This value is always greater than
            or equal to SM_CYICON.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_MENUDROPALIGNMENT">
            <summary>
            Nonzero if drop-down menus are right-aligned with the corresponding
            menu-bar item; zero if the menus are left-aligned.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_PENWINDOWS">
            <summary>
            Nonzero if the Microsoft Windows for Pen computing extensions are
            installed; zero otherwise.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_DBCSENABLED">
            <summary>
            Nonzero if User32.dll supports DBCS; zero otherwise. 
            (WinMe/95/98): Unicode
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CMOUSEBUTTONS">
            <summary>
            Number of buttons on mouse, or zero if no mouse is installed.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXFIXEDFRAME">
            <summary>
            Identical Values Changed After Windows NT 4.0  
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYFIXEDFRAME">
            <summary>
            Identical Values Changed After Windows NT 4.0
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXSIZEFRAME">
            <summary>
            Identical Values Changed After Windows NT 4.0
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYSIZEFRAME">
            <summary>
            Identical Values Changed After Windows NT 4.0
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_SECURE">
            <summary>
            Nonzero if security is present; zero otherwise.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXEDGE">
            <summary>
            Width of a 3-D border, in pixels. This is the 3-D counterpart 
            of SM_CXBORDER.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYEDGE">
            <summary>
            Height of a 3-D border, in pixels. This is the 3-D counterpart 
            of SM_CYBORDER.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXMINSPACING">
            <summary>
            Width of a grid cell for a minimized window, in pixels. Each 
            minimized window fits into a rectangle this size when arranged. 
            This value is always greater than or equal to SM_CXMINIMIZED.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMINSPACING">
            <summary>
            Height of a grid cell for a minimized window, in pixels. Each 
            minimized window fits into a rectangle this size when arranged. 
            This value is always greater than or equal to SM_CYMINIMIZED.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXSMICON">
            <summary>
            Recommended width of a small icon, in pixels. Small icons typically
            appear in window captions and in small icon view
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYSMICON">
            <summary>
            Recommended height of a small icon, in pixels. Small icons 
            typically appear in window captions and in small icon view.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYSMCAPTION">
            <summary>
            Height of a small caption, in pixels
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXSMSIZE">
            <summary>
            Width of small caption buttons, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYSMSIZE">
            <summary>
            Height of small caption buttons, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXMENUSIZE">
            <summary>
            Width of menu bar buttons, such as the child window close button
            used in the multiple document interface, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMENUSIZE">
            <summary>
            Height of menu bar buttons, such as the child window close button
            used in the multiple document interface, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_ARRANGE">
            <summary>
            Flags specifying how the system arranged minimized windows
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXMINIMIZED">
            <summary>
            Width of a minimized window, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMINIMIZED">
            <summary>
            Height of a minimized window, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXMAXTRACK">
            <summary>
            Default maximum width of a window that has a caption and sizing 
            borders, in pixels. This metric refers to the entire desktop. The
            user cannot drag the window frame to a size larger than these 
            dimensions. A window can override this value by processing the 
            WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMAXTRACK">
            <summary>
            Default maximum height of a window that has a caption and sizing 
            borders, in pixels. This metric refers to the entire desktop. The
            user cannot drag the window frame to a size larger than these 
            dimensions. A window can override this value by processing the 
            WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXMAXIMIZED">
            <summary>
            Default width, in pixels, of a maximized top-level window on the
            primary display monitor.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMAXIMIZED">
            <summary>
            Default height, in pixels, of a maximized top-level window on the 
            primary display monitor.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_NETWORK">
            <summary>
            Least significant bit is set if a network is present; otherwise, 
            it is cleared. The other bits are reserved for future use
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CLEANBOOT">
            <summary>
            Value that specifies how the system was started: 0-normal, 
            1-failsafe, 2-failsafe /w net
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXDRAG">
            <summary>
            Width of a rectangle centered on a drag point to allow for limited
            movement of the mouse pointer before a drag operation begins, 
            in pixels. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYDRAG">
            <summary>
            Height of a rectangle centered on a drag point to allow for limited
            movement of the mouse pointer before a drag operation begins. This 
            value is in pixels. It allows the user to click and release the 
            mouse button easily without unintentionally starting a drag 
            operation.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_SHOWSOUNDS">
            <summary>
            Nonzero if the user requires an application to present information
            visually in situations where it would otherwise present the 
            information only in audible form; zero otherwise. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXMENUCHECK">
            <summary>
            Width of the default menu check-mark bitmap, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYMENUCHECK">
            <summary>
            Height of the default menu check-mark bitmap, in pixels.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_SLOWMACHINE">
            <summary>
            Nonzero if the computer has a low-end (slow) processor; 
            zero otherwise.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_MIDEASTENABLED">
            <summary>
            Nonzero if the system is enabled for Hebrew and Arabic languages,
            zero if not.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_MOUSEPRESENT">
            <summary>
            Nonzero if a mouse is installed; zero otherwise. This value is 
            rarely zero, because of support for virtual mice and because some 
            systems detect the presence of the port instead of the presence of
            a mouse.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_XVIRTUALSCREEN">
            <summary>
            Windows 2000 (v5.0+) Coordinate of the top of the virtual screen.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_YVIRTUALSCREEN">
            <summary>
            Windows 2000 (v5.0+) Coordinate of the left of the virtual screen.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXVIRTUALSCREEN">
            <summary>
            Windows 2000 (v5.0+) Width of the virtual screen.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYVIRTUALSCREEN">
            <summary>
            Windows 2000 (v5.0+) Height of the virtual screen.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CMONITORS">
            <summary>
            Number of display monitors on the desktop.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_SAMEDISPLAYFORMAT">
            <summary>
            Windows XP (v5.1+) Nonzero if all the display monitors have the 
            same color format, zero otherwise. Note that two displays can have
            the same bit depth, but different color formats. For example, the 
            red, green, and blue pixels can be encoded with different numbers
            of bits, or those bits can be located in different places in a 
            pixel's color value. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_IMMENABLED">
            <summary>
            Windows XP (v5.1+) Nonzero if Input Method Manager/Input Method 
            Editor features are enabled; zero otherwise.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CXFOCUSBORDER">
            <summary>
            Windows XP (v5.1+) Width of the left and right edges of the focus 
            rectangle drawn by DrawFocusRect. This value is in pixels. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CYFOCUSBORDER">
            <summary>
            Windows XP (v5.1+) Height of the top and bottom edges of the focus 
            rectangle drawn by DrawFocusRect. This value is in pixels. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_TABLETPC">
            <summary>
            Nonzero if the current operating system is the Windows XP Tablet PC 
            edition, zero if not.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_MEDIACENTER">
            <summary>
            Nonzero if the current operating system is the Windows XP, Media 
            Center Edition, zero if not.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CMETRICS_OTHER">
            <summary>
            Metrics Other
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CMETRICS_2000">
            <summary>
            Metrics Windows 2000
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_CMETRICS_NT">
            <summary>
            Metrics Windows NT
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_REMOTESESSION">
            <summary>
            Windows XP (v5.1+) This system metric is used in a Terminal 
            Services environment. If the calling process is associated with a 
            Terminal Services client session, the return value is nonzero. If 
            the calling process is associated with the Terminal Server console 
            session, the return value is zero. The console session is not 
            necessarily the physical console - see WTSGetActiveConsoleSessionId 
            for more information. 
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_SHUTTINGDOWN">
            <summary>
            Windows XP (v5.1+) Nonzero if the current session is shutting down; 
            zero otherwise.
            </summary>
        </member>
        <member name="F:Comm.Utils.SystemMetric.SM_REMOTECONTROL">
            <summary>
            Windows XP (v5.1+) This system metric is used in a Terminal 
            Services environment. Its value is nonzero if the current session 
            is remotely controlled; zero otherwise.
            </summary>
        </member>
        <member name="T:Comm.Utils.SessionHelper">
            <summary>
            对“WEB缓存”相关进行封装
            </summary>
        </member>
        <member name="M:Comm.Utils.SessionHelper.Get(System.String)">
            <summary>
            从 Session 读取 键为 name 的值
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.SessionHelper.Remove(System.String)">
            <summary>
             从 Session 删除 键为 name session 项
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Comm.Utils.SessionHelper.RemoveAll">
            <summary>
            删除所有 session 项
            </summary>
        </member>
        <member name="M:Comm.Utils.SessionHelper.Set(System.String,System.Object)">
            <summary>
            向 Session 保存 键为 name 的， 值为 value
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:Comm.Utils.SessionHelper.Set(System.String,System.Object,System.Int32)">
            <summary>
            向 Session 保存 键为 name 的， 值为 value
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <param name="timeOut">过期时间（分）</param>
        </member>
        <member name="T:Comm.Utils.CollectionHelper">
            <summary>
            集合辅助
            </summary>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.ActionOnEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            对集合中的每个元素执行action
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="collection"></param>
            <param name="action"></param>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.ActionOnSpecification``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Predicate{``0})">
            <summary>
            对集合中满足predicate条件的元素执行action。如果没有条件，predicate传入null。
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="collection"></param>
            <param name="action"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Int32@)">
            <summary>
            从已排序的列表中，采用二分查找找到目标在列表中的位置。
               如果刚好有个元素与目标相等，则返回true，且minIndex会被赋予该元素的位置；
               否则，返回false，且minIndex会被赋予比目标小且最接近目标的元素的位置
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sortedList"></param>
            <param name="target"></param>
            <param name="minIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            集合中是否包含满足predicate条件的元素。
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
            <summary>
            集合中是否包含满足predicate条件的元素。
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.Find``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            从集合中选取符合条件的元素
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.FindFirst``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            返回符合条件的第一个元素
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.GetPart``1(``0[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ary"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.GetPart``1(``0[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ary"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="reverse"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            检查集合是否是 null 或 empty
               true 为 null 或 empty 否则 为  false
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CollectionHelper.IsNullOrEmpty(System.Collections.ICollection)">
            <summary>
            检查集合是否是 null 或 empty
               true 为 null 或 empty 否则 为  false
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.CtrlHelper">
            <summary>
            控件辅助类
            </summary>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.GetCheckBoxValue(System.Web.UI.WebControls.CheckBox)">
            <summary>
             获取复选框选中值 byte
            </summary>
            <param name="chk"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.GetInt(System.Web.UI.Control,System.Int32)">
            <summary>
             获取控件 Int 参数值,ctrl 必须是文本控件
            </summary>
            <param name="ctrl"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.GetSelectValue(System.Web.UI.WebControls.DropDownList)">
            <summary>
            获取下拉列表值
            </summary>
            <param name="ddlList"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.GetSelectValue(System.Web.UI.WebControls.DropDownList,System.Byte)">
            <summary>
            获取下拉列表值
            </summary>
            <param name="ddlList"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.GetText(System.Web.UI.HtmlControls.HtmlInputControl)">
            <summary>
            获取控件文本内容
            </summary>
            <param name="valueCtrl"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.GetText(System.Web.UI.ITextControl)">
            <summary>
            获取控件文本内容
            </summary>
            <param name="textCtrl"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.GetText(System.Web.UI.WebControls.HiddenField)">
            <summary>
            获取控件文本内容
            </summary>
            <param name="hiddenCtrl"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.SetCheckBoxValue(System.Web.UI.WebControls.CheckBox,System.Byte)">
            <summary>
            设置复选框值
            </summary>
            <param name="chk"></param>
            <param name="val"></param>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.SetText(System.Web.UI.HtmlControls.HtmlInputControl,System.String)">
            <summary>
            为文本控件赋值
            </summary>
            <param name="valueCtrl"></param>
            <param name="text"></param>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.SetText(System.Web.UI.ITextControl,System.String)">
            <summary>
            为文本控件赋值
            </summary>
            <param name="textCtrl"></param>
            <param name="text"></param>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.SetText(System.Web.UI.WebControls.HiddenField,System.String)">
            <summary>
            为文本控件赋值
            </summary>
            <param name="hiddenCtrl"></param>
            <param name="text"></param>
        </member>
        <member name="M:Comm.Utils.CtrlHelper.SetText(System.Web.UI.WebControls.TextBox,System.String)">
            <summary>
            为文本控件赋值
            </summary>
            <param name="textCtrl"></param>
            <param name="text"></param>
        </member>
        <member name="T:Comm.Utils.ReflexHelper">
            <summary>
            反射执行方法，属性，事件 的帮助类
            </summary>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.#cctor">
            <summary>
            静态构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetAssemblies">
            <summary>
            取得所有的程序集
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetAssembly(System.String,System.Boolean)">
            <summary>
            取得程序集
            </summary>
            <param name="assemblyName"></param>
            <param name="currDomain">当前域</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetAssembly(System.String)">
            <summary>
            反射取得程序集
            </summary>
            <param name="assemblyFile"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetTypes(System.Reflection.Assembly)">
            <summary>
            GetTypes
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetType(System.String)">
            <summary>
            反射取得类型
            </summary>
            <param name="assemblyAndType"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetType(System.String,System.String)">
            <summary>
            反射取得类型
            </summary>
            <param name="assemblyName">程序集名称</param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetType(System.Reflection.Assembly,System.String)">
            <summary>
            反射取得类型
            </summary>
            <param name="assembly">程序集</param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.InstanceType(System.Reflection.Assembly,System.String,Comm.Utils.ReflexWay,System.Object[])">
            <summary>
            反射创建实例对象
            </summary>
            <param name="assembly"></param>
            <param name="typeName"></param>
            <param name="reflexWay"></param>
            <param name="args">构造函数参数</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.InstanceType(System.String,System.String,Comm.Utils.ReflexWay,System.Object[])">
            <summary>
            反射创建实例对象
            </summary>
            <param name="assemblyFile"></param>
            <param name="typeName"></param>
            <param name="reflexWay"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.InstanceType(System.Type,Comm.Utils.ReflexWay,System.Object[])">
            <summary>
            反射创建实例对象
            </summary>
            <param name="type"></param>
            <param name="reflexWay"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.InstanceType(System.Type,System.Object[])">
            <summary>
            反射创建实例对象
            </summary>
            <param name="type"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetMethods(System.Type)">
            <summary>
            取着instanceType上的MethodInfo集合
            </summary>
            <param name="instanceType"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetMethod(System.Object,System.String,System.Object[])">
            <summary>
            反射取得对象的方法
            </summary>
            <param name="instance"></param>
            <param name="methodName"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.InvokeMethod(System.Object,System.String,System.Object[])">
            <summary>
            反射执行指定方法名的方法
            </summary>
            <param name="instance">要反射执行方法的对象</param>
            <param name="methodName">方法名</param>
            <param name="args">方法的参数</param>
            <returns>方法的返回值</returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetProperties(System.Object)">
            <summary>
            取着instance上的PropertyInfo集合
            </summary>
            <param name="instance">对象</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetProperties(System.Type)">
            <summary>
            取着instanceType上的PropertyInfo集合
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceType"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetProperty(System.Type,System.String)">
            <summary>
            反射取得对象的属性
            </summary>
            <param name="instanceType">对象类型</param>
            <param name="propertyName">属性名称</param>
            <returns>属性信息</returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetProperty(System.Object,System.String)">
            <summary>
            反射取得对象的属性
            </summary>
            <param name="instance">对象</param>
            <param name="propertyName">属性名称</param>
            <returns>属性信息</returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetPropertyValue(System.Object,System.String)">
            <summary>
            反射取得对象的属性值
            </summary>
            <param name="instance">对象</param>
            <param name="propertyName">属性名称</param>
            <returns>属性对应的值</returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            反射取设置对象的属性值
            </summary>
            <param name="instance">对象</param>
            <param name="propertyName">属性名称</param>
            <param name="value">要设的属性值</param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetFields(System.Type)">
            <summary>
            取着instanceType上的FieldInfo集合
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceType"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetField(System.Type,System.String)">
            <summary>
            反射取得对象的属性
            </summary>
            <param name="instanceType">对象</param>
            <param name="fieldName">属性名称</param>
            <returns>属性信息</returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetField(System.Object,System.String)">
            <summary>
            反射取得对象的属性
            </summary>
            <param name="instance">对象</param>
            <param name="propertyName">属性名称</param>
            <returns>属性信息</returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetFieldValue(System.Object,System.String)">
            <summary>
            反射取得对象的属性值
            </summary>
            <param name="instance">对象</param>
            <param name="propertyName">属性名称</param>
            <returns>属性对应的值</returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.SetFieldValue(System.Object,System.String,System.Object)">
            <summary>
            反射取设置对象的属性值
            </summary>
            <param name="instance">对象</param>
            <param name="propertyName">属性名称</param>
            <param name="value">要设的属性值</param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetAttributes(System.Reflection.MemberInfo)">
            <summary>
            取得<see cref="T:System.Reflection.MemberInfo"/>对应的对象上标识的属性，并做缓存
            </summary>
            <typeparam name="T"></typeparam>
            <param name="memberInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            取得<see cref="T:System.Reflection.MemberInfo"/>对应的对象上标识指定属性类型，并做缓存
            </summary>
            <typeparam name="T"></typeparam>
            <param name="memberInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetAttribute``1(System.Type)">
            <summary>
             取得<see cref="T:System.Type"/>对应的对象上标识指定属性类型，并做缓存
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.AddHandler(System.Object,System.String,System.Delegate)">
            <summary>
            反射往指定对象上注册指定事件的委托
            </summary>
            <param name="instance">对象</param>
            <param name="eventName">事件名称</param>
            <param name="handler">事件委托</param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.RemoveHandler(System.Object,System.String,System.Delegate)">
            <summary>
            反射往指定对象上反注册指定事件的委托
            </summary>
            <param name="instance">对象</param>
            <param name="eventName">事件名称</param>
            <param name="handler">事件委托</param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheAssemblies">
            <summary>
            缓存当前应用程序域的程序集
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheAssemblies(System.String)">
            <summary>
            缓存加载路径的程序集
            </summary>
            <param name="assemblyFile"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetAssemblyFromCache(System.String)">
            <summary>
            从缓存中获取程序集
            </summary>
            <param name="assemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheTypes(System.Reflection.Assembly)">
            <summary>
            缓存类型
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetTypeFromCache(System.Reflection.Assembly,System.String)">
            <summary>
            从缓存中获取类型
            </summary>
            <param name="assembly"></param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheMethods(System.Type)">
            <summary>
            缓存方法
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetMethodFromCache(System.Type,System.String,System.Object[])">
            <summary>
            从缓存中获取方法
            </summary>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.ValidateParameter(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            验证方法参数
            </summary>
            <param name="method"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheProperties(System.Type)">
            <summary>
            缓存属性
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetPropertyFromCache(System.Type,System.String)">
            <summary>
            从缓存中获取属性
            </summary>
            <param name="type"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheFields(System.Type)">
            <summary>
            缓存字段
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetFieldFromCache(System.Type,System.String)">
            <summary>
            从缓存中获取Field
            </summary>
            <param name="type"></param>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheAttributes(System.Reflection.MemberInfo)">
            <summary>
            缓存Attributes
            </summary>
            <param name="memberInfo"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheAttributes(System.Type)">
            <summary>
            缓存Attributes
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.CacheEvent(System.Type)">
            <summary>
            缓存事件
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Comm.Utils.ReflexHelper.GetEventFromCache(System.Type,System.String)">
            <summary>
            从缓存中获取事件
            </summary>
            <param name="type"></param>
            <param name="eventName"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.IParallelStrategy">
            <summary>
            并行策略
            </summary>
        </member>
        <member name="M:Comm.Utils.IParallelStrategy.Execute``1(System.Func{``0},Comm.Utils.NResultDel{``0},Comm.Utils.NExceptionDel,Comm.Utils.CallbackMode)">
            <summary>
            Execute  a code block asynchronously, 返回制定类型T
            </summary>
            <typeparam name="T">Result type of the code block</typeparam>
            <param name="asyncRoutine">The code block to execute</param>
            <param name="callbackRoutine">The callback routine</param>
            <param name="exceptionRoutine">The Exception Routine</param>
            <param name="callbackMode"></param>
            <returns>Holder of the result for the code block</returns>
        </member>
        <member name="M:Comm.Utils.IParallelStrategy.Execute(Comm.Utils.NVoidCallDel,Comm.Utils.NVoidCallDel,Comm.Utils.NExceptionDel,Comm.Utils.CallbackMode)">
            <summary>
            Execute  a code block asynchronously ， 返回Void
            </summary>
            <param name="asyncRoutine">The code block to execute</param>
            <param name="callbackRoutine">The callback routine</param>
            <param name="exceptionRoutine">The Exception Routine</param>
            <param name="callbackMode"></param>
            <returns>Holder of the result for the code block</returns>
            <returns></returns>
        </member>
        <member name="P:Comm.Utils.IParallelStrategy.ExceptionDel">
            <summary>
            The overall exception handling routine, 
            will be used when no exception routine is provided for the function
            </summary>
        </member>
        <member name="M:Comm.Utils.IParallelStrategy.AbortParallelThreads">
            <summary>
            终止所有并行线程
            </summary>
        </member>
        <member name="T:Comm.Utils.NVoid">
            <summary>
            Place holder for void in Generic classes
            在范型类中表示Void返回类型
            </summary>
        </member>
        <member name="M:Comm.Utils.NVoid.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:Comm.Utils.NResultDefault`3">
            <summary>
            缺省返回值
            </summary>
            <typeparam name="TMethodDelegate">委托方法</typeparam>
            <typeparam name="TCallbackDelegate">委托回调函数</typeparam>
            <typeparam name="T">委托返回类型</typeparam>
        </member>
        <member name="F:Comm.Utils.NResultDefault`3.asyncHandle">
            <summary>
            异步结果
            </summary>
        </member>
        <member name="M:Comm.Utils.NResultDefault`3.#ctor(System.IAsyncResult,`0,`1,Comm.Utils.NExceptionDel)">
            <summary>
            构造函数
            </summary>
            <param name="tar">异步执行结果</param>
            <param name="callerRoutine">呼叫程序</param>
            <param name="callbackRoutine">回调程序</param>
            <param name="exceptionRoutine">异常处理程序</param>
        </member>
        <member name="M:Comm.Utils.NResultDefault`3.#ctor(`0,`1,Comm.Utils.NExceptionDel)">
            <summary>
            构造函数
            </summary>
            <param name="callerRoutine">呼叫程序</param>
            <param name="callbackRoutine">回调程序</param>
            <param name="exceptionRoutine">异常处理程序</param>
        </member>
        <member name="P:Comm.Utils.NResultDefault`3.AsyncHandle">
            <summary>
            异步结果
            </summary>
        </member>
        <member name="P:Comm.Utils.NResultDefault`3.CallerRoutine">
            <summary>
            异步呼叫程序
            </summary>
        </member>
        <member name="P:Comm.Utils.NResultDefault`3.CallbackRoutine">
            <summary>
            回调程序
            </summary>
        </member>
        <member name="M:Comm.Utils.NResultDefault`3.AutoCallback(System.IAsyncResult)">
            <summary>
            自动回调
            </summary>
            <param name="tar">异步执行结果</param>
        </member>
        <member name="P:Comm.Utils.NResultDefault`3.Value">
            <summary>
            获取返回值
            </summary>
        </member>
        <member name="M:Comm.Utils.NResultDefault`3.RequireWait">
            <summary>
            是否需要等待
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NResultDefault`3.Wait">
            <summary>
            等待
            </summary>
        </member>
        <member name="M:Comm.Utils.NResultDefault`3.IsDone">
            <summary>
            是否已经执行完
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NResultDefault`3.IsReady">
            <summary>
            是否准备好
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.LibefaultStrategy.#ctor">
            <summary>
            默认构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.LibefaultStrategy.Execute``1(System.Func{``0},Comm.Utils.NResultDel{``0},Comm.Utils.NExceptionDel,Comm.Utils.CallbackMode)">
            <summary>
            Execute  a code block asynchronously, 返回制定类型T
            </summary>
            <typeparam name="T">Result type of the code block</typeparam>
            <param name="asyncRoutine">The code block to execute</param>
            <param name="callbackRoutine">The callback routine</param>
            <param name="exceptionRoutine">The Exception Routine</param>
            <param name="callbackMode"></param>
            <returns>Holder of the result for the code block</returns>
        </member>
        <member name="M:Comm.Utils.LibefaultStrategy.Execute(Comm.Utils.NVoidCallDel,Comm.Utils.NVoidCallDel,Comm.Utils.NExceptionDel,Comm.Utils.CallbackMode)">
            <summary>
            Execute  a code block asynchronously ， 返回Void
            </summary>
            <param name="asyncRoutine">The code block to execute</param>
            <param name="callbackRoutine">The callback routine</param>
            <param name="exceptionRoutine">The Exception Routine</param>
            <param name="callbackMode"></param>
            <returns>Holder of the result for the code block</returns>
        </member>
        <member name="P:Comm.Utils.LibefaultStrategy.ExceptionDel">
            <summary>
            The overall exception handling routine, 
            will be used when no exception routine is provided for the function
            </summary>
        </member>
        <member name="M:Comm.Utils.LibefaultStrategy.AbortParallelThreads">
            <summary>
            终止所有并行线程
            </summary>
        </member>
        <member name="T:Comm.Utils.NParallel">
            <summary>
            并行执行方法
            </summary>
        </member>
        <member name="F:Comm.Utils.NParallel.defaultMarshal">
            <summary>
            缺省为队列方式
            </summary>
        </member>
        <member name="F:Comm.Utils.NParallel.strategy">
            <summary>
            策略
            </summary>
        </member>
        <member name="M:Comm.Utils.NParallel.#cctor">
            <summary>
            静态构造函数
            </summary>
        </member>
        <member name="P:Comm.Utils.NParallel.Strategy">
            <summary>
            并行策略
            </summary>
        </member>
        <member name="P:Comm.Utils.NParallel.Queue">
            <summary>
            返回内部执行队列
            </summary>
        </member>
        <member name="P:Comm.Utils.NParallel.ExceptionRoutine">
            <summary>
            异常处理函数
            </summary>
        </member>
        <member name="P:Comm.Utils.NParallel.DefaultMarshal">
            <summary>
            缺省Callback排队模式
            </summary>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute``1(System.Func{``0})">
            <summary>
            执行方法， 无参，指定返回结果类型
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="del">执行函数</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute``1(System.Func{``0},Comm.Utils.NResultDel{``0})">
            <summary>
            执行方法， 无参，指定返回结果类型，指定回调函数
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="del">执行函数</param>
            <param name="callback">回调函数</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute``1(System.Func{``0},Comm.Utils.CallbackMode)">
            <summary>
            执行方法， 无参，指定返回结果类型
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="del">执行函数</param>
            <param name="marshal">回调排队方式</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute``1(System.Func{``0},Comm.Utils.NResultDel{``0},Comm.Utils.CallbackMode)">
            <summary>
            执行方法， 无参，指定返回结果类型，指定回调函数
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="del">执行函数体</param>
            <param name="callback">回调函数</param>
            <param name="marshal">回调排队方式</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute``1(System.Func{``0},Comm.Utils.NResultDel{``0},Comm.Utils.NExceptionDel,Comm.Utils.CallbackMode)">
            <summary>
            执行方法， 无参，指定返回结果类型，指定回调函数, 指定异常处理函数
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="del">执行函数</param>
            <param name="callback">回调函数</param>
            <param name="exceptionRoutine">异常处理函数</param>
            <param name="marshal">回调排队方式</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute(Comm.Utils.NVoidCallDel)">
            <summary>
            过程执行，无返回值
            </summary>
            <param name="del">处理过程</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute(Comm.Utils.NVoidCallDel,Comm.Utils.NVoidCallDel)">
            <summary>
            过程执行，无返回值， 指定回调函数
            </summary>
            <param name="del">执行函数</param>
            <param name="callback">回调方法</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute(Comm.Utils.NVoidCallDel,Comm.Utils.CallbackMode)">
            <summary>
            过程执行，无返回值， 指定执行函数，指定回调排队方式
            </summary>
            <param name="del">执行函数</param>
            <param name="marshal">回调排队方式</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute(Comm.Utils.NVoidCallDel,Comm.Utils.NVoidCallDel,Comm.Utils.CallbackMode)">
            <summary>
             过程执行，无返回值， 指定执行函数，指定回调排队方式
            </summary>
            <param name="del">执行函数</param>
            <param name="callback">回调函数</param>
            <param name="marshal">回调排队方式</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.Execute(Comm.Utils.NVoidCallDel,Comm.Utils.NVoidCallDel,Comm.Utils.NExceptionDel,Comm.Utils.CallbackMode)">
            <summary>
             过程执行，无返回值， 指定执行函数，指定回调排队方式，指定异常处理函数
            </summary>
            <param name="del">执行函数</param>
            <param name="callback">回调函数</param>
            <param name="exceptionRoutine">异常处理函数</param>
            <param name="marshal">回调排队方式</param>
            <returns>返回值对象</returns>
        </member>
        <member name="M:Comm.Utils.NParallel.AbortParallelThreads">
            <summary>
            终止所有并行线程
            </summary>
        </member>
        <member name="T:Comm.Utils.NQueue">
            <summary>
            队列实现
            </summary>
        </member>
        <member name="F:Comm.Utils.NQueue.instance">
            <summary>
            全局队列实例
            </summary>
        </member>
        <member name="M:Comm.Utils.NQueue.#ctor">
            <summary>
            异常构造函数
            </summary>
        </member>
        <member name="P:Comm.Utils.NQueue.Instance">
            <summary>
            静态实例
            </summary>
        </member>
        <member name="M:Comm.Utils.NQueue.EnQueue(Comm.Utils.NResult)">
            <summary>
            向队列添加元素
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:Comm.Utils.NQueue.Update">
            <summary>
            更新，压缩
            </summary>
        </member>
        <member name="T:Comm.Utils.NResultDel`1">
            <summary>
            指定类型的结果处理委托定义
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
        </member>
        <member name="T:Comm.Utils.NVoidCallDel">
            <summary>
            无返回值的结果处理委托定义
            </summary>
        </member>
        <member name="T:Comm.Utils.NExceptionDel">
            <summary>
            异常处理委托定义
            </summary>
            <param name="exc"></param>
        </member>
        <member name="T:Comm.Utils.CallbackMode">
            <summary>
            Callback模式
            </summary>
        </member>
        <member name="F:Comm.Utils.CallbackMode.Manual">
            <summary>
            手动
            </summary>
        </member>
        <member name="F:Comm.Utils.CallbackMode.Queue">
            <summary>
            等待
            </summary>
        </member>
        <member name="F:Comm.Utils.CallbackMode.Auto">
            <summary>
            自动
            </summary>
        </member>
        <member name="T:Comm.Utils.NResult">
            <summary>
            执行结果抽象类
            </summary>
        </member>
        <member name="F:Comm.Utils.NResult.marshal">
            <summary>
            初始化缺省回调排队方式，默认为并行对象的排队方式
            </summary>
        </member>
        <member name="F:Comm.Utils.NResult.canceled">
            <summary>
            是否被取消执行
            </summary>
        </member>
        <member name="P:Comm.Utils.NResult.CallbackMode">
            <summary>
            获取或者设定回调排队模式
            </summary>
        </member>
        <member name="M:Comm.Utils.NResult.IsDone">
            <summary>
            是否执行完毕
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NResult.IsReady">
            <summary>
            是否已经处于准备状态
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NResult.RequireWait">
            <summary>
            是否需要等待
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.NResult.AutoCallback(System.IAsyncResult)">
            <summary>
            自动回调函数
            </summary>
            <param name="tar"></param>
        </member>
        <member name="P:Comm.Utils.NResult.CallerRoutine">
            <summary>
            获取呼叫函数
            </summary>
        </member>
        <member name="M:Comm.Utils.NResult.Wait">
            <summary>
            等待
            </summary>
        </member>
        <member name="M:Comm.Utils.NResult.Cancel">
            <summary>
            获取是否被取消
            </summary>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.NResult`1">
            <summary>
            执行结果，可获取指定类型的返回值
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Comm.Utils.NResult`1.Value">
            <summary>
            获取指定类型的返回值
            </summary>
        </member>
        <member name="T:Comm.Utils.StringBuffer">
            <summary>
            对StringBuilder的封装
            </summary>
        </member>
        <member name="M:Comm.Utils.StringBuffer.op_Addition(Comm.Utils.StringBuffer,System.Char)">
            <summary>
            运算符重载
            </summary>
            <param name="buffer"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.StringBuffer.Remove(System.Int32,System.Int32)">
            <summary>
            移除指定位置的字符
            </summary>
            <param name="startIndex"></param>
            <param name="length"></param>
        </member>
        <member name="T:Comm.Utils.SymmetricMethod">
            <summary>
            对称加密算法类
            </summary>
        </member>
        <member name="M:Comm.Utils.SymmetricMethod.#ctor">
            <summary>
            对称加密类的构造函数
            </summary>
        </member>
        <member name="M:Comm.Utils.SymmetricMethod.GetLegalKey">
            <summary>
            获得密钥
            </summary>
            <returns>密钥</returns>
        </member>
        <member name="M:Comm.Utils.SymmetricMethod.GetLegalIV">
            <summary>
            获得初始向量IV
            </summary>
            <returns>初试向量IV</returns>
        </member>
        <member name="M:Comm.Utils.SymmetricMethod.Encrypto(System.String)">
            <summary>
            加密方法
            </summary>
            <param name="Source">待加密的串</param>
            <returns>经过加密的串</returns>
        </member>
        <member name="M:Comm.Utils.SymmetricMethod.Decrypto(System.String)">
            <summary>
            解密方法
            </summary>
            <param name="Source">待解密的串</param>
            <returns>经过解密的串</returns>
        </member>
        <member name="T:Comm.Utils.MD5ResultMode">
            <summary>
            MD5返回模式
            </summary>
        </member>
        <member name="F:Comm.Utils.MD5ResultMode.Strong">
            <summary>
            强类型
            </summary>
        </member>
        <member name="F:Comm.Utils.MD5ResultMode.Weak">
            <summary>
            弱类型
            </summary>
        </member>
        <member name="T:Comm.Utils.TextEncrypt">
            <summary>
            “单向加密”类
            </summary>
        </member>
        <member name="M:Comm.Utils.TextEncrypt.MD5Encrypt(System.String)">
            <summary>
            MD5 加密
            </summary>
            <param name="password">要加密的字符串</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextEncrypt.MD5Encrypt(System.String,Comm.Utils.MD5ResultMode)">
            <summary>
            MD5 加密
            </summary>
            <param name="password">要加密的字符串</param>
            <param name="mode">加密强度</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextEncrypt.DSAEncrypt(System.String)">
            <summary>
             DSA 加密
            </summary>
            <param name="password">要加密的字符串</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextEncrypt.SHA1Encrypt(System.String,System.Text.Encoding)">
            <summary>
            SHA1 加密
            </summary>
            <param name="password">要加密的字符串</param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextEncrypt.SHA256Encrypt(System.String)">
            <summary>
            SHA256 加密
            </summary>
            <param name="password">要加密的字符串</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextEncrypt.Base64Decode(System.String)">
            <summary>
             Base64 解码
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextEncrypt.Base64Encode(System.String)">
            <summary>
            Base64 编码
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="F:Comm.Utils.FilterType.Script">
            <summary>
            脚本
            </summary>
        </member>
        <member name="F:Comm.Utils.FilterType.Html">
            <summary>
            Html代码
            </summary>
        </member>
        <member name="F:Comm.Utils.FilterType.Object">
            <summary>
            对象
            </summary>
        </member>
        <member name="F:Comm.Utils.FilterType.AHrefScript">
            <summary>
            链接脚本
            </summary>
        </member>
        <member name="F:Comm.Utils.FilterType.Iframe">
            <summary>
            iframe
            </summary>
        </member>
        <member name="F:Comm.Utils.FilterType.Frameset">
            <summary>
            frameSet
            </summary>
        </member>
        <member name="F:Comm.Utils.FilterType.Src">
            <summary>
            Src
            </summary>
        </member>
        <member name="F:Comm.Utils.FilterType.BadWords">
            <summary>
            敏感字符，脏字
            </summary>
        </member>
        <member name="F:Comm.Utils.FilterType.All">
            <summary>
            全部
            </summary>
        </member>
        <member name="T:Comm.Utils.TextFilter">
            <summary>
            提供字符串过滤方法
            </summary>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterAll(System.String)">
            <summary>
            过滤全部
            </summary>
            <param name="content">要过滤的内容</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterAHrefScript(System.String)">
            <summary>
            过滤链接脚本
            </summary>
            <param name="content">要过滤的内容</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterBadWords(System.String)">
            <summary>
            过滤敏感字符
            </summary>
            <param name="chkStr"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterBR(System.String)">
            <summary>
            过滤回车、换行符
            </summary>
            <param name="filterStr"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterFrameset(System.String)">
            <summary>
            过滤Frameset标签
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterIframe(System.String)">
            <summary>
            过滤Iframe标签
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterHtml(System.String)">
            <summary>
            Html代码过滤
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterObject(System.String)">
            <summary>
            过滤 Object 标签
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterScript(System.String)">
            <summary>
            脚本过滤
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterSrc(System.String)">
            <summary>
            过滤包含 Src 的标签
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterTextFromHTML(System.String)">
            <summary>
            从HTML中获取文本,保留br,p,img标签
            </summary>
            <param name="contentHtml">要过滤的Html文本</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterTrim(System.String)">
            <summary>
            过滤字符串尾部的回车/换行/空格
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterUnsafeHtml(System.String)">
            <summary>
             过滤HTML中的不安全标签
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterUserInput(System.String)">
            <summary>
            过滤输入字符串为字母和数字,@,-
            </summary>
            <param name="inputStr">输入字符串</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterXHtml(System.String)">
            <summary>
             过滤所有 XHTML 标签,并编码过滤后返回的字符串
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterXHtml(System.String,System.Boolean)">
            <summary>
            过滤所有 XHTML 标签
            </summary>
            <param name="content">XHtml 内容</param>
            <param name="encode">是否对过滤后的内容编码</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterJson(System.String)">
            <summary>
            过滤Json非字符
            </summary>
            <param name="sourceStr"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterSql(System.String,System.Boolean)">
            <summary>
            过滤 Sql 语句字符串中的注入脚本
            </summary>
            <param name="NoHTML">包括HTML，脚本，数据库关键字，特殊字符的源码 </param>
            <returns>已经去除标记后的文字</returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.FilterSql(System.String)">
            <summary>
            过滤SQL注入字母
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.ContainsUnsafeSql(System.String)">
            <summary>
            是否包含不安全SQL关键字
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.IsHaveSqlWord(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            检测是否含有SQL注入代码
            </summary>
            <param name="sql"></param>
            <param name="relist">对于本身字段包含以下字符的,指定排除过滤的字符串列表，比如inserttime</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextFilter.Process(Comm.Utils.FilterType,System.String)">
            <summary>
             过滤XHtml标签
            </summary>
            <param name="filterType">过滤类型</param>
            <param name="filterContent">要过滤内容</param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.TextUtility">
            <summary>
            提供用于处理字符串的方法
            </summary>
        </member>
        <member name="M:Comm.Utils.TextUtility.CreateAuthStr(System.Int32)">
            <summary>
            创建验证码随机字符串(数字和字母)
            </summary>
            <param name="len">最大长度</param>
            <returns>返回指定最大长度的随机字符串</returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CreateAuthStr(System.Int32,System.Boolean)">
            <summary>
            创建验证码随机字符串
            </summary>
            <param name="len">最大长度</param>
            <param name="onlyNum">是否纯数字</param>
            <returns>返回指定最大长度的随机字符串</returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CreateRandom(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            生成随机字符串
            </summary>
            <param name="length">目标字符串的长度</param>
            <param name="useNum">是否包含数字，1=包含，默认为包含</param>
            <param name="useLow">是否包含小写字母，1=包含，默认为包含</param>
            <param name="useUpp">是否包含大写字母，1=包含，默认为包含</param>
            <param name="useSpe">是否包含特殊字符，1=包含，默认为不包含</param>
            <param name="custom">要包含的自定义字符，直接输入要包含的字符列表</param>
            <returns>指定长度的随机字符串</returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CreateRandomLowercase(System.Int32)">
            <summary>
            获取一个由26个小写字母组成的指定长度的随即字符串
            </summary>
            <param name="len">最大长度</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CreateRandomNum(System.Int32)">
            <summary>
            获取指定长度的纯数字随机数字串(以时间做随机种子)
            </summary>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CreateRandomNum2(System.Int32)">
            <summary>
            获取指定长度的纯数字随机数字串
            </summary>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.GetNewSeed">
            <summary>
            产生随机数的种子
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CutLeft(System.String,System.Int32)">
            <summary>
            从给定字符串(originalVal)左侧开始截取指定长度(cutLength)个字符,[使用字节宽度]
            </summary>
            <param name="originalVal"></param>
            <param name="cutLength"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CutRight(System.String,System.Int32)">
            <summary>
            从给定字符串(originalVal)右侧开始截取指定长度(cutLength)个字符,[使用方法Substring()]
            </summary>
            <param name="originalVal"></param>
            <param name="cutLength"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CutString(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="originalVal"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CutString(System.String,System.Int32,System.Int32)">
            <summary>
             从给定字符串(originalVal)的(startIndex)索引位置开始截取指定长度(cutLength)的字符串
            </summary>
            <param name="originalVal"></param>
            <param name="startIndex"></param>
            <param name="cutLength"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CutStringTitle(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="content"></param>
            <param name="cutLength"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CutEllipsis(System.String,System.Int32)">
            <summary>
            字符串超出指定长度截取并添加省略号
            </summary>
            <param name="originalVal">原始字符串</param>
            <param name="length">截取长度</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.SplitStringToArray(System.String,System.String)">
            <summary>
            用字符串(separator)把给定的字符串(originalStr)分割成字符数组
            </summary>
            <param name="originalStr"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.DiffDateAndTime(System.Object,System.Object)">
            <summary>
            二个时间差了多少天,多少小时的计算 
            </summary>
            <param name="todate"></param>
            <param name="fodate"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.DiffDateAndTime(System.Object,System.Object,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            二个时间差了多少天,多少小时的计算 
            </summary>
            <param name="todate"></param>
            <param name="fodate"></param>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <param name="v4"></param>
            <param name="v5"></param>
            <param name="v6"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.DiffDateDays(System.DateTime)">
            <summary>
            计算给定的日期时间距离现在的天数
            </summary>
            <param name="oneDateTime">要计算的日期对象</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.DiffDateDays(System.String)">
            <summary>
            计算给定的日期时间距离现在的天数
            </summary>
            <param name="oneDateTime">要计算的日期字符串</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.FormatDateSpan(System.Object)">
            <summary>
            把给定的日期格式化为距现在的模糊时间段，比如 1 分钟前
            </summary>
            <param name="dateSpan">日期</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.FormatDateTime(System.DateTime,System.Int32,System.String)">
            <summary>
            格式化日期输出
            1 ToString
            2 ToShortDateString
            3 yyyy年MM月dd日HH点mm分ss秒
            4 yyyy年MM月dd日
            5 yyyy年MM月dd日HH点mm分
            6 yyyy-MM-dd HH:mm
            7 yy年MM月dd日 HH点mm分
            8 yyyy-MM-dd HH:mm:ss
            </summary>
            <param name="oneDateVal">日期对象</param>
            <param name="formatType">输出类型</param>
            <param name="formatString"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.FormatDateTime(System.Nullable{System.DateTime},System.Int32,System.String)">
            <summary>
            格式化日期输出
            1 ToString
            2 ToShortDateString
            3 yyyy年MM月dd日HH点mm分ss秒
            4 yyyy年MM月dd日
            5 yyyy年MM月dd日HH点mm分
            6 yyyy-MM-dd HH:mm
            7 yy年MM月dd日 HH点mm分
            8 yyyy-MM-dd HH:mm:ss
            </summary>
            <param name="oneDateVal">日期对象</param>
            <param name="formatType">输出类型</param>
            <param name="formatString"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.FormatDateTime(System.String,System.Int32,System.String)">
            <summary>
            格式化日期输出
            1 ToString
            2 ToShortDateString
            3 yyyy年MM月dd日HH点mm分ss秒
            4 yyyy年MM月dd日
            5 yyyy年MM月dd日HH点mm分
            6 yyyy-MM-dd HH:mm
            7 yy年MM月dd日 HH点mm分
            8 yyyy-MM-dd HH:mm:ss
            </summary>
            <param name="oneDateVal"></param>
            <param name="formatType"></param>
            <param name="formatString"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.FormatSecondSpan(System.Int64)">
            <summary>
            计算模糊时间段，秒换算为X天X时X分X秒
            </summary>
            <param name="second">秒数</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.GetDateTimeLongString">
            <summary>
            获取长日期字符串表示 yyyyMMddHHmmss000
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.GetDateTimeLongString(System.String)">
            <summary>
            获取长日期字符串表示 yyyyMMddHHmmss000,可以添加前缀
            </summary>
            <param name="prefix">前缀字符</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.GetTimeStamp(System.DateTime)">
            <summary>
            获取时间戳
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.ConvertDateTimeToInt(System.DateTime)">
            <summary>  
            将DateTime时间格式转换为Unix时间戳格式
            </summary>  
            <param name="time">时间</param>  
            <returns>long</returns>  
        </member>
        <member name="M:Comm.Utils.TextUtility.ConvertStringToDateTime(System.String)">
            <summary>        
            时间戳转为时间格式        
            </summary>        
            <param name="timeStamp"></param>        
            <returns></returns>        
        </member>
        <member name="M:Comm.Utils.TextUtility.UrlAppendHttp(System.String)">
            <summary>
            Url附加http或https字符
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.GetHost(System.String,System.Boolean)">
            <summary>
            根据Url地址获取主机(可以是IP地址、域名、Localhost等)
            </summary>
            <param name="strReqUrl">请求Url</param>
            <param name="returnPort">是否返回端口号</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.GetIpByHost(System.String)">
            <summary>
            根据主机名（可以是IP地址、域名、Localhost）获取IP
            </summary>
            <param name="strHostOrIp">主机名（可以是IP地址、域名、Localhost）</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.GetIp(System.String)">
            <summary>
            根据Url地址获取Ip
            </summary>
            <param name="strReqUrl">请求Url</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.GetPathAndQuery(System.String,System.Boolean)">
            <summary>
            根据Url地址获取路径与参数(可以是IP地址、域名、Localhost等)
            </summary>
            <param name="strReqUrl">http://localhost:51151/gateway/deviceindex/1?p=1212</param>
            <param name="containsQuery">是否包含参数，？后的部分</param>
            <returns>gateway/deviceindex/1?p=1212或gateway/deviceindex/1</returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.JoinQueryString(System.String,System.String,System.String)">
            <summary>
            向URL地址添加新参数
            </summary>
            <param name="strUrl"></param>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.FormatIP(System.String,System.Int32)">
            <summary>
            格式化 IP 地址, fields 3,2,1 保留左起三位，二位，一位
               隐藏IP地址最后一位用*号代替
            </summary>
            <param name="ip"></param>
            <param name="fields"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.CreateTemporaryPassword(System.Int32)">
            <summary>
            创建指定长度的临时密码
            </summary>
            <param name="length">临时密码最大长度</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.StringInArrayIndexOf(System.String,System.String[],System.Boolean)">
            <summary>
            判断字符串1 在 字符串数组中的位置
            </summary>
            <param name="originalStr">字符串1</param>
            <param name="strArray">字符串数组</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.TransformFirstToLower(System.String)">
            <summary>
             转换字符串首字符为小写字符(对英文字符有效)
            </summary>
            <param name="originalVal"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.TransformFirstToUpper(System.String)">
            <summary>
            转换字符串首字符为大写字符(对英文字符有效)
            </summary>
            <param name="originalVal">原始字符串</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TextUtility.NumToChn(System.Int32)">
            <summary>
            将数字转化为大写中文字符
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.TraceTool.FontDetail">
            <summary>
            Specify a font detail for traces columns items and members.
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.StringList">
            <summary>
            List of string.
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.MemberList">
            <summary>
            List of Members.
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.InternalWinTraceList">
            <summary>
            List of InternalWinTrace.
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.MsgQueueList">
            <summary>
            List of StringList.
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.FontDetailList">
            <summary>
            List of FontDetail.
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.NodeContextList">
            <summary>
            List of NodeContext.
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.StrKeyObjectList">
            <summary>
            List of string keys / object (Hashtable)
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.ParsedObjectList">
            <summary>
            List of parsed object.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ParsedObjectList.#ctor">
            <summary>
            The parameterless constructor of the base class creates a 
            KeyedCollection with an internal dictionary. For this code 
            example, no other constructors are exposed.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ParsedObjectList.GetKeyForItem(System.Object)">
            <summary>
            This is the only method that absolutely must be overridden,
            because without it the KeyedCollection cannot extract the
            keys from the items. The input parameter type is the 
            second generic type argument, in this case OrderItem, and 
            the return value type is the first generic type argument,
            in this case int.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ParsedObjectList.ContainsKey(System.Object)">
            <summary>
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.SendMode">
            2 ways to send traces : windows messages or socket messages. Under ASP, you must use Socket
        </member>
        <member name="F:Comm.Utils.TraceTool.SendMode.WinMsg">
            Windows message
        </member>
        <member name="F:Comm.Utils.TraceTool.SendMode.Socket">
            Socket message
        </member>
        <member name="F:Comm.Utils.TraceTool.SendMode.None">
            No messages are send (use local log)
        </member>
        <member name="T:Comm.Utils.TraceTool.TraceDisplayFlags">
            <summary>
            What information to display
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowModifiers">
            <summary>
            show modifiers (public class,...)
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowClassInfo">
            <summary>
            show class info (assembly,guid,...) and bases classes names
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowFields">
            <summary>
            show fields values
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowCustomAttributes">
            <summary>
            show custom attributes
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowNonPublic">
            <summary>
            show non public (private and protected) members
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowInheritedMembers">
            <summary>
            show Inherited members
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowEvents">
            <summary>
            show events (delegates)
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowMethods">
            <summary>
            show methods and constructors
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceDisplayFlags.ShowDoc">
            <summary>
            show documenation for type, fields, methods,..
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.TraceConst">
            <summary>
            Define all const and windows functions used by the TraceTool namespace
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.WM_COPYDATA">
            <summary> the windows constant to use to send bloc of data across process </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.WMD">
            <summary> identification code 'traceTool'. Other code are discarded by the server </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_DEFAULT">
            <summary> Use the default Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_FORM">
            <summary> Use the 'form' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_COMPONENT">
            <summary> Use the 'component' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_CONTROL">
            <summary> Use the 'control' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_PROP">
            <summary> Use the 'property' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_MENU">
            <summary> Use the 'memu' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_MENU_ITEM">
            <summary> Use the 'menu item' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_COLLECT_ITEM">
            <summary> Use the 'Collection Item' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_WARNING">
            <summary> Use the 'warning' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_ERROR">
            <summary> Use the 'Error' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_INFO">
            <summary> Use the 'Info' Icon on the gutter for the trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_NONE">
            <summary> viewer kind : default viewer, no icon</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_DUMP">
            <summary> viewer kind : dump viewer </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_XML">
            <summary> viewer kind : xml viewer </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_TABLE">
            <summary> viewer kind : table viewer </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_STACK">
            <summary> viewer kind : stack </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_BITMAP">
            <summary> viewer kind : bitmap viewer </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_OBJECT">
            <summary> viewer kind : object structure </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_VALUE">
            <summary> viewer kind : object value </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_ENTER">
            <summary> viewer kind : enter method </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_EXIT">
            <summary> viewer kind : exit method </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VIEWER_TXT">
            <summary> viewer kind : text added to default viewer </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_PLUG_ONACTION">
            <summary> Ask to receive OnAction event </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_PLUG_ONBEFOREDELETE">
            <summary>  Ask to receive OnBeforeDelete event </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_PLUG_ONTIMER">
            <summary>  Ask to receive OnTimer event </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RES_BUT_RIGHT">
            <summary> Button on right</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RES_BUT_LEFT">
            <summary> Button on left</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RES_LABEL_RIGHT">
            <summary> Label on right</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RES_LABELH_RIGHT">
            <summary> Label on right HyperLink</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RES_LABEL_LEFT">
            <summary> Label on left</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RES_LABELH_LEFT">
            <summary> Label on left hyperlink</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RES_MENU_ACTION">
            <summary> Item menu in the Actions Menu</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RES_MENU_WINDOW">
            <summary> Item menu in the Windows Menu. Call CreateResource on the main win trace to create this menu item</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_CUT">
            <summary> Cut. Same as copy then delete </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_COPY">
            <summary> Copy </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_DELETE">
            <summary> Delete selected </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_SELECT_ALL">
            <summary> Select all </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_RESIZE_COLS">
            <summary> Resize columns </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_VIEW_INFO">
            <summary> View trace info </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_VIEW_PROP">
            <summary> View properties </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_PAUSE">
            <summary> Pause </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_SAVE">
            <summary> SaveToFile </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_CLEAR_ALL">
            <summary> Clear all </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_CLOSE_WIN">
            <summary> Close win </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_RESUME">
            <summary> Resume from Pause </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_LABEL_INFO">
            <summary> TracesInfo label </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_LABEL_LOGFILE">
            <summary> LabelLogFile label </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_VIEW_MAIN">
            <summary> View Main trace </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_VIEW_ODS">
            <summary> ODS </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_OPEN_XML">
            <summary> XML trace -> Tracetool XML traces </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_EVENTLOG">
            <summary> Event log </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ACTION_TAIL">
            <summary> Tail </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ENTER_DEBUG_MODE">
            <summary>VIEWER INTERNAL : enter debug mode  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_LEAVE_DEBUG_MODE">
            <summary>VIEWER INTERNAL : leave debug mode  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_OPEN_TAIL">
            <summary>VIEWER INTERNAL : Open tail file  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_OPEN_XML">
            <summary>VIEWER INTERNAL : Open xml file on a new window (don't confuse with CST_LOADXML)  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_GET_OBJECT">
            <summary>VIEWER INTERNAL : the user interface ask to retreive an object  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_FLUSH">
            <summary>Flush remaining traces to server</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_GOTO_FIRST_NODE">
            <summary>WinTrace.GotoFirstNode()  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_GOTO_LAST_NODE">
            <summary>WinTrace.GotoLastNode()  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_FIND_NEXT">
            <summary>WinTrace.FindNext(forward)  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_GOTO_BOOKMARK">
            <summary>WinTrace.GotoBookmark(pos)  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CLEAR_BOOKMARK">
            <summary>WinTrace.ClearBookmark()  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CLEAR_FILTER">
            <summary>WinTrace.ClearFilter()  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ADD_FILTER">
            <summary>WinTrace.AddFilter(column,compare,text)  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_APPLY_FILTER">
            <summary>WinTrace.ApplyFilter(ConditionAnd, ShowMatch,IncludeChildren)  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_TREE_COLUMNWIDTH">
            <summary>Columns widths</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_TREE_MULTI_COLUMN">
            <summary>change the tree to display multiple column</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_TREE_COLUMNTITLE">
            <summary>change the columns titles</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_DISPLAY_TREE">
            <summary>display tree windows</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_TREE_NAME">
            <summary>new name of the tree</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_USE_TREE">
            <summary>the tree to use for other command</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CLEAR_ALL">
            <summary>The command to clear all nodes on the viewer</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CLOSE_WIN">
            <summary>Close the window (wintrace or winwatch)</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_WINWATCH_NAME">
            <summary>Watch Window name</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_WINWATCH_ID">
            <summary>Watch Window ID</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_WATCH_NAME">
            <summary>watch name</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_SAVETOTEXT">
            <summary>Save to text file</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_SAVETOXML">
            <summary>Save to XML file</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_LOADXML">
            <summary>Load XML file</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_LOGFILE">
            <summary>set the log file</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_LINKTOPLUGIN">
            <summary>link a wintrace to a plugin</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CREATE_RESOURCE">
            <summary>create a resource on a wintrace</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_SET_TEXT_RESOURCE">
            <summary>set the text resource</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_DISABLE_RESOURCE">
            <summary>disable a resource </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_FIND_TEXT">
            <summary>TTrace.Find (text, bool Sensitive, bool WholeWord , bool highlight )</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_SHOW">
            <summary>The command to bring the trace tool to front</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CLOSE_VIEWER">
            <summary>Close the viewer (shutdown)</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_TRACE_ID">
            <summary>the unique ID (from the server point of view) of the node (preferably a GUID)</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ICO_INDEX">
            <summary>the index of the Icon to use (CST_ICO_INFO, CST_ICO_WARNING,...)</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_GOTO_NEXTSIBLING">
            <summary>ITraceNode.GotoNextSibling ()  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_GOTO_PREVSIBLING">
            <summary>ITraceNode.GotoPrevSibling ()  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_GOTO_FIRST_CHILD">
            <summary>ITraceNode.GotoFirstChild  ()  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_GOTO_LAST_CHILD">
            <summary>ITraceNode.GotoLastChild   ()  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_SET_BOOKMARK">
            <summary>ITraceNode.SetBookmark (bool enabled)  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_VISIBLE_NODE">
            <summary>ITraceNode.SetVisible  (visible)  </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CLEAR_NODE">
            <summary>Delete the node on the viewer</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CLEAR_SUBNODES">
            <summary>Delete children node on the viewer</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_THREAD_ID">
            <summary>The Thread ID of the sender thread (optional).Used when tracing multiple thread (actived by default)</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_PROCESS_NAME">
            <summary>The process name (optional).Used when tracing multiple process </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_MESSAGE_TIME">
            <summary>The time of trace</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_THREAD_NAME">
            <summary>Thread name (Java or user defined)</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_IP">
            <summary>Client Ip adress</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_NEW_NODE">
            <summary>Command to create a new trace node</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_LEFT_MSG">
            <summary>The left message ("traces column")</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_RIGHT_MSG">
            <summary>the right message ("Comment column")</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_SELECT_NODE">
            <summary>set the node as 'Selected' by the user</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_USE_NODE">
            <summary>use an existing node</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_APPEND_LEFT_MSG">
            <summary>The left message to append to "traces column"</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_APPEND_RIGHT_MSG">
            <summary>The right message to append to "Comment column"</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_FOCUS_NODE">
            <summary>Focus to the node</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_FONT_DETAIL">
            <summary>Font detail : ColId Bold Italic Color(BGR) size  Fontname</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_BACKGROUND_COLOR">
            <summary>Background color</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_CREATE_MEMBER">
            <summary>Command to create a member for the current trace node</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_MEMBER_FONT_DETAIL">
            <summary>Member Font detail : ColId Bold Italic Color(BGR) size  Fontname</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_MEMBER_COL2">
            <summary>The text of the second member column</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_MEMBER_VIEWER_KIND">
            <summary>Viewer kind id</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_MEMBER_COL3">
            <summary>The text of the third member column</summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceConst.CST_ADD_MEMBER">
            <summary>Add the member. Close the previous CST_CREATE_MEMBER </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.COPYDATASTRUCT">
            <summary>
            The windows structure to send data to another process
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.COPYDATASTRUCT.dwData">
            <summary>
            The identifiant of the message (checked at destination)
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.COPYDATASTRUCT.cbData">
            <summary>
            The number of byte to send
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.COPYDATASTRUCT.lpData">
            <summary>
            The message to send
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.Helper">
            <summary>
            Define all windows functions used by the TraceTool namespace
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.SendMessage(System.Int32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The windows function that send a message to a windows handle
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.PostMessage(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            The windows function that send a message to a windows handle
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.FindWindow(System.String,System.String)">
            <summary>
            The windows function that search a windows
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.GetCurrentThreadId">
            <summary>
            Return the current thread id (Win Ce / win 32)
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.GetCurrentProcessName">
            <summary>
            Return the current process name with path (Win Ce / win 32)
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.NewGuid">
            <summary>
            Return a new System.Guid object.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.ARGB_to_BGR(System.Int32)">
            <summary>
            convert a ARGB color (dotnet) to a BGR color (windows)
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.HtmlEncode(System.String,System.Text.StringBuilder)">
            <summary>
            Html encode. To reduce dependencies, the HttpUtility.HtmlEncode is reproduce here, with StringBuilder as target (faster)
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.addCommand(Comm.Utils.TraceTool.StringList,System.Int32)">
            code only
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.addCommand(Comm.Utils.TraceTool.StringList,System.Int32,System.Int32)">
            code + int
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.addCommand(Comm.Utils.TraceTool.StringList,System.Int32,System.Boolean)">
            code + bool
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.addCommand(Comm.Utils.TraceTool.StringList,System.Int32,System.String)">
            code + string
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.addCommand(Comm.Utils.TraceTool.StringList,System.Int32,System.Int32,System.String)">
            code + int + string
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.addCommand(Comm.Utils.TraceTool.StringList,System.Int32,System.Int32,System.Int32,System.String)">
            code + int + int + string
        </member>
        <member name="M:Comm.Utils.TraceTool.Helper.addCommand(Comm.Utils.TraceTool.StringList,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            code + int + int + int + string
        </member>
        <member name="T:Comm.Utils.TraceTool.TMemberNode">
            <summary>
            TMemberNode represent a node inside the right object tree
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TMemberNode.Col1">
            <summary>
            The 3 columns to display
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TMemberNode.Col2">
            <summary>
            The 3 columns to display
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TMemberNode.Col3">
            <summary>
            The 3 columns to display
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TMemberNode.Members">
            <summary>
            an array of sub members (TMemberNode)
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TMemberNode.ViewerKind">
            <summary>
             Viewer kind. determine how the node will display members
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TMemberNode.Tag">
            <summary>
             User defined tag, NOT SEND to the viewer
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.#ctor">
            <summary>
            Create a TMemberNode with no text in the 3 columns
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.#ctor(System.String)">
            <summary>
            Create a TMemberNode with a text for the first column
            </summary>
            <param name="col1">text of col1</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.#ctor(System.String,System.String)">
            <summary>
            Create a TMemberNode with text for the first 2 columns
            </summary>
            <param name="col1">text of col1</param>
            <param name="col2">text of col2</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a TMemberNode with text for the 3 columns
            </summary>
            <param name="col1">text of col1</param>
            <param name="col2">text of col2</param>
            <param name="col3">text of col3</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.Add(Comm.Utils.TraceTool.TMemberNode)">
            <summary>
            Add a member to the members list
            </summary>
            <param name="member"></param>
            <returns>The TMember node to add</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.Add(System.String)">
            <summary>
            Create a TMemberNode with a text for the first column
            </summary>
            <param name="col1">text of first col</param>
            <returns>The TMember node to add</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.Add(System.String,System.String)">
            <summary>
            Create a TMemberNode with text for the first 2 columns
            </summary>
            <param name="col1">text of first col</param>
            <param name="col2">text of second col</param>
            <returns>The TMember node to add</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.Add(System.String,System.String,System.String)">
            <summary>
            Create a TMemberNode with text for the 3 columns
            </summary>
            <param name="col1">text of first col</param>
            <param name="col2">text of second col</param>
            <param name="col3">text of third col</param>
            <returns>The TMember node to add</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.SetFontDetail(System.Int32,System.Boolean)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="ColId">Column index : All columns=-1, Col1=0, Col2=1, Col3=2</param>
            <param name="Bold">Change font to bold</param>
            <returns>The TMember node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.SetFontDetail(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="ColId">Column index : All columns=-1, Col1=0, Col2=1, Col3=2</param>
            <param name="Bold">Change font to bold</param>
            <param name="Italic">Change font to Italic</param>
            <returns>The TMember node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.SetFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="ColId">Column index : All columns=-1, Col1=0, Col2=1, Col3=2</param>
            <param name="Bold">Change font to bold</param>
            <param name="Italic">Change font to Italic</param>
            <param name="Color">Change Color. To reduce the number assembly reference, the Color structure is not used. Use YourColor.ToArgb() instead. </param>
            <returns>The TMember node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.SetFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="ColId">Column index : All columns=-1, Col1=0, Col2=1, Col3=2</param>
            <param name="Bold">Change font to bold</param>
            <param name="Italic">Change font to Italic</param>
            <param name="Color">Change Color. To reduce the number assembly reference, the Color structure is not used. Use YourColor.ToArgb() instead. Use -1 to keep default color</param>
            <param name="Size">Change font size</param>
            <returns>The TMember node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.SetFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="ColId">Column index : All columns=-1, Col1=0, Col2=1, Col3=2</param>
            <param name="Bold">Change font to bold</param>
            <param name="Italic">Change font to Italic</param>
            <param name="Color">Change Color. To reduce the number assembly reference, the Color structure is not used. Use YourColor.ToArgb() instead. Use -1 to keep default color</param>
            <param name="Size">Change font size, use zero to keep normal size</param>
            <param name="FontName">Change font name</param>
            <returns>The TMember node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TMemberNode.AddToStringList(Comm.Utils.TraceTool.StringList)">
            <summary>
            recursively add members to the node CommandList
            </summary>
            <param name="CommandList">target command list</param>
        </member>
        <member name="T:Comm.Utils.TraceTool.ITracePLugin">
            <summary>
            Plugin interface. Inherit from this interface to create a TraceTool plugin
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ITracePLugin.GetPlugName">
            <summary>
            Get the plugin name
            </summary>
            <returns>
            plugin name 
            </returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.ITracePLugin.OnAction(System.String,System.Int32,System.String)">
            <summary>
            Called when the user click on a button, label or menu on a WinTrace.
            The plugin must call WinTrace.LinkToPlugin in order to receive this event
            </summary>
            <param name="WinId">Wintrace Id</param>
            <param name="ResourceId">Resource Id</param>
            <param name="NodeId">Node id of the current selected trace (can be empty)</param>
            <returns>
             when true  : tracetool perform the default action
             when false : tracetool don't perform any action
            </returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.ITracePLugin.OnBeforeDelete(System.String,System.String)">
            <summary>
            Called when a node is to be deleted on a WinTrace
            The plugin must call WinTrace.LinkToPlugin in order to receive this event
            </summary>
            <param name="WinId">Wintrace Id</param>
            <param name="NodeId">Node Id</param>
            <returns>
             when true  : tracetool delete the node
             when false : tracetool don't delete the node
            </returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.ITracePLugin.OnTimer">
            <summary>
            Called every 500 ms. Can be used for example to refresh labels
            The plugin must call LinkToPlugin in order to receive this event
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ITracePLugin.Start">
            <summary>
            Initialise the plugin
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ITracePLugin.Stop">
            <summary>
            Stop the plugin
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.ReflectionHelper">
            <summary>
            Helper for reflection. You can use it your project without TraceTool
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.Type2ShortString(System.Type)">
            <summary>
            return the name of the type or element type if reference
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.ArrayBounds(System.Array)">
            <summary>
            return the list of bounds : 1..2, 0..3 , 1..1
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.Type2String(System.Type,System.String@,System.String@)">
            <summary>
            return the modifiers and the name of a type
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.Constructor2String(System.Reflection.ConstructorInfo,System.String@,System.String@)">
            <summary>
            return the modifiers and the name of a constructor (similar to a method)
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.getFieldModifier(System.Reflection.FieldInfo)">
            <summary>
            return the modifiers of a field
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.Field2String(System.Reflection.FieldInfo,System.String@,System.String@)">
            <summary>
            return the modifiers and the name of a field
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.Property2String(System.Reflection.PropertyInfo,System.String@,System.String@,System.String@,System.Boolean@)">
            <summary>
            return the modifiers and the name of a property
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.event2String(System.Reflection.EventInfo,System.String@,System.String@)">
            <summary>
            return the modifiers and the name of an event
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.Method2String(System.Reflection.MethodInfo,System.String@,System.String@)">
            <summary>
            Give the modifiers and the name of a method
            if the method is an operator, the method return true
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.Method2StringModifier(System.Reflection.MethodBase)">
            <summary>
            return the modifier (private,...) of a method (without the method type and name)
            called by Property2String,Constructor2String and Method2String
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.MethodParams2String(System.Reflection.MethodBase)">
            <summary>
            return the parameters name and type of a method
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.MethodParamsType2String(System.Reflection.MethodBase)">
            <summary>
            return the parameters type of a method , usefull to retreive XML documentation for a method
            parenthesis are included only if parameters exists
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.PropertyParamsType2String(System.Reflection.PropertyInfo)">
            <summary>
            return the parameters type of a property , usefull to retreive XML documentation for a property
            parenthesis are included only if parameters exists
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.IsDefaultMember(System.Type,System.Reflection.MemberInfo)">
            <summary>
            indicate if the member is one of the "default" member.
            I don't know how to specify 2 "default", but ...
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.IsArray(System.Type)">
            <summary>
            indicate if the type is an aray.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.IsDelegate(System.Type)">
            <summary>
            indicate if the type is a delegate.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.ReflectionHelper.AssemblyDocumentationFileName(System.Type)">
            <summary>
            return the name of the XML assembly documentation file for a type.Empty string if not found
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.TTraceListener">
            <summary>
            TTraceListener is the trace listener, if you want to use the classic Microsoft Trace class.
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TTraceListener.listener">
            <summary>
            Specify at any time what is top node that receive the traces
            </summary>
        </member>
        <member name="P:Comm.Utils.TraceTool.TTraceListener.CurrentNode">
            <summary>
            the current node (read only)
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TTraceListener.#ctor">
            <summary>
            Create a listener. TTrace.Debug is used to send traces
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TTraceListener.#ctor(Comm.Utils.TraceTool.TraceNode)">
            <summary>
            Create a listener giving a TraceNode as the parent node.
            </summary>
            <param name="TraceDoor">Specify Debug,Warning,Error or user TraceNode object</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TTraceListener.Write(System.String)">
            <summary>
            Send message to TTrace
            </summary>
            <param name="message">the message</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TTraceListener.WriteLine(System.String)">
            <summary>
            Send message to TTrace
            </summary>
            <param name="message">the message</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TTraceListener.WriteIndent">
            <summary>
            Force creation of new trace node
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.TraceNode">
            <summary>
            TraceNode represent node on the viewer.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.#ctor(Comm.Utils.TraceTool.TraceNode,System.Boolean)">
            <summary>
            Internal constructor. Use TTrace or TraceNodeEx class as entry point
            create a Node with an unique ID (true)
            </summary>
            <param name="ParentNode">The parent node where to place that trace.
            The IconIndex and the enabled properties are also recopied
            Can be null : the root tree become the parent node, enabled is true and the default icon is used
            </param>
            <param name="generateUniqueId">When true, a unique ID (a guid) is generated for the trace.
            </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.#ctor(Comm.Utils.TraceTool.TraceToSend)">
            <summary>
            Copy constructor : create a TraceNode copy of a TraceToSend
            </summary>
            <param name="Source">TraceNode to copy</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.#ctor(Comm.Utils.TraceTool.TraceNodeEx)">
            <summary>
            Copy constructor : create a TraceNode copy of a TraceNodeEx
            </summary>
            <param name="Source">TraceNodeEx to copy</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.Resend(System.String,System.String)">
            <summary>
            Resend the left and right trace message to the viewer
            </summary>
            <param name="NewLeftMsg">new left message</param>
            <param name="NewRightMsg">new right message</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.ResendLeft(System.String)">
            <summary>
            ReSend left trace to the server
            </summary>
            <param name="NewLeftMsg">new left message</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.ResendRight(System.String)">
            <summary>
            ReSend right trace to the server
            </summary>
            <param name="NewRightMsg">new right message</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.ResendIconIndex(System.Int32)">
            <summary>
            Change the Icon index
            </summary>
            <param name="Index">Index of the icon to use</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetBackgroundColor(System.Int32)">
            <summary>
            Change Background Color (whole line) of a node
            </summary>
            <param name="color">new background color of the node</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetBackgroundColor(System.Int32,System.Int32)">
            <summary>
            Change Background Color (specific column) of a node
            </summary>
            <param name="color">new background color of the node</param>
            <param name="colId">Column index : All columns=-1, Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetFontDetail(System.Int32,System.Boolean)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns=-1, Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetFontDetail(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns=-1, Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <param name="italic">Change font to Italic</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns=-1, Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <param name="italic">Change font to Italic</param>
            <param name="color">Change Color. To reduce the number assembly reference, the Color structure is not used. Use YourColor.ToArgb() instead. </param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns=-1, Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <param name="italic">Change font to Italic</param>
            <param name="color">Change Color. To reduce the number assembly reference, the Color structure is not used. Use YourColor.ToArgb() instead. Use -1 to keep default color</param>
            <param name="size">Change font size</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns=-1, Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <param name="italic">Change font to Italic</param>
            <param name="color">Change Color. To reduce the number assembly reference, the Color structure is not used. Use YourColor.ToArgb() instead. Use -1 to keep default color</param>
            <param name="size">Change font size, use zero to keep normal size</param>
            <param name="fontName">Change font name</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.Append(System.String,System.String)">
            <summary>
            append right and left texts to an existing node
            </summary>
            <param name="LeftMsgtoAdd">left message</param>
            <param name="RightMsgtoAdd">right message</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.AppendLeft(System.String)">
            <summary>
            append left text to an existing node
            </summary>
            <param name="LeftMsgtoAdd">left message</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.AppendRight(System.String)">
            <summary>
            append right text to an existing node
            </summary>
            <param name="RightMsgtoAdd">right message</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.Show">
            <summary>
            Show the node in the tree (not means selected, just visible in the tree)
            </summary>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetSelected">
            <summary>
            Select the node in the viewer
            </summary>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.Delete">
            <summary>
            Delete the node
            </summary>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.DeleteChildren">
            <summary>
            Delete children node
            </summary>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetBookmark(System.Boolean)">
            <summary>
            Set or reset the bookmark for the node
            </summary>
            <param name="Bookmarked">true/false</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.SetVisible(System.Boolean)">
            <summary>
            set a node visible or invisible
            </summary>
            <param name="Visible">true/false</param>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.GotoNextSibling">
            <summary>
            Set focus to next sibling
            </summary>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.GotoPrevSibling">
            <summary>
            Set focus to previous sibling
            </summary>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.GotoFirstChild">
            <summary>
            Set focus to first child
            </summary>
            <returns>The trace node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNode.GotoLastChild">
            <summary>
            Set focus to last child
            </summary>
            <returns>The trace node</returns>
        </member>
        <member name="T:Comm.Utils.TraceTool.TraceNodeBase">
            <summary>
            base class for TraceToSend (TraceNode, Wintrace) and traceNodeEx
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeBase.Id">
            <summary>
            The unique ID. Normally it's a GUID, but can be replaced by something else for interprocess traces.
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeBase.Enabled">
            <summary>
            When Enabled is false, all traces are disabled. Default is true.
            All node have a Enabled property, that lets you define group of Enabled trace.
            For example set the TTrace.Debug.enabled to false but continue to accept Error and Warning traces
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeBase.WinTraceId">
            <summary>
            The window where trace is send.
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeBase.Tag">
            <summary>
            User variable, provided for the convenience of developers
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeBase.IconIndex">
            <summary>
            The index of the icon to use. You can then show an icon for Warning traces different for Error traces
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeBase.ToString">
            <summary>
            return the node id
            </summary>
            <returns>node id</returns>
        </member>
        <member name="T:Comm.Utils.TraceTool.TraceNodeEx">
            <summary> Alternate way to send traces : prepare a TraceNode with all properties then send it.
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeEx.ParentNodeId">
            <summary>
            The Id of the parent node
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeEx.LeftMsg">
            <summary>
            The left part of the tree message
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeEx.RightMsg">
            <summary>
            The right part of the tree message
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeEx.Time">
            <summary>
            time
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeEx.ThreadName">
            <summary>
            thread name
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeEx.Members">
            <summary>
            the root for the Member tree
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.#ctor">
            <summary>
            create a Node with an unique ID
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.#ctor(Comm.Utils.TraceTool.TraceToSend)">
            <summary>
            create a Node with an unique ID (true)
            </summary>
            <param name="ParentNode">The parent node where to place that trace.
            The IconIndex and the enabled properties are also recopied
            Can be null : the root tree become the parent node, enabled is true and the default icon is used
            </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.#ctor(Comm.Utils.TraceTool.TraceToSend,System.Boolean)">
            <summary>
            Create a Node.
            </summary>
            <param name="ParentNode">The parent node where to place that trace.
            The IconIndex and the enabled properties are also recopied
            Can be null : the root tree become the parent node, enabled is true and the default icon is used
            </param>
            <param name="generateUniqueId">if true, the id is generated automatically, else set the empty string
            </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddObject(System.Object)">
            <summary>
            Call AddObject to fill the "member" tree with the object description
            </summary>
            <param name="ObjToSend"></param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddObject(System.Object,Comm.Utils.TraceTool.TraceDisplayFlags)">
            <summary>
            Call AddObject to fill the "member" tree with the object description
            </summary>
            <param name="ObjToSend">Object to send</param>
            <param name="flags">determine what information to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddType(System.Type)">
            <summary>
            Call AddType to fill the "member" tree with the object type
            </summary>
            <param name="typeToSend">Object type to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddType(System.Type,Comm.Utils.TraceTool.TraceDisplayFlags)">
            <summary>
            Call AddType to fill the "member" tree with the object type
            </summary>
            <param name="typeToSend">Object type to send</param>
            <param name="flags">determine what infrmation to send</param>
        </member>
        <member name="F:Comm.Utils.TraceTool.TraceNodeEx.SendObjectRecursiveStatus">
            <summary>
            SendObjectRecursiveStatus is used to block recursive call to AddTypeObject
            since AddTypeObject will try to evaluate field GET method.
            If the GET method call AddObject or similar function,
            we have a possible recursive call (with stack overflow).
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddTypeObject(System.Object,System.Type,Comm.Utils.TraceTool.TraceDisplayFlags)">
            fill the Members member with a type description and optional values of that type
            caller : AddType, AddObject
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddDocumentation(System.Object,Comm.Utils.TraceTool.TMemberNode,System.Type,System.Reflection.MemberInfo)">
             <summary>
             add documentation for a type or a member
             </summary>
            
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.displayCustomAttrib(Comm.Utils.TraceTool.TMemberNode,System.Object[])">
            add the attributes stored in the given parameter to the submembers
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddValue(System.Object)">
            <summary>
            Call AddValue to fill the "member" tree with the object value.
            </summary>
            <param name="ObjToSend">Object to display</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddValue(System.Object,System.Boolean)">
            <summary>
            Call AddValue to fill the "member" tree with the object value.
            </summary>
            <param name="ObjToSend">Object to display</param>
            <param name="SendPrivate">Display private fields</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddValue(System.Object,System.Boolean,System.Int32)">
            <summary>
            Call AddValue to fill the "member" tree with the object value.
            </summary>
            <param name="ObjToSend">Object to display</param>
            <param name="sendPrivate">Display private fields</param>
            <param name="maxLevel">Number of sub component to display in tree</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddValue(System.Object,System.Boolean,System.Int32,System.String)">
            <summary>
            Call AddValue to fill the "member" tree with the object value.
            </summary>
            <param name="ObjToSend">Object to display</param>
            <param name="sendPrivate">Display private fields</param>
            <param name="maxLevel">Number of sub component to display in tree</param>
            <param name="objTitle">Title to display for the object</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.addAllFieldsValue(System.Object,System.Type,Comm.Utils.TraceTool.TMemberNode,System.Boolean,System.Int32,Comm.Utils.TraceTool.ParsedObjectList)">
            Display all fields (with corresponding value) of the type
            Called by AddValue(), not by AddObject()
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.addProperties(System.Object,System.Type,Comm.Utils.TraceTool.TMemberNode,System.Boolean,System.Int32,Comm.Utils.TraceTool.ParsedObjectList)">
            Display all properties (with corresponding value, if any) of the type
            Called by AddValue(), not by AddObject()
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.DisplayBases(System.Type,Comm.Utils.TraceTool.TraceDisplayFlags)">
            show the type with its interfaces, and base classes.
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.DisplayNestedTypes(System.Type,System.Object,Comm.Utils.TraceTool.TraceDisplayFlags)">
            show nested type names (not the content)
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.DisplayFields(System.Object,System.Type,System.Object,Comm.Utils.TraceTool.TraceDisplayFlags)">
            Display all fields (with corresponding value) of the type
            Called by AddObject(), not by AddValue()
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.DisplayDependencyProperties(System.Object)">
            caller : AddTypeObject (caller : AddType, AddObject)
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.DisplayProperties(System.Object,System.Type,System.Object,Comm.Utils.TraceTool.TraceDisplayFlags)">
            Display all properties (with corresponding value, if any) of the type
            Called by AddObject(), not by AddValue()
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.DisplayConstructors(System.Object,System.Type,System.Object,Comm.Utils.TraceTool.TraceDisplayFlags)">
            display all Constructors of a type
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.DisplayMethods(System.Object,System.Type,System.Object,Comm.Utils.TraceTool.TraceDisplayFlags)">
            display all Methods of a type
            Note that Operators are method but will be displayed in a separate group
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.DisplayEvents(System.Object,System.Type,System.Object,Comm.Utils.TraceTool.TraceDisplayFlags)">
            display all Events of a type
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddStackTrace">
            <summary>
            Add the stack frame to the Members.
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddStackTrace(System.Int32)">
            <summary>
            Add the stack frame to the Members.
            </summary>
            <param name="level">start level (default 1)</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddCaller">
            <summary>
            Add the caller frame to the Members. Level 0 is self
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddCaller(System.Int32)">
            <summary>
            Add the caller stack information. It's like the call stack, but display only 1 line
            </summary>
            <param name="level">Level 0 is self</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddBitmap(System.Drawing.Image)">
            <summary>
            Add a bitmap
            </summary>
            <param name="image">The Image</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddDump(System.String,System.Byte[],System.Int32)">
            <summary>
            Add byte dump to the Members
            </summary>
            <param name="shortTitle">Tite to display in the first col</param>
            <param name="bytes">Pointer to the buffer to dump</param>
            <param name="count">Number of bytes to dump</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddDump(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add byte dump to the Members
            </summary>
            <param name="shortTitle">Tite to display in the first col</param>
            <param name="bytes">Pointer to the buffer to dump</param>
            <param name="index">start offset</param>
            <param name="count">Number of byte to dump</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddXML(System.String)">
            <summary>
            Add xml text
            </summary>
            <param name="xml">xml text to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddTable(Comm.Utils.TraceTool.TraceTable)">
            <summary>
            Add table to node
            </summary>
            <param name="table">table to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddTable(System.Object)">
            <summary>
            Add table to node
            </summary>
            <param name="list">Object table to send. Must be an Array or IEnumerable or IDictionary</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddBackgroundColor(System.Int32)">
            <summary>
            Change background font color
            </summary>
            <param name="color">RGB background color (see Color.ToArgb function)</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddBackgroundColor(System.Int32,System.Int32)">
            <summary>
            Change background font color
            </summary>
            <param name="color">RGB background color (see Color.ToArgb function)</param>
            <param name="colId">Column index : All columns= -1,Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddFontDetail(System.Int32,System.Boolean)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns= -1,Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <returns>The TraceNodeEx</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddFontDetail(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns= -1,Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <param name="italic">Change font to italic</param>
            <returns>The TraceNodeEx</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns= -1,Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <param name="italic">Change font to italic</param>
            <param name="color">RGB color (see Color.ToArgb function). Use -1 to keep default color</param>
            <returns>The TraceNodeEx</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns= -1,Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <param name="italic">Change font to italic</param>
            <param name="color">RGB color (see Color.ToArgb function). Use -1 to keep default color</param>
            <param name="size">Change font size, use zero to keep normal size</param>
            <returns>The TraceNodeEx</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.AddFontDetail(System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)">
            <summary>
            Change font detail for an item in the trace
            </summary>
            <param name="colId">Column index : All columns= -1,Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <param name="bold">Change font to bold</param>
            <param name="italic">Change font to italic</param>
            <param name="color">RGB color (see Color.ToArgb function). Use -1 to keep default color</param>
            <param name="size">Change font size, use zero to keep normal size</param>
            <param name="fontName">Change font name</param>
            <returns>The TraceNodeEx</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.Send">
            <summary>
            Send the trace to the server (left + right + members)
            </summary>
            <returns>a TraceNode for furthers changes</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceNodeEx.Resend">
            <summary>
            Resend the trace to the server (only left and right message)
            </summary>
        </member>
        <member name="T:Comm.Utils.TraceTool.TraceTable">
            <summary>
            TraceTable class : construct a table of row to display in the viewer on a node.
            The table must be associated with a node. see TraceNodeEx.AddTable() and TraceToSend.SendTable()
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceTable.#ctor">
            <summary>
            create a table
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceTable.AddColumnTitle(System.String)">
            <summary>
            Add columns title : one or more columns titles separated by tabs
            </summary>
            <param name="colTitle">one or more columns titles separated by tabs. Can also be called several times to add titles</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceTable.AddRow">
            <summary>
            Add an empty row
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceTable.AddRowData(System.String)">
            <summary>
            Add data to current row
            </summary>
            <param name="cell">one or more columns data separated by tabs. Can also be called several times to add cells</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceTable.CopyToNodeMembers(Comm.Utils.TraceTool.TMemberNode)">
            <summary>
            convert to members
            </summary>
            <param name="nodeMembers">target</param>
        </member>
        <member name="T:Comm.Utils.TraceTool.TraceToSend">
            TraceToSend methodes create new traces and send it to the viewer
            Common base class for TraceNode and WinTrace
            TTrace.warning, debug and error are TraceNode
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.Send(System.String)">
            <summary>
            The most useful function to send trace
            <example> This sample shows how to send a sample trace.
            <code>
            TTrace.Debug.Send ("Hello world") ;
            </code>
            <code>
            TraceNode FirstNode ;
            FirstNode = TTrace.Debug.Send ("Hello") ;
            FirstNode.Send ("World") ;   // add a second node under the first one
            </code>
            </example>
            </summary>
            <param name="leftMsg">The message to display in the 'traces' column</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.Send(System.String,System.String)">
            <summary>
            Send a trace specifying the text for 2 columns
            <example> This sample shows how to send a sample trace.
            <code>
            TTrace.Debug.Send ("Hello", "world") ;  // 2 columns trace
            </code>
            </example>
            </summary>
            <param name="leftMsg">The message in the "traces" column</param>
            <param name="rightMsg">The message in the "Comment" column</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendObject(System.String,System.Object)">
            <summary>
            Send a 'reflected' representation of the given object
            </summary>
            <param name="leftMsg">the message to display</param>
            <param name="ObjToSend">The object to inspect</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendObject(System.String,System.Object,Comm.Utils.TraceTool.TraceDisplayFlags)">
            <summary>
            Send a 'reflected' representation of the given object
            </summary>
            <param name="leftMsg">the message to display</param>
            <param name="ObjToSend">The object to inspect</param>
            <param name="flags">what information to display</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendValue(System.String,System.Object)">
            <summary>
            Send the Value of the given object (useful for base type, variant and array)
            properties and array content are also inspected with a maximum
            </summary>
            <param name="leftMsg">the message to display</param>
            <param name="ObjToSend">The object to show</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendValue(System.String,System.Object,System.Boolean)">
            <summary>
            Send the Value of the given object (useful for base type, variant and array)
            </summary>
            <param name="leftMsg">the message to display</param>
            <param name="ObjToSend">The object to show</param>
            <param name="sendPrivate">Send Private fields (default is false)</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendValue(System.String,System.Object,System.Boolean,System.Int32)">
            <summary>
            Send the Value of the given object (useful for base type, variant and array)
            </summary>
            <param name="leftMsg">the message to display</param>
            <param name="ObjToSend">The object to show</param>
            <param name="sendPrivate">Send Private fields (default is false)</param>
            <param name="maxLevel">Max level to inspect (default is 3)</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendValue(System.String,System.Object,System.Boolean,System.Int32,System.String)">
            <summary>
            Send the Value of the given object (useful for base type, variant and array)
            </summary>
            <param name="leftMsg">the message to display</param>
            <param name="ObjToSend">The object to show</param>
            <param name="sendPrivate">Send Private fields (default is false)</param>
            <param name="maxLevel">Max level to inspect (default is 3)</param>
            <param name="objTitle">Title of the object</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendType(System.String,System.Type)">
            <summary>
            Send a 'reflected' representation of the given type
            </summary>
            <param name="leftMsg">The message to display</param>
            <param name="oType">The type to inspect</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendType(System.String,System.Type,Comm.Utils.TraceTool.TraceDisplayFlags)">
            <summary>
            Send a 'reflected' representation of the given type
            </summary>
            <param name="leftMsg">The message to display</param>
            <param name="oType">The type to inspect</param>
            <param name="flags">flags to limit information to send</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendStack(System.String,System.Int32)">
            <summary>
            Send the stack frames.
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="level">Number of call to skip</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendCaller(System.String,System.Int32)">
            <summary>
            Send the caller frame.
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="level">Level 0 is self</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendBitmap(System.String,System.Drawing.Image)">
            <summary>
            Send a bitmap
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="image">The Image</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendDump(System.String,System.String,System.Byte[],System.Int32)">
            <summary>
            Send byte dump.
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="ShortTitle">Tite to display in the first col</param>
            <param name="adr">Pointer to the buffer to dump</param>
            <param name="count">Number of byte to dump</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendBackgroundColor(System.String,System.Int32)">
            <summary>
            send trace with a specific background color
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="color">RGB background color (see Color.ToArgb function)</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendBackgroundColor(System.String,System.Int32,System.Int32)">
            <summary>
            send trace with a specific background color
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="color">RGB background color (see Color.ToArgb function)</param>
            <param name="colId">Column index : All columns= -1,Icon=0, Time=1, thread=2, left msg=3, right msg =4 or user defined column</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendXml(System.String,System.String)">
            <summary>
            Send xml text
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="xml">xml text to send</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendTable(System.String,Comm.Utils.TraceTool.TraceTable)">
            <summary>
            Add table to node
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="table">table to send</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.SendTable(System.String,System.Object)">
            <summary>
            Add table to node
            </summary>
            <param name="leftMsg">Trace message</param>
            <param name="table">Object table to send. Must be an Array or IEnumerable or IDictionary</param>
            <returns>the new node</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.prepareNewNode(System.String,System.String)">
            Prepare the commandList. Common to all SendXXX function
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.GetLastContext">
            Get the last context.
            @return last context for the thread
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.GetLastContextId">
            Get the last context ID.
            @return last context ID for the thread
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.PushContext(Comm.Utils.TraceTool.NodeContext)">
            Save the context
            @param newContext the context to push
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.DeleteLastContext">
            Delete the last context for the thread
        </member>
        <member name="P:Comm.Utils.TraceTool.TraceToSend.IndentLevel">
            <summary>
            return current indent level. See Indent()
            </summary>
            <returns>current indent level</returns>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.Indent(System.String)">
            <summary>
            Send a message. further trace to the same node are indented under this one.
            </summary>
            <param name="leftMsg">Left message to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.Indent(System.String,System.String)">
            <summary>
            Send a message. further trace to the same node are indented under this one.
            </summary>
            <param name="leftMsg">Left message to send</param>
            <param name="rightMsg">Right message to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.Indent(System.String,System.String,System.Int32)">
            <summary>
            Send a message. further trace to the same node are indented under this one.
            </summary>
            <param name="leftMsg">Left message to send</param>
            <param name="rightMsg">Right message to send</param>
            <param name="BackGroundColor">RGB BackGround Color (see Color.ToArgb function)</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.Indent(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Send a message. further trace to the same node are indented under this one.
            </summary>
            <param name="leftMsg">Left message to send</param>
            <param name="rightMsg">Right message to send</param>
            <param name="BackGroundColor">BackGround Color</param>
            <param name="IsEnter">if true , a special "enter" icon is added on the node</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.UnIndent">
            <summary>
            Delete indentation to the node added by indent()
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.UnIndent(System.String)">
            <summary>
            Delete indentation to the node added by indent()
            </summary>
            <param name="leftMsg">Message to send to close indentation (optional)</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.UnIndent(System.String,System.String)">
            <summary>
            Delete indentation to the node added by indent()
            </summary>
            <param name="leftMsg">Message to send to close indentation (optional)</param>
            <param name="rightMsg">Message to send to close indentation (optional)</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.UnIndent(System.String,System.String,System.Int32)">
            <summary>
            Delete indentation to the node added by indent()
            </summary>
            <param name="leftMsg">Message to send to close indentation (optional)</param>
            <param name="rightMsg">Message to send to close indentation (optional)</param>
            <param name="BackGroundColor">RGB background color (optional)(see Color.ToArgb function)</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.UnIndent(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Delete indentation to the node added by indent()
            </summary>
            <param name="leftMsg">Message to send to close indentation (optional)</param>
            <param name="rightMsg">Message to send to close indentation (optional)</param>
            <param name="BackGroundColor">RGB background color (optional)(see Color.ToArgb function)</param>
            <param name="isExit">if true, viewer type 'exit' is used</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.EnterMethod(System.String)">
            <summary>
            Indent with "Enter " + left message + right message (optional) + background color (optional)
            </summary>
            <param name="leftMsg">Left message to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.EnterMethod(System.String,System.String)">
            <summary>
            Indent with "Enter " + left message + right message (optional) + background color (optional)
            </summary>
            <param name="leftMsg">Left message to send</param>
            <param name="rightMsg">Right message to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.EnterMethod(System.String,System.String,System.Int32)">
            <summary>
            Indent with "Enter " + left message + right message (optional) + background color (optional)
            </summary>
            <param name="leftMsg">Left message to send</param>
            <param name="rightMsg">Right message to send</param>
            <param name="BackGroundColor">RGB BackGround Color(see Color.ToArgb function)</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.ExitMethod">
            <summary>
            UnIndent with "Exit " + left message (optional) + right message (optional) + background color (optional)
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.ExitMethod(System.String)">
            <summary>
            UnIndent with "Exit " + left message (optional) + right message (optional) + background color (optional)
            </summary>
            <param name="leftMsg">Left message to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.ExitMethod(System.String,System.String)">
            <summary>
            UnIndent with "Exit " + left message (optional) + right message (optional) + background color (optional)
            </summary>
            <param name="leftMsg">Left message to send</param>
            <param name="rightMsg">Right message to send</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.TraceToSend.ExitMethod(System.String,System.String,System.Int32)">
            <summary>
            UnIndent with "Exit " + left message (optional) + right message (optional) + background color (optional)
            </summary>
            <param name="leftMsg">Left message to send</param>
            <param name="rightMsg">Right message to send</param>
            <param name="BackGroundColor">RGB BackGround Color(see Color.ToArgb function)</param>
        </member>
        <member name="T:Comm.Utils.TraceTool.WinTrace">
            <summary>
            WinTrace represent a windows tree where you put traces
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.#ctor">
            <summary>
            WinTrace constructor : you can map a WinTrace to an existing window
            Nothing is send to the viewer
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.#ctor(System.String,System.String)">
            <summary>
            WinTrace constructor. The Window Trace is create on the viewer (if not already done)
            </summary>
            <param name="WinTraceID">Required window trace Id. If empty, a guid will be generated</param>
            <param name="WinTraceText">The Window Title on the viewer.If empty, a default name will be used</param>
        </member>
        <member name="P:Comm.Utils.TraceTool.WinTrace.Warning">
            <summary>
            Warning, Error and Debug are the 3 doors to send traces
            <example> This sample shows how to send a sample trace.
            <code>
            TTrace.Error.Send ("Hello", "world") ;       // 2 columns
            TTrace.Warning.Send ("Hello") ;              // 1 columns
            TTrace.Debug.SendObject("MyObject" , this) ; // 1 columns + members tree
            </code>
            </example>
            </summary>
        </member>
        <member name="P:Comm.Utils.TraceTool.WinTrace.Error">
            <summary>
            Warning, Error and Debug are the 3 doors to send traces
            <example> This sample shows how to send a sample trace.
            <code>
            TTrace.Error.Send ("Hello", "world") ;       // 2 columns
            TTrace.Warning.Send ("Hello") ;              // 1 columns
            TTrace.Debug.SendObject("MyObject" , this) ; // 1 columns + members tree
            </code>
            </example>
            </summary>
        </member>
        <member name="P:Comm.Utils.TraceTool.WinTrace.Debug">
            <summary>
            Warning, Error and Debug are the 3 doors to send traces
            <example> This sample shows how to send a sample trace.
            <code>
            TTrace.Error.Send ("Hello", "world") ;       // 2 columns
            TTrace.Warning.Send ("Hello") ;              // 1 columns
            TTrace.Debug.SendObject("MyObject" , this) ; // 1 columns + members tree
            </code>
            </example>
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SaveToTextfile(System.String)">
            <summary>
            Save the window tree traces to a text file
            </summary>
            <param name="FileName">file to save</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SaveToXml(System.String)">
            <summary>
            Save the window tree traces to an XML file
            </summary>
            <param name="FileName">file to save</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SaveToXml(System.String,System.String)">
            <summary>
            Save the window tree traces to an XML file
            </summary>
            <param name="FileName">file to save</param>
            <param name="StyleSheet">optional StyleSheet file name added in xml</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.LoadXml(System.String)">
            <summary>
            Load an XML file to the window tree traces
            </summary>
            <param name="FileName">file to open</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.DisplayWin">
            <summary>
            Show the window tree
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SetMultiColumn">
            <summary>
            change the tree to display user defined multiple columns
            must be called before setting column titles. The first column is the main column
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SetMultiColumn(System.Int32)">
            <summary>
            change the tree to display user defined multiple columns
            must be called before setting column titles
            </summary>
            <param name="MainColIndex">The Main column index (default is 0)</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SetLogFile(System.String,System.Int32)">
            <summary>
              Set the log file.(Path is relative to the viewer). To enabled
              log on local AND on the viewer call this function twice. To
              don't use the viewer, set the TTrace.options.SendMode to
              None.
              <code>
              The Mode can be one of the following :
              0, Viewer Log is disabled.
              1, Viewer log enabled. No size limit.
              2, Viewer log enabled. A new file is create each day (CCYYMMDD is appended to the filename)
              3, Local log is disabled
              4, Local log enabled. No size limit. Ignored in silverlight 2
              5, Local log enabled. A new file is create each day (CCYYMMDD is appended to the filename). Ignored in silverlight 2
              </code>
              </summary>
              <param name="FileName">\File to open</param>
              <param name="Mode">Local and viewer site log mode. </param>                                 
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SetLogFile(System.String,System.Int32,System.Int32)">
            <summary>
              Set the log file.(Path is relative to the viewer). To enabled
              log on local AND on the viewer call this function twice. To
              don't use the viewer, set the TTrace.options.SendMode to
              None.
              <code>
              The Mode can be one of the following :
              0, Viewer Log is disabled.
              1, Viewer log enabled. No size limit.
              2, Viewer log enabled. A new file is create each day (CCYYMMDD is appended to the filename)
              3, Local log is disabled
              4, Local log enabled. No size limit. Ignored in silverlight 2
              5, Local log enabled. A new file is create each day (CCYYMMDD is appended to the filename). Ignored in silverlight 2
              </code>
              </summary>
              <param name="FileName">\File to open</param>
              <param name="Mode">Local and viewer site log mode. </param>
              <param name="MaxLines">Number of lines before starting a new
                                     \file (default \: \-1 = unlimited). </param>                         
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.GetLocalLogFile">
            <summary>
              Return the last local log file. (when mode 4 or 5 is used). Note : Call TTrace.Flush() to ensure traces are saved
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SetColumnsTitle(System.String)">
            <summary>
            set columns title
            </summary>
            <param name="Titles">Tab separated columns titles
            Example : Title1 \t title2
            </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SetColumnsWidth(System.String)">
            <summary>
            set columns widths
            </summary>
            <param name="Widths">Tab separated columns width.
            The format for each column is width[:Min[:Max]] <p/>
            where Min and Max are optional minimum and maximum column width for resizing purpose.<p/>
            Example : 100:20:80 \t 200:50 \t 100
            </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.GotoFirstNode">
            <summary>
            Set the focus to the first trace node
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.GotoLastNode">
            <summary>
            Set the focus to the last trace node
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.FindNext(System.Boolean)">
            <summary>
            Set the focus to the next matching node
            </summary>
            <param name="SearForward">If true search down, else search up  </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.GotoBookmark(System.Int32)">
            <summary>
            Set the focus to a bookmarked node identified by his position. Bookmarks are cheched by the user or with the node.SetBookmark() function
            </summary>
            <param name="Pos">Indice of the bookmark </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.ClearBookmark">
            <summary>
            Clear all bookmarks
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.ClearFilter">
            <summary>
            Clear all filters
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.AddFilter(System.Int32,System.Int32,System.String)">
             <summary>
             Add a filter to node. Multiple calls to this function can be done. Call ApplyFilter() to apply filtering
             </summary>
             <param name="Column">Column to apply filter.<p/>
               In multicolumn mode the first column start at 0 <p/>
               In normal mode : <p/>
               col icone   = 999    <p/>
               col time    = 1      <p/>
               col thread  = 2      <p/>
               col traces  = 3      <p/>
               col Comment = 4      <p/>
               col members = 998
             </param>
             <param name="Compare">There is 5 kinds of filters : <p/>
                Equal           = 0  <p/>
                Not equal       = 1  <p/>
                contains       = 2  <p/>
                Don't contains  = 3  <p/>
                (Ignore this filter) = 4 or -1
            </param>
             <param name="Text">The text to search (insensitive) </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.ApplyFilter(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Apply filters after calls to AddFilter().
            </summary>
            <param name="ConditionAnd">If true, use an 'AND' condition for each filters, else use a "OR" </param>
            <param name="ShowMatch">If true, show node that match filter and hide others. If false hide matching node and show others</param>
            <param name="IncludeChildren">If true, search in subnodes</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.ClearAll">
            <summary>
            Clear all trace for the window tree
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.Close">
            <summary>
            Close the window tree
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.CreateResource(System.Int32,System.Int32,System.Int32,System.String)">
             <summary>
             Plugin API : Create a resource.
             </summary>
             <param name="ResId">The resource Id (must be >= 100)</param>
             <param name="ResType">Resource type. See TraceConst
             <code>
             CST_RES_BUT_RIGHT    : Button on right
             CST_RES_BUT_LEFT     : Button on left
             CST_RES_LABEL_RIGHT  : Label on right
             CST_RES_LABELH_RIGHT : Label on right HyperLink
             CST_RES_LABEL_LEFT   : Label on left
             CST_RES_LABELH_LEFT  : Label on left hyperlink
             CST_RES_MENU_ACTION  : Item menu in the Actions Menu
             CST_RES_MENU_WINDOW  : Item menu in the Windows Menu.
                                    Call CreateResource on the main win trace to create this menu item
             </code>
            </param>
             <param name="ResWidth">Width of the resource. Applicable only to button and labels</param>
             <param name="ResText">Resource text</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.DisableResource(System.Int32)">
            <summary>
            Plugin API : Disable tracetool or user created resources
            </summary>
            <param name="ResId">The resource Id
            ResId: resource id to disable. Tracetool resources :
            <code>
            CST_ACTION_CUT            : Cut. Same as copy then delete
            CST_ACTION_COPY           : Copy
            CST_ACTION_DELETE         : Delete selected
            CST_ACTION_SELECT_ALL     : Select all
            CST_ACTION_RESIZE_COLS    : Resize columns
            CST_ACTION_VIEW_INFO      : View trace info
            CST_ACTION_VIEW_PROP      : View properties
            CST_ACTION_PAUSE          : Pause
            CST_ACTION_SAVE           : SaveToFile
            CST_ACTION_CLEAR_ALL      : Clear all
            CST_ACTION_CLOSE_WIN      : Close win
            CST_ACTION_LABEL_INFO     : TracesInfo label
            CST_ACTION_LABEL_LOGFILE  : LabelLogFile label
            CST_ACTION_VIEW_MAIN      : View Main trace
            CST_ACTION_VIEW_ODS       : ODS
            CST_ACTION_OPEN_XML       : XML trace -> Tracetool XML traces
            CST_ACTION_EVENTLOG       : Event log
            CST_ACTION_TAIL           : Tail
            </code>
            </param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.SetTextResource(System.Int32,System.String)">
            <summary>
            Plugin API : Set the resource text (tracetool or user created resources), specified by his Id
            </summary>
            <param name="ResId">The resource Id </param>
            <param name="ResText">Resource text</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinTrace.LinkToPlugin(System.String,System.Int32)">
            <summary>
            Plugin API : Attach a winTrace to a plugin. Many winTrace can be attached to a plugin.
            Note that a plugin don't need to be attached to a WinTrace.
            The plugin is identified by his internal name (not dll name).
            When linked, the plugin can receive event (see ITracePLugin).
            </summary>
            <param name="PluginName">name of the plugin</param>
            <param name="flags">combinaison of CST_PLUG_ONACTION , CST_PLUG_ONBEFOREDELETE , CST_PLUG_ONTIMER</param>
        </member>
        <member name="T:Comm.Utils.TraceTool.WinWatch">
            <summary>
            WinWatch represent a windows tree where you put watches
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.WinWatch.Id">
            <summary>
            The "Required" Id of the window tree, can be any string, or a guid
            The Main window trace Id is empty
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.WinWatch.Enabled">
            <summary>
            When Enabled is false, all traces are disabled. Default is true.
            </summary>
        </member>
        <member name="F:Comm.Utils.TraceTool.WinWatch.Tag">
            <summary>
            User variable, provided for the convenience of developers
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinWatch.#ctor">
            <summary>
            WinWatch constructor : you can map a WinWatch to an existing window
            Nothing Is send to the viewer
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinWatch.#ctor(System.String,System.String)">
            <summary>
            WinWatch constructor. The Window Watch is create on the viewer (if not already done)
            </summary>
            <param name="WinWatchID">Required window trace Id. If empty, a guid will be generated</param>
            <param name="WinWatchText">The Window Title on the viewer.If empty, a default name will be used</param>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinWatch.DisplayWin">
            <summary>
            Put the window in foreground
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinWatch.ClearAll">
            <summary>
            Clear all the watches
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinWatch.Close">
            <summary>
            Clear all the watches
            </summary>
        </member>
        <member name="M:Comm.Utils.TraceTool.WinWatch.Send(System.String,System.Object)">
            <summary>
            Send a watch
            </summary>
            <param name="WatchName">Watch name</param>
            <param name="WatchValue">Watch value</param>
        </member>
        <member name="T:Comm.Utils.TimerInfo">
            <summary>
            时间记录器
            </summary>
        </member>
        <member name="T:Comm.Utils.TimerRecord">
            <summary>
            时间定位类型
            利用tracetool的过滤功能进行查看数据
            如果不需用时，可
            </summary>
        </member>
        <member name="M:Comm.Utils.TimerRecord.TraceInit(System.String[])">
            <summary>
            计时启动
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.TimerRecord.Trace_CompareFront(Comm.Utils.TimerInfo,System.String)">
            <summary>
            相对与上次计时的时差
            </summary>
            <param name="info"></param>
            <param name="strOperationName"></param>
        </member>
        <member name="M:Comm.Utils.TimerRecord.Trace_CompareInit(Comm.Utils.TimerInfo)">
            <summary>
            相对与TraceInit的计时
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:Comm.Utils.TimerRecord.TraceEnd(Comm.Utils.TimerInfo)">
            <summary>
            结束计时
            </summary>
            <param name="info"></param>
        </member>
        <member name="T:Comm.Utils.TTrace">
            <summary>
            TTrace is the entry point for all traces.
            TTrace give 3 'TraceNode' doors : Warning , Error and Debug.
            Theses 3 doors are displayed with a special icon (all of them have the 'enabled' property set to true.
            That class is fully static.
            </summary>
        </member>
        <member name="F:Comm.Utils.TTrace.nbDiscarded">
            number of message discarded (socket error)
        </member>
        <member name="F:Comm.Utils.TTrace.nbSend">
            number of message send by silverlight (socket error)
        </member>
        <member name="F:Comm.Utils.TTrace.Options">
            TTrace Options (socket, show functions, ...)
        </member>
        <member name="M:Comm.Utils.TTrace.Stop">
            <summary>
            Stop sub-system before leaving your program. You may call TTrace.Flush() before Stop()
            </summary>
        </member>
        <member name="M:Comm.Utils.TTrace.Show(System.Boolean)">
            <summary>
            Show or hide the trace program
            </summary>
            <param name="IsVisible">When True : Show. When False : Hide</param>
        </member>
        <member name="M:Comm.Utils.TTrace.Find(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Set the global search criteria. You must call TTrace.Wintrace.FindNext to position to the next or previous matching node
            </summary>
            <param name="Text">Text to search</param>
            <param name="Sensitive">Search is case sensitive</param>
            <param name="WholeWord">match only whole word</param>
            <param name="Highlight">Highlight results</param>
            <param name="SearchInAllPages">call to FindNext will search also in other traces windows if true</param>
        </member>
        <member name="M:Comm.Utils.TTrace.ClearAll">
            <summary>
            Clear all traces
            </summary>
        </member>
        <member name="M:Comm.Utils.TTrace.CloseViewer">
            <summary>
            Close the viewer
            </summary>
        </member>
        <member name="M:Comm.Utils.TTrace.CloseSocket">
            <summary>
            Close the socket
            Tips : Socket is automatically closed when destroyed. No need to create destructor
            </summary>
        </member>
        <member name="P:Comm.Utils.TTrace.WinTrace">
            <summary>
            The windows where is stored the main tree (read only)
            </summary>
        </member>
        <member name="P:Comm.Utils.TTrace.Watches">
            <summary>
            The main watches window
            </summary>
        </member>
        <member name="P:Comm.Utils.TTrace.Warning">
            <summary>
            Shortcut to WinTrace.Warning
            </summary>
        </member>
        <member name="P:Comm.Utils.TTrace.Error">
            <summary>
            Shortcut to WinTrace.Error
            </summary>
        </member>
        <member name="P:Comm.Utils.TTrace.Debug">
            <summary>
            Shortcut to WinTrace.Debug
            </summary>
        </member>
        <member name="P:Comm.Utils.TTrace.Out">
            <summary>
            TextWriter output. For Linq to SQL for example : NORTHWNDDataContext.Log = TTrace.Out 
            </summary>
        </member>
        <member name="M:Comm.Utils.TTrace.Flush">
            flush remaining traces to the viewer
        </member>
        <member name="M:Comm.Utils.TTrace.GetLocalNetworkIP">
            <summary>
            获取本地可用网络IP地址（以太网卡与无线网卡，优先取以太网卡。去除虚拟机网卡/PPP宽带连接网卡）
            </summary>
            <returns></returns>
        </member>
        <member name="F:Comm.Utils.TTrace.s_lastTimeToTheSecond">
            Last stored time with precision up to the second.
        </member>
        <member name="F:Comm.Utils.TTrace.s_lastTime">
            Last stored time with precision up to the second, formatted as a string.
        </member>
        <member name="M:Comm.Utils.TTrace.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)">
            <summary>
            Renders the date into a string. Format is "HH:mm:ss". if Options.SendDate is true , date is added in front
            </summary>
            <remarks>
            This method will be called at most once per second and the result will be
            reused if it is needed again during the same second.
            </remarks>
            <param name="dateToFormat">The date to render into a string.</param>
            <param name="buffer">The string builder to write to.</param>
        </member>
        <member name="M:Comm.Utils.TTrace.FormatDate(System.DateTime)">
            <summary>
            Renders the date into a string. Format is "HH:mm:ss,SSS".
            </summary>
            <remarks>
            <para>Uses the FormatDateWithoutMillis() method to generate the
            time string up to the seconds and then appends the current
            milliseconds. The results from FormatDateWithoutMillis() are
            cached and FormatDateWithoutMillis() is called at most once
            per second.</para>
            <para>Sub classes should override FormatDateWithoutMillis()
            rather than FormatDate().</para>
            </remarks>
            <param name="dateToFormat">The date to render into a string.</param>
            <returns>The stringbuilder passed.</returns>
        </member>
        <member name="T:Comm.Utils.TTraceOptions">
            <summary>
            Options for the traces.
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SendMode">
            <summary>
            Change SendMode to Mode.Socket to use it under ASP
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SocketHost">
            <summary>
            The Socket Host adress
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SocketPort">
            <summary>
            The socket port
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SocketUdp">
            <summary>
            Indicate if the socket use the Udp protocol
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SendFunctions">
            <summary>
            indicate if the reflection should display functions
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SendInherited">
            <summary>
            indicate if the reflections should display inherited members
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SendEvents">
            <summary>
            indicate if the reflections should display the events
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SendPrivate">
            <summary>
            indicate if the reflection should also display private members. Default is false
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.ObjectTreeDepth">
            <summary>
            Max Object tree depth for SendValue and Watches
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SendTypeWithValue">
            <summary>
            Indicate if SendValue and AddValue function should display members type. Default is true
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SendProcessName">
            <summary>
            indicate if the process name must be send. Displayed on the status bar.
            </summary>
        </member>
        <member name="P:Comm.Utils.TTraceOptions.SendDate">
            <summary>
            indicate if the date must be send with the time.
            </summary>
        </member>
        <member name="F:Comm.Utils.TTraceOptions.SendThreadId">
            <summary>
            indicate if the thread id must be send.
            </summary>
        </member>
        <member name="M:Comm.Utils.TTraceOptions.GetDefault">
            <summary>
            return default TraceDisplayFlags options if you don't supply one for the AddObject / AddType / SendObject / SendType functions .
            </summary>
        </member>
        <member name="T:Comm.Utils.ConfigSectionHandler">
            <summary>
            configure tracetool using app.config
            </summary>
        </member>
        <member name="M:Comm.Utils.ConfigSectionHandler.Create(System.Object,System.Object,System.Xml.XmlNode)">
            <summary>
            The returned object is added to the configuration collection and is accessed
            by System.Configuration.ConfigurationSettings.GetConfig(System.String)
            </summary>
            <param name="parent"></param>
            <param name="configContext"></param>
            <param name="section"></param>
            <returns>section</returns>
        </member>
        <member name="T:Comm.Utils.TTraceWriter">
            <summary>
            TextWriter output. For Linq to SQL for example : NORTHWNDDataContext.Log = TTrace.Out 
            </summary>
        </member>
        <member name="T:Comm.Utils.RegistryHelper">
            <summary>
            注册表助手
            </summary>
        </member>
        <member name="M:Comm.Utils.RegistryHelper.ExistSubNode(System.String,System.String)">
            <summary>
            检索是否存在子项
            </summary>
            <param name="parentName">父节点</param>
            <param name="subName">子节点</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.RegistryHelper.GetSubNodes(System.String)">
            <summary>
            获取所有子项数组
            </summary>
            <param name="parentName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.RegistryHelper.GetKeyValue(System.String,System.String)">
            <summary>
            获取注册表节点对应项的值
            </summary>
            <param name="nodeName">注册表节点</param>
            <param name="keyName">项名称</param>
            <returns>项值</returns>
        </member>
        <member name="M:Comm.Utils.RegistryHelper.GetKeyValue(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            获取注册表节点对应项的值
            </summary>
            <param name="root">根节点类型枚举</param>
            <param name="nodeName">注册表节点</param>
            <param name="keyName">项名称</param>
            <returns>项值</returns>
        </member>
        <member name="M:Comm.Utils.RegistryHelper.SetKeyValue(System.String,System.String,System.String)">
            <summary>
            设置注册表节点对应项的值
            </summary>
            <param name="nodeName">注册表节点</param>
            <param name="keyName">项名称</param>
            <param name="keyValue">项值</param>
        </member>
        <member name="M:Comm.Utils.RegistryHelper.SetKeyValue(Microsoft.Win32.RegistryKey,System.String,System.String,System.String)">
            <summary>
            设置注册表节点对应项的值
            </summary>
            <param name="root">根节点类型枚举</param>
            <param name="nodeName">注册表节点</param>
            <param name="keyName">项名称</param>
            <param name="keyValue">项值</param>
        </member>
        <member name="M:Comm.Utils.RegistryHelper.Register(System.String)">
            <summary>
            注册Dll库(OCX)的方法
            </summary>
            <param name="dllFullName">DLL/OCX文件的完整路径</param>
        </member>
        <member name="M:Comm.Utils.RegistryHelper.IsRegister(System.String)">
            <summary>
            判断Dll库(OCX)是否已经注册的方法
            </summary>
            <param name="clsid">Dll的唯一ID</param>
            <returns>true:代表已经注册成功;false:代表未注册成功;</returns>
        </member>
        <member name="T:Comm.Utils.WindowsApi">
            <summary>
            API接口
            </summary>
        </member>
        <member name="M:Comm.Utils.WindowsApi.FindWindow(System.String,System.String)">
            <summary>
            检索处理顶级窗口的类名和窗口名称匹配指定的字符串。这个函数不搜索子窗口
            </summary>
            <param name="lpClassName">参数指向类名</param>
            <param name="lpWindowName">指向窗口名</param>
            <returns>如果有指定的类名和窗口的名字则表示成功返回一个窗口的句柄。否则返回零。</returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.SendMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            将指定的消息发送到一个或多个窗口
            </summary>
            <param name="hWnd">将接收消息的窗口的句柄</param>
            <param name="Msg">指定被发送的消息</param>
            <param name="wParam">指定附加的消息特定信息</param>
            <param name="lParam">指定附加的消息特定信息</param>
            <returns>返回值指定消息处理的结果，依赖于所发送的消息</returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.CloseHandle(System.IntPtr)">
            <summary>
            关闭一个内核对象、句柄
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.GetSystemMetrics(Comm.Utils.SystemMetric)">
            <summary>
            用于得到被定义的系统数据或者系统配置信息
            </summary>
            <param name="smIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.GetLastError">
            <summary>
            该函数返回调用线程最近的错误代码值，错误代码以单线程为基础来维护的，多线程不重写各自的错误代码值
            </summary>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.WaitForSingleObject(System.IntPtr,System.UInt32)">
            <summary>
            等待函数可使线程自愿进入等待状态，直到一个特定的内核对象变为已通知状态为止
            </summary>
            <param name="token"></param>
            <param name="timeInterval"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.LoadLibrary(System.String)">
            <summary>
            加载DLL
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.GetProcAddress(System.IntPtr,System.String)">
            <summary>
            获取DLL函数名
            </summary>
            <param name="libIntPtr"></param>
            <param name="funcName"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.FreeLibrary(System.IntPtr)">
            <summary>
            释放DLL
            </summary>
            <param name="libIntPtr"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.GetWindowThreadProcessId(System.IntPtr,System.Int32@)">
            <summary>
            找出某个窗口的创建者（线程或进程），返回创建者的标志符
            </summary>
            <param name="hWnd">窗口句柄</param>
            <param name="lpdwProcessId">输入线程或进程ID</param>
            <returns>哪个线程创建了这个窗口,返回的就是这个线程的id号 （进程只有一个线程的话，那么线程标志符与进程标志符就是指同一个标志符）</returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.CreateToolhelp32Snapshot(System.Int32,System.Int32)">
            <summary>
            获取进程快照
            </summary>
            <param name="dwFlags">指定快照中包含的系统内容:
            TH32CS_INHERIT - 声明快照句柄是可继承的。
            TH32CS_SNAPALL - 在快照中包含系统中所有的进程和线程。
            TH32CS_SNAPHEAPLIST - 在快照中包含在th32ProcessID中指定的进程的所有的堆。
            TH32CS_SNAPMODULE - 在快照中包含在th32ProcessID中指定的进程的所有的模块。
            TH32CS_SNAPPROCESS - 在快照中包含系统中所有的进程。
            TH32CS_SNAPTHREAD - 在快照中包含系统中所有的线程。
            </param>
            <param name="th32ProcessID">指定将要快照的进程ID,如果该参数为0表示快照当前进程</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.Process32First(System.IntPtr,Comm.Utils.PROCESSENTRY32@)">
            <summary>
            进程获取函数,当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,
            我们可以利用process32First函数来获得第一个进程的句柄
            </summary>
            <param name="hSnapshot"></param>
            <param name="lppe"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.WindowsApi.Process32Next(System.IntPtr,Comm.Utils.PROCESSENTRY32@)">
            <summary>
            进程获取函数,当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,
            我们可以利用process32First函数来获得下一个进程的句柄
            </summary>
            <param name="hSnapshot"></param>
            <param name="lppe"></param>
            <returns></returns>
        </member>
        <member name="T:Comm.Utils.XmlOperate.OperateXmlMethod">
            <summary>
            XML文档的操作类型
            </summary>
        </member>
        <member name="F:Comm.Utils.XmlOperate.OperateXmlMethod.XmlProperty">
            <summary>
            仅操作属性
            </summary>
        </member>
        <member name="F:Comm.Utils.XmlOperate.OperateXmlMethod.XmlNodes">
            <summary>
             仅操作节点
            </summary>
        </member>
        <member name="F:Comm.Utils.XmlOperate.OperateXmlMethod.All">
            <summary>
            属性和节点都操作
            </summary>
        </member>
        <member name="P:Comm.Utils.XmlOperate.fileContent">
            <summary>
            XML格式的内容
            </summary>
        </member>
        <member name="P:Comm.Utils.XmlOperate.filePath">
            <summary>
             XML文件的绝对路径
            </summary>
        </member>
        <member name="P:Comm.Utils.XmlOperate.Method">
            <summary>
            操作方式
            </summary>
        </member>
        <member name="P:Comm.Utils.XmlOperate.xPath">
            <summary>
             xPath表达式
            </summary>
        </member>
        <member name="M:Comm.Utils.XmlOperate.CheckXml(System.String)">
            <summary>
            检测指定节点的属性或者子节点名称是否存在
            </summary>
            <param name="Name">指定属性或子节点</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.XmlOperate.GetXml(System.String)">
            <summary>
            提取指定节点的指定属性或子节点的值
            </summary>
            <param name="name">指定属性或子节点</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.XmlOperate.GetXml(System.String,System.Int32,System.String)">
            <summary>
            提取指定节点的指定属性或子节点的值
            </summary>
            <param name="nodes">指定节点</param>
            <param name="type">0为属性，1为节点</param>
            <param name="name">指定属性或子节点</param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.XmlOperate.GetXmlElement(System.String)">
            <summary>
            提取单个节点的信息(包括属性及其子节点)
            </summary>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:Comm.Utils.XmlOperate.GetXmlNodeList(System.String,System.Int32)">
            <summary>
             提取指定XML文件某个节点的信息(包括属性及其子节点)
            </summary>
            <param name="nodes">要提取的节点位置</param>
            <param name="method">0提取单个节点，1提取所有相关节点</param>
            <returns></returns>
        </member>
        <member name="T:TypeValidate">
            <summary>
            类型验证
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_Date">
            <summary>
            匹配日期格式（年月日之间用“-”隔开）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_Time">
            <summary>
            匹配时间格式
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_DateAndTime">
            <summary>
            匹配日期 + 时间格式（年月日之间用“-”隔开）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_PositiveInteger">
            <summary>
            匹配正整数
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_NegativeInteger">
            <summary>
            匹配负整数
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_PositiveIntegerDecimal">
            <summary>
            匹配正数（需含小数点）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_PositiveIntegerMayContainDecimal">
            <summary>
            匹配正数（可含小数点）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_Numeric">
            <summary>
            匹配数字（含负数、小数）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_Email">
            <summary>
            匹配Email地址
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_EmailAtAfter">
            <summary>
            匹配Email地址（@之后地址，含@）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_Base64String">
            <summary>
            匹配Base64数字编码的字符串
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_CnChar">
            <summary>
            匹配中文字符串
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LetterAndNum">
            <summary>
            匹配字母与数字（单字符）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersAndNumbers">
            <summary>
            匹配字母与数字（多字符）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersAndNumbers6To15">
            <summary>
            匹配字母与数字，长度在{6,15}之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersAndNumbersLimitLength">
            <summary>
            匹配字母与数字，长度在（通过String.Format{0},自定长度）之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersAndUnderline">
            <summary>
            匹配英文、数字与下划线
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersAndUnderline6To15">
            <summary>
            匹配英文、数字与下划线，长度在{6,15}之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersAndUnderlineLimitLength">
            <summary>
            匹配英文、数字与下划线，长度在（通过String.Format{0},自定长度）之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersAndUnderlineStartLetter">
            <summary>
            匹配英文、数字与下划线，须以英文字母开头
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersAndUnderline6To15StartLetter">
            <summary>
            匹配英文、数字与下划线，须以英文字母开头，长度在{6,15}之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersAndUnderlineLimitLengthStartLetter">
            <summary>
            匹配英文、数字与下划线，须以英文字母开头，长度在（通过String.Format{0},自定长度）之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersCnAndUnderline">
            <summary>
            匹配中文、英文、数字与下划线
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersCnAndUnderline6To15">
            <summary>
            匹配中文、英文、数字与下划线，长度在{6,15}之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersCnAndUnderlineLimitLength">
            <summary>
            匹配中文、英文、数字与下划线，长度在（通过String.Format{0},自定长度）之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_LettersNumbersCnAndUnderline6To14">
            <summary>
            匹配中文、英文、数字与下划线，长度在{3,7}汉字之间，或{6,14}字符之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_StrongLettersAndNumbers8To20">
            <summary>
            匹配大小写字母和数字的组合，长度在{8,20}之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_StrongLettersAndNumbersLimitLength">
            <summary>
            匹配大小写字母和数字的组合，长度在（通过String.Format{0},自定长度）之间
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_IPAddress">
            <summary>
            匹配IP地址
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_IPAddressAndPort">
            <summary>
            匹配IP地址（需含端口号）
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_MobileNumber">
            <summary>
            匹配手机号码
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_PhoneNumber">
            <summary>
            匹配电话号码
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_ImgFormat">
            <summary>
            匹配文件名为图片格式扩展名
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_PostalCode">
            <summary>
            匹配邮政编码
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_PhysicalPath">
            <summary>
            匹配物理路径
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_SqlExpression">
            <summary>
            匹配SQL语句
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_Domain">
            <summary>
            匹配域名
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_URL">
            <summary>
            匹配URL地址
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_IdCard">
            <summary>
            匹配15位身份证
            </summary>
        </member>
        <member name="F:TypeValidate.Regex_IdCard18">
            <summary>
            匹配18位身份证
            </summary>
        </member>
        <member name="M:TypeValidate.IsDate(System.String)">
            <summary>
            验证字符串是否为日期格式（年月日之间用“-”隔开）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsTime(System.String)">
            <summary>
            验证是否为时间格式
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsDateAndTime(System.String)">
            <summary>
            验证字符串是否为日期+时间格式（年月日之间用“-”隔开）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsDateTime(System.String)">
            <summary>
            验证字符串是否为DateTime
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsPositiveByte(System.String)">
            <summary>
            验证字符串是否为ASCII数（Byte型）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsPositiveInt(System.String)">
            <summary>
            验证字符串是否为正整数（Int型）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsPositiveLong(System.String)">
            <summary>
            验证字符串是否为正整数（Long型）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsNegativeInt(System.String)">
            <summary>
            验证字符串是否为负整数
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsPositiveIntMayContainDecimal(System.String)">
            <summary>
            验证字符串是否为正数（可含小数点）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsPositiveIntDecimal(System.String)">
            <summary>
            验证字符串是否为正数（需含小数点）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsNumeric(System.String)">
            <summary>
            验证字符串是否为数字（含负数、小数）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsNumericArray(System.String[])">
            <summary>
            验证string[]中的字符串是否都为数字（含负数、小数）
            </summary>
            <param name="valueArray">要验证的字符串数组</param>
            <returns>是则返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsEmail(System.String)">
            <summary>
            验证字符串是否为Email地址
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsEmailAtAfter(System.String)">
            <summary>
            验证字符串是否为Email地址（@之后地址，含@）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsBase64String(System.String)">
            <summary>
            验证字符串是否为Base64数字编码的字符串
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsCnChar(System.String)">
            <summary>
            验证字符串是否为中文字符串
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsLetterAndNum(System.String)">
            <summary>
            验证字符串是否为字母与数字（单字符）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsLettersAndNumbers(System.String,System.Int32,System.Int32)">
            <summary>
            验证字符串是否为字母与数字（多字符）
            </summary>
            <param name="str">要验证的字符串</param>
            <param name="minLen">最小长度</param>
            <param name="maxLen">最大长度</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsLettersNumbersAndUnderline(System.String,System.Int32,System.Int32)">
            <summary>
            验证字符串是否为英文、数字与下划线
            </summary>
            <param name="str">要验证的字符串</param>
            <param name="minLen">最小长度</param>
            <param name="maxLen">最大长度</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsLettersNumbersAndUnderlineStartLetter(System.String,System.Int32,System.Int32)">
            <summary>
            验证字符串是否为英文、数字与下划线，须以英文字母开头
            </summary>
            <param name="str">要验证的字符串</param>
            <param name="minLen">最小长度</param>
            <param name="maxLen">最大长度</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsLettersNumbersCnAndUnderline(System.String,System.Int32,System.Int32)">
            <summary>
            验证字符串是否为中文、英文、数字与下划线
            </summary>
            <param name="str">要验证的字符串</param>
            <param name="minLen">最小长度</param>
            <param name="maxLen">最大长度</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsStrongLettersAndNumbers(System.String,System.Int32,System.Int32)">
            <summary>
            验证字符串是否为中文、英文、数字与下划线
            </summary>
            <param name="str">要验证的字符串</param>
            <param name="minLen">最小长度</param>
            <param name="maxLen">最大长度</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsIPAddress(System.String)">
            <summary>
            验证字符串是否为IP地址
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsIPAddressAndPort(System.String)">
            <summary>
            验证字符串是否为IP地址（需含端口号）
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsMobileNumber(System.String)">
            <summary>
            验证字符串是否为手机号码
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsPhoneNumber(System.String)">
            <summary>
            验证字符串是否为电话号码
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsImageFormat(System.String)">
            <summary>
            验证文件名是否为图片格式扩展名
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsPhysicalPath(System.String)">
            <summary>
            验证字符串是否为物理路径
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsRelativePath(System.String)">
            <summary>
            验证字符串是否为相对路径
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TypeValidate.IsDomain(System.String)">
            <summary>
            验证是否为域名
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsURL(System.String)">
            <summary>
            验证是否为URL地址
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsIDCard(System.String)">
            <summary>
            验证是否为身份证
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsPostalCode(System.String)">
            <summary>
            验证字符串是否为邮政编码
            </summary>
            <param name="str">要验证的字符串</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsUTF8(System.IO.FileStream)">
            <summary>
            验证FileStream是否为 UTF8 编码
            </summary>
            <param name="sbInputStream">文件输入流</param>
            <returns>是返回 true,否则 false</returns>
        </member>
        <member name="M:TypeValidate.IsInArray(System.String,System.String[],System.Boolean)">
            <summary>
            判断字符串1 是否存在于 字符串数组 中
            </summary>
            <param name="str">要匹配的字符串</param>
            <param name="strArray">字符串数组</param>
            <param name="ignoreCase"></param>
            <returns>存在返回是 true,否 false</returns>
        </member>
        <member name="M:TypeValidate.IsInArray(System.String,System.String,System.String,System.Boolean)">
            <summary>
            判断字符串1是否存在于以“separator”分隔的字符串2中
            </summary>
            <param name="str">字符串1</param>
            <param name="originalStr">字符串2</param>
            <param name="separator"></param>
            <param name="ignoreCase"></param>
            <returns></returns>
        </member>
        <member name="M:TypeValidate.IsNull(System.Data.DataSet,System.Boolean,System.Boolean)">
            <summary>
            验证DataSet是否为空
            </summary>
            <param name="value">要验证的值</param>
            <param name="isValidTable">是否验证DataSet.Tables</param>
            <param name="isValidRows">是否验证DataSet.Tables.Rows</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsNull(System.Data.DataTable,System.Boolean)">
            <summary>
            验证DataTable是否为空
            </summary>
            <param name="value">要验证的值</param>
            <param name="isValidRows">是否验证DataTable.Rows</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TypeValidate.IsNull``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)" -->
        <member name="M:TypeValidate.IsNull(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            验证String数组是否为空（包括零长度及第一索引位值为空）
            </summary>
            <param name="value"></param>
            <param name="verify0IndexOf">是否验证零长度及第一索引位值</param>
            <returns></returns>
        </member>
        <member name="M:TypeValidate.IsNull(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            验证int数组是否为空（包括零长度及第一索引位值为空）
            </summary>
            <param name="value">要验证的值</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsNull(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            验证byte数组是否为空（包括零长度及第一索引位值为空）
            </summary>
            <param name="value">要验证的值</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsNull(System.Byte[])">
            <summary>
            验证byte数组是否为空（包括零长度及第一索引位值为空）
            </summary>
            <param name="value">要验证的值</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsNull(System.String)">
            <summary>
            验证String是否为空
            </summary>
            <param name="value">要验证的值</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="M:TypeValidate.IsNull(System.Object)">
            <summary>
            验证object是否为空
            </summary>
            <param name="value">要验证的值</param>
            <returns>是返回true，否则返回false</returns>
        </member>
        <member name="T:TypeParse">
            <summary>
            数据辅助类,提供从 DataTable 到 TEntity 的转换
            </summary>
            <summary>
            类型之间的转换,如:字符串与数字之间的转换
            </summary>
        </member>
        <member name="M:TypeParse.ToEntitys``1(System.Data.DataTable)">
            <summary>
            将DataTable数据转为TEntity指定类型的实体集合
            </summary>
            <typeparam name="TEntity"></typeparam>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ToEntitys``1(System.Data.DataRow[])">
            <summary>
            将DataTable数据转为TEntity指定类型的实体集合
            </summary>
            <typeparam name="TEntity"></typeparam>
            <param name="drs"></param>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ToEntitys``1(System.Collections.Generic.IEnumerable{System.Data.DataRow})">
            <summary>
            将DataTable数据转为TEntity指定类型的实体集合
            </summary>
            <typeparam name="TEntity"></typeparam>
            <param name="drs"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TypeParse.ToEntity``1(System.Data.DataRow,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:TypeParse.ToEntity(System.Data.DataRow,System.Type,System.Boolean)" -->
        <member name="M:TypeParse.CombineClassMemberAsSqlColumn``1">
            <summary>
            将类中包含的每个属性名组合成以“,”分隔的字符串
            </summary>
            <typeparam name="TEntity"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ToBoolean(System.Byte)">
            <summary>
            byte型转换为bool型
            </summary>
            <param name="value">要转换的对象</param>
            <returns>ushort型值</returns>
        </member>
        <member name="M:TypeParse.ToInt16(System.Byte[],System.Boolean,System.Int16)">
            <summary>
            byte[]型转换为System.Int16型（默认低位在前高位在后）
            </summary>
            <param name="value">要转换的对象</param>
            <param name="isHighBefore">是否高位在前</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>short型值</returns>
        </member>
        <member name="M:TypeParse.ToInt32(System.Byte[],System.Boolean,System.Int32)">
            <summary>
            byte[]型转换为System.Int32型（默认低位在前高位在后）
            </summary>
            <param name="value">要转换的对象</param>
            <param name="isHighBefore">是否高位在前</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>int型值</returns>
        </member>
        <member name="M:TypeParse.ToInt64(System.Byte[],System.Boolean,System.Int64)">
            <summary>
            byte[]型转换为System.Int64型（默认低位在前高位在后）
            </summary>
            <param name="value">要转换的对象</param>
            <param name="isHighBefore">是否高位在前</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>long型值</returns>
        </member>
        <member name="M:TypeParse.ToShortForHostToNetworkOrder(System.Byte[],System.Int16)">
            <summary>
            byte[]型转换为System.Int16型（用于将短值由主机字节顺序转换为网络字节顺序）
            </summary>
            <param name="value">要转换的对象</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>short型值</returns>
        </member>
        <member name="M:TypeParse.ToString(System.Byte[],System.String)">
            <summary>
            byte[]型转换为string型
            </summary>
            <param name="value">要转换的对象</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>string型值</returns>
        </member>
        <member name="M:TypeParse.ToString(System.Byte[],System.Text.Encoding,System.String)">
            <summary>
            byte[]型转换为string型
            </summary>
            <param name="value">要转换的对象</param>
            <param name="encoding">要使用的字符编码</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>string型值</returns>
        </member>
        <member name="M:TypeParse.ToUInt32(System.Byte[],System.Int32,System.Boolean,System.UInt32)">
            <summary>
            byte[]型转换为uint型（默认低位在前高位在后）
            </summary>
            <param name="value">要转换的对象</param>
            <param name="index">起始位置索引</param>
            <param name="isHighBefore">是否高位在前</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>ushort型值</returns>
        </member>
        <member name="M:TypeParse.ToUShort(System.Byte[],System.Int32,System.Boolean,System.UInt16)">
            <summary>
            byte[]型转换为ushort型（默认低位在前高位在后）
            </summary>
            <param name="value">要转换的对象</param>
            <param name="index">起始位置索引</param>
            <param name="isHighBefore">是否高位在前</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>ushort型值</returns>
        </member>
        <member name="M:TypeParse.ToHexString(System.Byte[],System.String)">
            <summary>
            byte[]型转换为十六进制的字符串
            </summary>
            <param name="value">要转换的对象</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>十六进制的字符串</returns>
        </member>
        <member name="M:TypeParse.ToHexString(System.Byte[],System.Boolean,System.String)">
            <summary>
            byte[]型转换为十六进制的字符串
            </summary>
            <param name="value">要转换的对象</param>
            <param name="isAddSpaces">是否在每个字节中加空格</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>十六进制的字符串</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TypeParse.ToHexString(System.Byte[],System.String,System.String)" -->
        <member name="M:TypeParse.ToHexString(System.Byte[],System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            byte[]型转换为十六进制的字符串
            </summary>
            <param name="value">要转换的对象</param>
            <param name="startIndex">value内的起始位置</param>
            <param name="lenght">读取的长度</param>
            <param name="isAddSpaces">是否在每个字节中加空格</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>十六进制的字符串</returns>
        </member>
        <member name="M:TypeParse.ToHexString(System.Byte[],System.Int32,System.Int32,System.String,System.String)">
            <summary>
            byte[]型转换为十六进制的字符串
            </summary>
            <param name="value">要转换的对象</param>
            <param name="startIndex">value内的起始位置</param>
            <param name="lenght">读取的长度</param>
            <param name="separator">要用作分隔符的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>十六进制的字符串</returns>
        </member>
        <member name="M:TypeParse.ToUInt16(System.Double,System.UInt16)">
            <summary>
            double型转为UInt16
            </summary>
            <param name="value">要转换的值</param>
            <param name="defValue">缺省值</param>
            <returns>UInt16型值</returns>
        </member>
        <member name="M:TypeParse.ToBytes(System.Int32)">
            <summary>
            Int32型转为byte[]
            </summary>
            <param name="value">要转换的值</param>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ToInt32ForBase(System.Int32,System.Int32,System.Int32)">
            <summary>
            将指定基数的Int32型转换为等效的十进制Int32型
            </summary>
            <param name="value">要转换的值</param>
            <param name="fromBase">value 中数字的基数，它必须是 2、8、10 或 16</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>int型值</returns>
        </member>
        <member name="M:TypeParse.ToInt32(System.Int64,System.Int32)">
            <summary>
            long型转换为int型
            </summary>
            <param name="value">要转换的值</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>int型值</returns>
        </member>
        <member name="M:TypeParse.ToIP(System.Int64)">
            <summary>
            long型IP转换成string型IP
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ToBoolean(System.Object,System.Boolean)">
            <summary>
             object型转换为bool型
            </summary>
            <param name="value">要转换的对象("true" - "1" 或 "false" - "0")</param>
            <param name="defValue">缺省值</param>
            <returns>bool型值</returns>
        </member>
        <member name="M:TypeParse.ToByte(System.Object,System.Byte)">
            <summary>
             object型转换为byte型
            </summary>
            <param name="value">要转换的对象</param>
            <param name="defValue">缺省值</param>
            <returns>byte型值</returns>
        </member>
        <member name="M:TypeParse.ToDecimal(System.Object,System.Decimal)">
            <summary>
             object型转换为decimal型
            </summary>
            <param name="value">要转换的对象</param>
            <param name="defValue">缺省值</param>
            <returns>decimal型值</returns>
        </member>
        <member name="M:TypeParse.ToDouble(System.Object,System.Double)">
            <summary>
             object型转换为double型
            </summary>
            <param name="value">要转换的对象</param>
            <param name="defValue">缺省值</param>
            <returns>double型值</returns>
        </member>
        <member name="M:TypeParse.ToFloat(System.Object,System.Single)">
            <summary>
            object型转换为float型
            </summary>
            <param name="value">要转换的对象</param>
            <param name="defValue">缺省值</param>
            <returns>float型值</returns>
        </member>
        <member name="M:TypeParse.ToInt32(System.Object,System.Int32)">
            <summary>
            object型转换为Int32型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">缺省值</param>
            <returns>Int32型值</returns>
        </member>
        <member name="M:TypeParse.ToInt16(System.Object,System.Int16)">
            <summary>
            object型转换为Int16型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">缺省值</param>
            <returns>Int32型值</returns>
        </member>
        <member name="M:TypeParse.ToUInt16(System.Object,System.UInt16)">
            <summary>
            object型转换为UInt16型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">缺省值</param>
            <returns>Int32型值</returns>
        </member>
        <member name="M:TypeParse.ToDateTime(System.Object)">
            <summary>
            object型转换为DateTime型
            </summary>
            <param name="value">要转换的字符串</param>
            <returns>DateTime型值</returns>
        </member>
        <member name="M:TypeParse.ToDateTime(System.Object,System.DateTime)">
            <summary>
            object型转换为DateTime型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">缺省值</param>
            <returns>DateTime型值</returns>
        </member>
        <member name="M:TypeParse.HexToByteArray(System.String)">
            <summary>
            十六进制值的字符串转为byte[]型
            </summary>
            <param name="hexString">十六进制值的字符串</param>
            <returns>byte[]型值</returns>
        </member>
        <member name="M:TypeParse.ToBoolean(System.String,System.Boolean)">
            <summary>
            string型转换为bool型
            </summary>
            <param name="value">要转换的字符串("true" - "1" 或 "false" - "0")</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>bool型值</returns>
        </member>
        <member name="M:TypeParse.ToByte(System.String,System.Byte)">
            <summary>
            string型转换为byte型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>bool型值</returns>
        </member>
        <member name="M:TypeParse.ToByteForBase(System.String,System.Int32,System.Byte)">
            <summary>
            string型转换为byte型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="fromBase">value 中数字的基数，它必须是 2、8、10 或 16</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>bool型值</returns>
        </member>
        <member name="M:TypeParse.ToByteArray(System.String,System.Byte[])">
            <summary>
            string型转换为byte[]型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>byte[]型值</returns>
        </member>
        <member name="M:TypeParse.ToByteArray(System.String,System.Text.Encoding,System.Byte[])">
            <summary>
            string型转换为byte[]型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="encoding">要使用的字符编码</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>byte[]型值</returns>
        </member>
        <member name="M:TypeParse.ToDateTime(System.String)">
            <summary>
            string型转换为DateTime型
            </summary>
            <param name="value">要转换的字符串</param>
            <returns>DateTime型值</returns>
        </member>
        <member name="M:TypeParse.ToDateTime(System.String,System.DateTime)">
            <summary>
            string型转换为DateTime型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>DateTime型值</returns>
        </member>
        <member name="M:TypeParse.ToDecimal(System.String,System.Decimal)">
            <summary>
            string型转换为decimal型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>decimal型值</returns>
        </member>
        <member name="M:TypeParse.ToDouble(System.String,System.Double)">
            <summary>
            string型转换为double型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>double型值</returns>
        </member>
        <member name="M:TypeParse.ToFloat(System.String,System.Single)">
            <summary>
            string型转换为float型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>float型值</returns>
        </member>
        <member name="M:TypeParse.ToHexString(System.String,System.String)">
            <summary>
            string 型转换为十六进制字符串（字节间使用空格隔开）
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>十六进制字符串</returns>
        </member>
        <member name="M:TypeParse.ToInt16(System.String,System.Int16)">
            <summary>
            string型转换为System.Int32型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>int型值</returns>
        </member>
        <member name="M:TypeParse.ToInt32(System.String,System.Int32)">
            <summary>
            string型转换为System.Int32型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>int型值</returns>
        </member>
        <member name="M:TypeParse.ToUInt16(System.String,System.UInt16)">
            <summary>
            string型转换为System.Int32型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>int型值</returns>
        </member>
        <member name="M:TypeParse.ToInt32ForBase(System.String,System.Int32,System.Int32)">
            <summary>
            string型转换为System.Int32型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="fromBase">value 中数字的基数，它必须是 2、8、10 或 16</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>int型值</returns>
        </member>
        <member name="M:TypeParse.ToInt64(System.String,System.Int64)">
            <summary>
            string型转换为System.Int64型
            </summary>
            <param name="value">要转换的字符串</param>
            <param name="defValue">转换失败后返回的默认值</param>
            <returns>int型值</returns>
        </member>
        <member name="M:TypeParse.ToIp(System.String)">
            <summary>
            string型IP转换成long型
            </summary>
            <param name="strIp"></param>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ToColor(System.String)">
            <summary>
            string型转换为Color型
            </summary>
            <param name="strColor"></param>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ToByte(System.Boolean)">
            <summary>
            string型转换为bool型
            </summary>
            <param name="value">要转换的布尔值("true" 或 "false")</param>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ToInt32(System.Version)">
            <summary>
            Version型转换为Int32型
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TypeParse.ChangeType(System.Type,System.Object)">
            <summary>
            将value转为targetType的对象值
            </summary>
            <param name="targetType"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:DisableAsSqlColumnAttribute">
            <summary>
            配合<see cref="M:TypeParse.CombineClassMemberAsSqlColumn``1"/>方法一起使用,排除不查询列的属性
            </summary>
        </member>
        <member name="M:DisableAsSqlColumnAttribute.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
    </members>
</doc>
